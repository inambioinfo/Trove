package database;

import graph.annotation;
import graph.edge;
import hallmark.allHallmark;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Random;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;

import kinetics.rate;
import constants.stringConstant;
import dataType.diseaseNode;
import dataType.stringArray;
import dataType.targetCombination;
import fileObject.excel2CSV;

//Currently we have ten tables in the curated target DB
//[Target info]		 				Table1 TARGET: <targetID(key)> <targetName> <targetSource> <targetSourceID>
//[Signaling network info]		 	Table2 NETWORK: <networkID(key)> <networkName> <networkSource> <networkSourceID>
//[Disease info]					Table3 DISEASE: <diseaseID(key)> <diseaseName> <diseaseSource> <diseaseSourceID>
//[Organism info]					Table4 ORGANISM: <organismID(key)> <organismName> <organismSource> <organismSourceID>
//[Drug info]						Table5 DRUG: <drugID(key)> <drugName> <drugSource> <drugSourceID>
//[Network_Target info]				Table6 NETWORK_TARGET: <networkID(key)> <targetID(key)>
//[Network_Disease_Organism info]	Table7 NETWORK_DISEASE_ORGANISM: <networkID(key)> <diseaseID(key)> <organismID(key)>
//[Clinical trials info]			Table8 TRIAL: <trialID(key)> <trialSource> <trialSourceID>
//[Target evidence (drug) info]		Table9 DRUG_EVIDENCE: <diseaseID(key)> <organismID(key)> <targetID(key)> <drugID(key)> <source> <sourceID>
//[Target evidence (other) info]	Table10 OTHER_EVIDENCE: <diseaseID(key)> <organismID(key)> <targetID(key)> <source> <sourceID>
//[Data source info]				Table11 SOURCE: <source(key)> <url>
//[Trial_disease_organism_node_drug info] Table12 TRIAL_DISEASE_ORGANISM_TARGET_DRUG: <trialID(key)> <diseaseID(key)> <organismID(key)> <targetID(key)> <drugID(key)>

public class postgreSQL 
{
	protected final static String LIB_FOLDER = "network_lib";
	protected final static String LIB_LIST_FILE = "lib_list.txt";
	protected final static String LIB_EXCEL_TAB_TARGET = "target";
	protected final static String LIB_EXCEL_TAB_SOURCE = "source";
	protected final static String LIB_EXCEL_TAB_NETWORK = "network";
	protected final static int TRAINING_NETWORK_TARGET_TABLE_WITH_QUOTES = 0, TRAINING_NETWORK_TARGET_TABLE_NO_QUOTES = 1, TEMP_TABLE_WITH_QUOTES = 2, TEMP_TABLE_NO_QUOTES = 3;
	protected final static int THIS_NETWORK_WITH_QUOTES = 4, THIS_NETWORK_NO_QUOTES = 5, HALLMARK_TABLE_WITH_QUOTES = 6, HALLMARK_TABLE_NO_QUOTES = 7;
	protected final static int KINETICS_TABLE_WITH_QUOTES = 8, KINETICS_TABLE_NO_QUOTES = 9, NODE_ANNOTATION_TABLE_WITH_QUOTES = 10, NODE_ANNOTATION_TABLE_NO_QUOTES = 11;
	protected final static int SHARED_WITH_QUOTES = 12, SHARED_NO_QUOTES = 13, TEMP_COMBI_TABLE_WITH_QUOTES = 14, TEMP_COMBI_TABLE_NO_QUOTES = 15;
	protected final static int TEMP_SORT_TABLE_WITH_QUOTES = 16, TEMP_SORT_TABLE_NO_QUOTES = 17, CURATED_COMBI_TABLE_WITH_QUOTES=18, CURATED_COMBI_TABLE_NO_QUOTES=19;
	protected final static int PREDICTED_COMBI_TABLE_WITH_QUOTES=20, PREDICTED_COMBI_TABLE_NO_QUOTES=21, CURATED_DRUG_TABLE_WITH_QUOTES=22, CURATED_DRUG_TABLE_NO_QUOTES=23;
	protected final static int DRUG_EVIDENCE = 0, OTHER_EVIDENCE = 1, DISEASE=2, NETWORK=3, ORGANISM=4, TARGET=5, DRUG=6, TRIAL=7;

	private String IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, BRIDGING_COEFFICIENT;
	private String BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, IN_CLUSTERING_COEFFICIENT, OUT_CLUSTERING_COEFFICIENT;
	private String CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, PROXIMITY_PRESTIGE, TARGET_DOWNSTREAM_EFFECT;
	private String PROBABILITY_COEFFICIENT;

	private boolean COMPUTED_IN_DEGREE=false, COMPUTED_OUT_DEGREE=false, COMPUTED_TOTAL_DEGREE=false, COMPUTED_EIGENVECTOR=false;
	private boolean COMPUTED_CLOSENESS=false, COMPUTED_ECCENTRICITY=false, COMPUTED_BETWEENNESS=false, COMPUTED_BRIDGING_COEFFICIENT=false;
	private boolean COMPUTED_BRIDGING_CENTRALITY=false, COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT=false, COMPUTED_IN_CLUSTERING_COEFFICIENT=false;
	private boolean COMPUTED_OUT_CLUSTERING_COEFFICIENT=false, COMPUTED_CYCLE_CLUSTERING_COEFFICIENT=false, COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT=false;
	private boolean COMPUTED_PROXIMITY_PRESTIGE=false, COMPUTED_TARGET_DOWNSTREAM_EFFECT=false;
	private boolean COMPUTED_PROBABILITY_COEFFICIENT=false; //for TDE

	private int MAX_FEATURES=16;
	private stringConstant staticString=new stringConstant();
	private ArrayList<String> featureList=new ArrayList<String>();

	private Connection conn=null;

	public postgreSQL() 
	{
		initializeConstant();
		conn=getConnection();
		//		currWorkingDirectory=System.getProperty("user.dir");
	}

	private void initializeComputedFeature()
	{
		COMPUTED_IN_DEGREE=false;
		COMPUTED_OUT_DEGREE=false; 
		COMPUTED_TOTAL_DEGREE=false;
		COMPUTED_EIGENVECTOR=false;
		COMPUTED_CLOSENESS=false;
		COMPUTED_ECCENTRICITY=false;
		COMPUTED_BETWEENNESS=false;
		COMPUTED_BRIDGING_COEFFICIENT=false;
		COMPUTED_BRIDGING_CENTRALITY=false;
		COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT=false;
		COMPUTED_IN_CLUSTERING_COEFFICIENT=false;
		COMPUTED_OUT_CLUSTERING_COEFFICIENT=false;
		COMPUTED_CYCLE_CLUSTERING_COEFFICIENT=false;
		COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT=false;
		COMPUTED_PROXIMITY_PRESTIGE=false;
		COMPUTED_TARGET_DOWNSTREAM_EFFECT=false;
		COMPUTED_PROBABILITY_COEFFICIENT=false;
	}

	private void initializeConstant()
	{
		IN_DEGREE=staticString.getDBInDegree();
		OUT_DEGREE=staticString.getDBOutDegree();
		TOTAL_DEGREE=staticString.getDBTotalDegree();
		EIGENVECTOR=staticString.getDBEigenvector();
		CLOSENESS=staticString.getDBCloseness();
		ECCENTRICITY=staticString.getDBEccentricity();
		BETWEENNESS=staticString.getDBBetweenness();
		BRIDGING_COEFFICIENT=staticString.getDBBridgingCoeff();
		BRIDGING_CENTRALITY=staticString.getDBBridgingCentrality();
		UNDIRECTED_CLUSTERING_COEFFICIENT=staticString.getDBUndirClustering();
		IN_CLUSTERING_COEFFICIENT=staticString.getDBInClustering();
		OUT_CLUSTERING_COEFFICIENT=staticString.getDBOutClustering();
		CYCLE_CLUSTERING_COEFFICIENT=staticString.getDBCycClustering();
		MIDDLEMAN_CLUSTERING_COEFFICIENT=staticString.getDBMidClustering();
		PROXIMITY_PRESTIGE=staticString.getDBProximityPrestige();
		TARGET_DOWNSTREAM_EFFECT=staticString.getDBTDE();
		PROBABILITY_COEFFICIENT=staticString.getDBProbCoeff();

		featureList.add(IN_DEGREE);
		featureList.add(OUT_DEGREE);
		featureList.add(TOTAL_DEGREE);
		featureList.add(EIGENVECTOR);
		featureList.add(CLOSENESS);
		featureList.add(ECCENTRICITY);
		featureList.add(BETWEENNESS);
		featureList.add(BRIDGING_COEFFICIENT);
		featureList.add(BRIDGING_CENTRALITY);
		featureList.add(UNDIRECTED_CLUSTERING_COEFFICIENT);
		featureList.add(IN_CLUSTERING_COEFFICIENT);
		featureList.add(OUT_CLUSTERING_COEFFICIENT);
		featureList.add(CYCLE_CLUSTERING_COEFFICIENT);
		featureList.add(MIDDLEMAN_CLUSTERING_COEFFICIENT);
		featureList.add(PROXIMITY_PRESTIGE);
		featureList.add(TARGET_DOWNSTREAM_EFFECT);
	}

	private boolean checkTableExistence(ArrayList<String> tableList)
	{
		try {
			int tablesExist=0;
			String tableListStr=tableList.toString();
			tableListStr=tableListStr.substring(1, tableListStr.length()-1);

			Statement statement = conn.createStatement();
			System.out.println("SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME IN "
					+ "("+tableListStr+") HAVING COUNT (DISTINCT TABLE_NAME)="+tableList.size());
			//check existence of all tables
			ResultSet result = statement.executeQuery("SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME IN "
					+ "("+tableListStr+") HAVING COUNT (DISTINCT TABLE_NAME)="+tableList.size());
			if(result.next())
				tablesExist=result.getInt(1);

			statement.close();
			result.close();

			if(tablesExist==1)
				return true;

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	private void dropTable(ArrayList<String> tableList)
	{
		try {
			String tableListStr=tableList.toString();
			tableListStr=tableListStr.substring(1, tableListStr.length()-1);

			Connection conn=getConnection();
			Statement statement = conn.createStatement();
			//drop table if it exists
			statement.execute("DROP TABLE IF EXISTS "+ tableListStr + " CASCADE;"); 

			//will commit automatically
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createTrainingNetworkTargetTables()
	{
		try {
			//create all tables
			Statement statement= conn.createStatement();

			String sqlCreateTargetTab="CREATE TABLE TARGET (TARGET_ID INTEGER PRIMARY KEY NOT NULL, TARGET_NAME TEXT NOT NULL, TARGET_SOURCE TEXT, TARGET_SOURCE_ID TEXT,"
					+ "FOREIGN KEY (TARGET_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateNetworkTab="CREATE TABLE NETWORK (NETWORK_ID INTEGER PRIMARY KEY NOT NULL, NETWORK_NAME TEXT NOT NULL,"
					+ "NETWORK_SOURCE TEXT, NETWORK_SOURCE_ID TEXT, FOREIGN KEY (NETWORK_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateDiseaseTab="CREATE TABLE DISEASE (DISEASE_ID INTEGER PRIMARY KEY NOT NULL, DISEASE_NAME TEXT NOT NULL,"
					+ "DISEASE_SOURCE TEXT, DISEASE_SOURCE_ID TEXT, FOREIGN KEY (DISEASE_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);"; //KEGG database
			String sqlCreateOrganismTab="CREATE TABLE ORGANISM (ORGANISM_ID INTEGER PRIMARY KEY NOT NULL, ORGANISM_NAME TEXT NOT NULL,"
					+ "ORGANISM_SOURCE TEXT, ORGANISM_SOURCE_ID TEXT, FOREIGN KEY (ORGANISM_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);"; //KEGG database
			String sqlCreateDrugTab="CREATE TABLE DRUG (DRUG_ID INTEGER PRIMARY KEY NOT NULL, DRUG_NAME TEXT NOT NULL,"
					+ "DRUG_SOURCE TEXT, DRUG_SOURCE_ID TEXT, FOREIGN KEY (DRUG_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);"; //Drugbank database
			String sqlCreateNetworkTargetTab="CREATE TABLE NETWORK_TARGET (NETWORK_ID INTEGER NOT NULL, TARGET_ID INTEGER NOT NULL, "
					+ "PRIMARY KEY (NETWORK_ID, TARGET_ID), FOREIGN KEY (NETWORK_ID) REFERENCES NETWORK(NETWORK_ID) ON DELETE CASCADE,"
					+ "FOREIGN KEY (TARGET_ID) REFERENCES TARGET(TARGET_ID) ON DELETE CASCADE);"; 
			String sqlCreateNetworkDiseaseOrganismTab="CREATE TABLE NETWORK_DISEASE_ORGANISM (NETWORK_ID INTEGER NOT NULL, DISEASE_ID INTEGER NOT NULL,"
					+ "ORGANISM_ID INTEGER NOT NULL, PRIMARY KEY (NETWORK_ID, DISEASE_ID, ORGANISM_ID));"; 
			String sqlCreateTrialTab="CREATE TABLE TRIAL (TRIAL_ID INTEGER PRIMARY KEY NOT NULL, TRIAL_SOURCE TEXT NOT NULL, TRIAL_SOURCE_ID TEXT NOT NULL, "
					+ "FOREIGN KEY (TRIAL_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateOtherEvidenceTab="CREATE TABLE OTHER_EVIDENCE (DISEASE_ID INTEGER NOT NULL, ORGANISM_ID INTEGER NOT NULL, TARGET_ID INTEGER NOT NULL,"
					+ "EVIDENCE_SOURCE TEXT NOT NULL, EVIDENCE_SOURCE_ID TEXT NOT NULL, PRIMARY KEY (DISEASE_ID, ORGANISM_ID, TARGET_ID), "
					+ "FOREIGN KEY (DISEASE_ID) REFERENCES DISEASE(DISEASE_ID) ON DELETE CASCADE, FOREIGN KEY (ORGANISM_ID) REFERENCES ORGANISM(ORGANISM_ID) ON DELETE CASCADE,"
					+ "FOREIGN KEY (TARGET_ID) REFERENCES TARGET(TARGET_ID) ON DELETE CASCADE, FOREIGN KEY (EVIDENCE_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateDrugEvidenceTab="CREATE TABLE DRUG_EVIDENCE (DISEASE_ID INTEGER NOT NULL, ORGANISM_ID INTEGER NOT NULL, TARGET_ID INTEGER NOT NULL, DRUG_ID INTEGER NOT NULL,"
					+ "EVIDENCE_SOURCE TEXT NOT NULL, EVIDENCE_SOURCE_ID TEXT NOT NULL, PRIMARY KEY (DISEASE_ID, ORGANISM_ID, TARGET_ID, DRUG_ID), "
					+ "FOREIGN KEY (DISEASE_ID) REFERENCES DISEASE(DISEASE_ID) ON DELETE CASCADE, FOREIGN KEY (ORGANISM_ID) REFERENCES ORGANISM(ORGANISM_ID) ON DELETE CASCADE,"
					+ "FOREIGN KEY (TARGET_ID) REFERENCES TARGET(TARGET_ID) ON DELETE CASCADE, FOREIGN KEY (DRUG_ID) REFERENCES DRUG(DRUG_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (EVIDENCE_SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateSourceTab="CREATE TABLE SOURCE (SOURCE_NAME TEXT PRIMARY KEY NOT NULL, SOURCE_URL TEXT)";
			String sqlCreateTrialDiseaseOrganismTargetDrugTab="CREATE TABLE TRIAL_DISEASE_ORGANISM_TARGET_DRUG (TRIAL_ID INTEGER NOT NULL, DISEASE_ID INTEGER NOT NULL, ORGANISM_ID INTEGER NOT NULL,"
					+ "TARGET_ID INTEGER NOT NULL, DRUG_ID INTEGER NOT NULL, PRIMARY KEY (TRIAL_ID, DISEASE_ID, ORGANISM_ID, TARGET_ID, DRUG_ID), "
					+ "FOREIGN KEY (DISEASE_ID) REFERENCES DISEASE(DISEASE_ID) ON DELETE CASCADE, FOREIGN KEY (DRUG_ID) REFERENCES DRUG(DRUG_ID) ON DELETE CASCADE,"
					+ "FOREIGN KEY (ORGANISM_ID) REFERENCES ORGANISM(ORGANISM_ID) ON DELETE CASCADE, FOREIGN KEY (TARGET_ID) REFERENCES TARGET(TARGET_ID) ON DELETE CASCADE,"
					+ "FOREIGN KEY (TRIAL_ID) REFERENCES TRIAL(TRIAL_ID) ON DELETE CASCADE);";

			statement.execute(sqlCreateSourceTab);
			statement.execute(sqlCreateTargetTab);
			statement.execute(sqlCreateNetworkTab);
			statement.execute(sqlCreateDiseaseTab);
			statement.execute(sqlCreateOrganismTab);
			statement.execute(sqlCreateDrugTab);
			statement.execute(sqlCreateNetworkTargetTab);
			statement.execute(sqlCreateNetworkDiseaseOrganismTab);
			statement.execute(sqlCreateTrialTab);
			statement.execute(sqlCreateOtherEvidenceTab);
			statement.execute(sqlCreateDrugEvidenceTab);
			statement.execute(sqlCreateTrialDiseaseOrganismTargetDrugTab);
			//will commit automatically
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createSharedTables()
	{
		try {
			//create shared tables
			Statement statement= conn.createStatement();

			String sqlCreateSourceTab="CREATE TABLE SOURCE (SOURCE_NAME TEXT PRIMARY KEY NOT NULL, SOURCE_URL TEXT, SOURCE_NUM_PARAM INTEGER)";

			statement.execute(sqlCreateSourceTab);
			//will commit automatically
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createThisNetwork()
	{
		try {
			//create all tables
			Statement statement= conn.createStatement();

			String sqlCreateNodeTab="CREATE TABLE CURR_NETWORK_NODE (NODE_ID INTEGER PRIMARY KEY NOT NULL, SBML_NODE_ID TEXT UNIQUE, SBML_NODE_NAME TEXT NOT NULL, "
					+ "IN_DEGREE NUMERIC, OUT_DEGREE NUMERIC, TOTAL_DEGREE NUMERIC, EIGENVECTOR NUMERIC, CLOSENESS NUMERIC, ECCENTRICITY NUMERIC, BETWEENNESS NUMERIC, BRIDGING_COEFFICIENT NUMERIC, "
					+ "BRIDGING_CENTRALITY NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT NUMERIC, IN_CLUSTERING_COEFFICIENT NUMERIC, OUT_CLUSTERING_COEFFICIENT NUMERIC, CYCLE_CLUSTERING_COEFFICIENT NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT NUMERIC, PROXIMITY_PRESTIGE NUMERIC, TARGET_DOWNSTREAM_EFFECT NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE NUMERIC, PROBABILITY_COEFFICIENT NUMERIC);";
			String sqlCreateEdgeTab="CREATE TABLE CURR_NETWORK_EDGE (SOURCE_NODE_ID INTEGER NOT NULL, TARGET_NODE_ID INTEGER NOT NULL, EDGE_TYPE TEXT, "
					+ "PRIMARY KEY (SOURCE_NODE_ID, TARGET_NODE_ID), FOREIGN KEY (SOURCE_NODE_ID) REFERENCES CURR_NETWORK_NODE(NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (TARGET_NODE_ID) REFERENCES CURR_NETWORK_NODE(NODE_ID) ON DELETE CASCADE);";
			String sqlCreateNodeRankTab="CREATE TABLE CURR_NETWORK_NODE_RANKS (NODE_ID INTEGER PRIMARY KEY NOT NULL, SBML_NODE_ID TEXT NOT NULL, SBML_NODE_NAME TEXT, "
					+ "IN_DEGREE_RANK NUMERIC, OUT_DEGREE_RANK NUMERIC, TOTAL_DEGREE_RANK NUMERIC, EIGENVECTOR_RANK NUMERIC, CLOSENESS_RANK NUMERIC, ECCENTRICITY_RANK NUMERIC, BETWEENNESS_RANK NUMERIC, BRIDGING_COEFFICIENT_RANK NUMERIC, "
					+ "BRIDGING_CENTRALITY_RANK NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT_RANK NUMERIC, IN_CLUSTERING_COEFFICIENT_RANK NUMERIC, OUT_CLUSTERING_COEFFICIENT_RANK NUMERIC, CYCLE_CLUSTERING_COEFFICIENT_RANK NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT_RANK NUMERIC, PROXIMITY_PRESTIGE_RANK NUMERIC, TARGET_DOWNSTREAM_EFFECT_RANK NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE_RANK NUMERIC, PROBABILITY_COEFFICIENT_RANK NUMERIC);";
			String sqlCreateNormalizedNodeRankTab="CREATE TABLE CURR_NETWORK_NODE_NORMALIZED_RANKS (NODE_ID INTEGER PRIMARY KEY NOT NULL, SBML_NODE_ID TEXT NOT NULL, SBML_NODE_NAME TEXT, "
					+ "IN_DEGREE_RANK NUMERIC, OUT_DEGREE_RANK NUMERIC, TOTAL_DEGREE_RANK NUMERIC, EIGENVECTOR_RANK NUMERIC, CLOSENESS_RANK NUMERIC, ECCENTRICITY_RANK NUMERIC, BETWEENNESS_RANK NUMERIC, BRIDGING_COEFFICIENT_RANK NUMERIC, "
					+ "BRIDGING_CENTRALITY_RANK NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT_RANK NUMERIC, IN_CLUSTERING_COEFFICIENT_RANK NUMERIC, OUT_CLUSTERING_COEFFICIENT_RANK NUMERIC, CYCLE_CLUSTERING_COEFFICIENT_RANK NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT_RANK NUMERIC, PROXIMITY_PRESTIGE_RANK NUMERIC, TARGET_DOWNSTREAM_EFFECT_RANK NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE_RANK NUMERIC, PROBABILITY_COEFFICIENT_RANK NUMERIC);";
			String sqlCreateFeatureTab="CREATE TABLE CURR_NETWORK_FEATURE (FEATURE_ID INTEGER PRIMARY KEY NOT NULL, FEATURE_NAME NUMERIC NOT NULL, WILCOXON_PVALUE NUMERIC, ROC_AUC NUMERIC);";
			String sqlCreateModelAccuracyTab="CREATE TABLE CURR_NETWORK_MODEL_ACCURACY (MODEL_ID INTEGER PRIMARY KEY NOT NULL, WEIGHT NUMERIC NOT NULL, C NUMERIC NOT NULL, ACCURACY NUMERIC NOT NULL, "
					+ "IN_DEGREE NUMERIC, OUT_DEGREE NUMERIC, TOTAL_DEGREE NUMERIC, EIGENVECTOR NUMERIC, CLOSENESS NUMERIC, ECCENTRICITY NUMERIC, BETWEENNESS NUMERIC, BRIDGING_COEFFICIENT NUMERIC, "
					+ "BRIDGING_CENTRALITY NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT NUMERIC, IN_CLUSTERING_COEFFICIENT NUMERIC, OUT_CLUSTERING_COEFFICIENT NUMERIC, CYCLE_CLUSTERING_COEFFICIENT NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT NUMERIC, PROXIMITY_PRESTIGE NUMERIC, TARGET_DOWNSTREAM_EFFECT NUMERIC);";
			String sqlCreateMetadataTab="CREATE TABLE CURR_NETWORK_METADATA (NETWORK_NAME TEXT PRIMARY KEY NOT NULL, VERSION TEXT);";
			String sqlCreateCandidateCombiSize2_Test1Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST1 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test2Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST2 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test3Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST3 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test4Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST4 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test5Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST5 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test6Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST6 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test7Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST7 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test8Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST8 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test9Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST9 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize2_Test10Tab="CREATE TABLE CANDIDATE_COMBI_SIZE2_TEST10 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test1Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST1 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test2Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST2 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test3Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST3 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test4Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST4 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test5Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST5 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test6Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST6 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test7Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST7 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test8Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST8 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test9Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST9 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize3_Test10Tab="CREATE TABLE CANDIDATE_COMBI_SIZE3_TEST10 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";			
			String sqlCreateCandidateCombiSize4_Test1Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST1 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test2Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST2 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test3Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST3 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test4Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST4 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test5Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST5 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test6Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST6 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test7Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST7 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test8Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST8 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test9Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST9 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize4_Test10Tab="CREATE TABLE CANDIDATE_COMBI_SIZE4_TEST10 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, NODE_ID_4 TEXT NOT NULL, "
					+ "ESSENTIAL_NODE_FRACTION TEXT, NON_DISEASE_OUT_DEGREE_FRACTION TEXT, " 
					+ "FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateCandidateCombiSize5Tab="CREATE TABLE CANDIDATE_COMBI_SIZE_5 (COMBI_INDEX INTEGER PRIMARY KEY NOT NULL, NODE_ID_1 TEXT NOT NULL, NODE_ID_2 TEXT NOT NULL, NODE_ID_3 TEXT NOT NULL, "
					+ "NODE_ID_4 TEXT NOT NULL, NODE_ID_5 TEXT NOT NULL, FOREIGN KEY (NODE_ID_1) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_2) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_3) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_4) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (NODE_ID_5) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateViewEssentialGenesTab="CREATE TABLE NETWORK_VIEW_NODE_ESSENTIAL (VIEW_NAME TEXT NOT NULL, NODE_ID TEXT NOT NULL, " 
					+ "PRIMARY KEY (VIEW_NAME, NODE_ID), FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateViewFoldChangeTab="CREATE TABLE NETWORK_VIEW_NODE_FOLDCHANGE (VIEW_NAME TEXT NOT NULL, NODE_ID TEXT NOT NULL, FOLD_CHANGE TEXT NOT NULL, " 
					+ "PRIMARY KEY (VIEW_NAME, NODE_ID), FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreateViewMutationTab="CREATE TABLE NETWORK_VIEW_NODE_MUTATION (VIEW_NAME TEXT NOT NULL, NODE_ID TEXT NOT NULL, PERCENTAGE TEXT NOT NULL, " 
					+ "PRIMARY KEY (VIEW_NAME, NODE_ID), FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(SBML_NODE_ID) ON DELETE CASCADE);";
			String sqlCreatePathwayNodeTab="CREATE TABLE CURR_PATHWAY_NODE (NODE_ID INTEGER PRIMARY KEY NOT NULL, SBML_NODE_ID TEXT, SBML_NODE_NAME TEXT NOT NULL, "
					+ "IN_DEGREE NUMERIC, OUT_DEGREE NUMERIC, TOTAL_DEGREE NUMERIC, EIGENVECTOR NUMERIC, CLOSENESS NUMERIC, ECCENTRICITY NUMERIC, BETWEENNESS NUMERIC, BRIDGING_COEFFICIENT NUMERIC, "
					+ "BRIDGING_CENTRALITY NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT NUMERIC, IN_CLUSTERING_COEFFICIENT NUMERIC, OUT_CLUSTERING_COEFFICIENT NUMERIC, CYCLE_CLUSTERING_COEFFICIENT NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT NUMERIC, PROXIMITY_PRESTIGE NUMERIC, TARGET_DOWNSTREAM_EFFECT NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE NUMERIC, PROBABILITY_COEFFICIENT NUMERIC);";
			String sqlCreatePathwayNodeRankTab="CREATE TABLE CURR_PATHWAY_NODE_RANKS (NODE_ID INTEGER PRIMARY KEY NOT NULL, SBML_NODE_ID TEXT NOT NULL, SBML_NODE_NAME TEXT, "
					+ "IN_DEGREE_RANK NUMERIC, OUT_DEGREE_RANK NUMERIC, TOTAL_DEGREE_RANK NUMERIC, EIGENVECTOR_RANK NUMERIC, CLOSENESS_RANK NUMERIC, ECCENTRICITY_RANK NUMERIC, BETWEENNESS_RANK NUMERIC, BRIDGING_COEFFICIENT_RANK NUMERIC, "
					+ "BRIDGING_CENTRALITY_RANK NUMERIC, UNDIRECTED_CLUSTERING_COEFFICIENT_RANK NUMERIC, IN_CLUSTERING_COEFFICIENT_RANK NUMERIC, OUT_CLUSTERING_COEFFICIENT_RANK NUMERIC, CYCLE_CLUSTERING_COEFFICIENT_RANK NUMERIC, "
					+ "MIDDLEMAN_CLUSTERING_COEFFICIENT_RANK NUMERIC, PROXIMITY_PRESTIGE_RANK NUMERIC, TARGET_DOWNSTREAM_EFFECT_RANK NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE_RANK NUMERIC, PROBABILITY_COEFFICIENT_RANK NUMERIC);";
			String sqlCreateNetworkHallmarkCharacterizationTab="CREATE TABLE CURR_NETWORK_HALLMARK_CHARACTERIZATION (HALLMARK TEXT PRIMARY KEY NOT NULL, MODEL_FILENAME TEXT, WEIGHT NUMERIC, C NUMERIC, ACCURACY NUMERIC, "
					+ "IN_DEGREE NUMERIC, OUT_DEGREE NUMERIC, TOTAL_DEGREE NUMERIC, EIGENVECTOR NUMERIC, CLOSENESS NUMERIC, ECCENTRICITY NUMERIC, BETWEENNESS NUMERIC, BRIDGING_COEFFICIENT NUMERIC, BRIDGING_CENTRALITY NUMERIC, "
					+ "UNDIRECTED_CLUSTERING_COEFFICIENT NUMERIC, IN_CLUSTERING_COEFFICIENT NUMERIC, OUT_CLUSTERING_COEFFICIENT NUMERIC, CYCLE_CLUSTERING_COEFFICIENT NUMERIC, MIDDLEMAN_CLUSTERING_COEFFICIENT NUMERIC, "
					+ "PROXIMITY_PRESTIGE NUMERIC, TARGET_DOWNSTREAM_EFFECT NUMERIC, PROFILE_SHAPE_SIMILARITY_DISTANCE NUMERIC, PROBABILITY_COEFFICIENT NUMERIC);";
			statement.execute(sqlCreateNodeTab);
			statement.execute(sqlCreateEdgeTab);
			statement.execute(sqlCreateNormalizedNodeRankTab);
			statement.execute(sqlCreateFeatureTab);
			statement.execute(sqlCreateModelAccuracyTab);
			statement.execute(sqlCreateMetadataTab);
			statement.execute(sqlCreateCandidateCombiSize2_Test1Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test2Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test3Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test4Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test5Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test6Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test7Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test8Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test9Tab);
			statement.execute(sqlCreateCandidateCombiSize2_Test10Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test1Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test2Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test3Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test4Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test5Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test6Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test7Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test8Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test9Tab);
			statement.execute(sqlCreateCandidateCombiSize3_Test10Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test1Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test2Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test3Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test4Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test5Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test6Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test7Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test8Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test9Tab);
			statement.execute(sqlCreateCandidateCombiSize4_Test10Tab);
			statement.execute(sqlCreateCandidateCombiSize5Tab);
			statement.execute(sqlCreateViewEssentialGenesTab);
			statement.execute(sqlCreateViewFoldChangeTab);
			statement.execute(sqlCreateViewMutationTab);
			statement.execute(sqlCreateNodeRankTab);
			statement.execute(sqlCreatePathwayNodeTab);
			statement.execute(sqlCreatePathwayNodeRankTab);
			statement.execute(sqlCreateNetworkHallmarkCharacterizationTab);
			//will commit automatically
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createTempTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateTempNetworkTab="CREATE TABLE IF NOT EXISTS TEMP_NETWORK (NETWORK_NAME TEXT PRIMARY KEY NOT NULL, NETWORK_SOURCE TEXT, NETWORK_SOURCE_ID TEXT, DISEASE_NAME TEXT NOT NULL,"
					+ "DISEASE_SOURCE TEXT, DISEASE_SOURCE_ID TEXT, ORGANISM_NAME TEXT NOT NULL, ORGANISM_SOURCE TEXT, ORGANISM_SOURCE_ID TEXT);";
			String sqlCreateTempTargetTab="CREATE TABLE IF NOT EXISTS TEMP_TARGET (ENTRY TEXT PRIMARY KEY NOT NULL, TARGET_NAME TEXT NOT NULL, TARGET_SOURCE TEXT, TARGET_SOURCE_ID TEXT, DRUG_NAME TEXT,"
					+ "DRUG_SOURCE TEXT, DRUG_SOURCE_ID TEXT, EVIDENCE_SOURCE TEXT NOT NULL, EVIDENCE_SOURCE_ID TEXT NOT NULL, TRIAL_SOURCE TEXT,"
					+ "TRIAL_SOURCE_ID TEXT);";
			//will commit automatically			
			statement.execute(sqlCreateTempNetworkTab);
			statement.execute(sqlCreateTempTargetTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void createTargetCombiTempTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateTempAllAncestorsOfDiseaseNodeTab="CREATE TABLE IF NOT EXISTS TEMP_ALL_ANCESTORS_OF_DISEASE_NODES (NODE TEXT NOT NULL, ANCESTOR TEXT NOT NULL, JACCARD NUMERIC NOT NULL, PRIMARY KEY (NODE, ANCESTOR, JACCARD));";
			String sqlCreateTempCombination1Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_1 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination2Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_2 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination3Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_3 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination4Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_4 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination5Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_5 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination6Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_6 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination7Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_7 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination8Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_8 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination9Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_9 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombination10Tab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_10 (COMBI TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET NUMERIC, OUTDEGREE_OFFTARGET NUMERIC, OFFTARGET_SCORE NUMERIC, DISEASE_NODE_COVERAGE NUMERIC, ELAPSED_TIME NUMERIC, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			String sqlCreateTempCombinationSummaryTab="CREATE TABLE IF NOT EXISTS TEMP_COMBI_SUMMARY (TRIAL TEXT PRIMARY KEY NOT NULL, TEMPERATURE NUMERIC, ITERATION NUMERIC, ELAPSED_TIME NUMERIC);";
			String sqlCreateTempCandidateHallmarkRankTab="CREATE TABLE IF NOT EXISTS TEMP_CANDIDATE_HALLMARK_RANK (CANDIDATE TEXT PRIMARY KEY NOT NULL, JACCARD_INDEX NUMERIC, RANK NUMERIC, SELECTION_PROBABILITY NUMERIC);";
			String sqlCreateTempCandidateAllTab="CREATE TABLE IF NOT EXISTS TEMP_CANDIDATE_ALL (METANODE TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, DISEASE_NODE_NUM INTEGER);";
			String sqlCreateTempCandidateTab="CREATE TABLE IF NOT EXISTS TEMP_CANDIDATE (NEXTNODE TEXT PRIMARY KEY NOT NULL, DISEASE_NODE_LIST TEXT NOT NULL, ESSENTIAL_OFFTARGET TEXT, OUTDEGREE_OFFTARGET TEXT, OFFTARGET_SCORE DECIMAL, DISEASE_NODE_NUM INTEGER, JACCARD NUMERIC, OVERALL_SCORE NUMERIC);";
			//will commit automatically			
			statement.execute(sqlCreateTempAllAncestorsOfDiseaseNodeTab);
			statement.execute(sqlCreateTempCombination1Tab);
			statement.execute(sqlCreateTempCombination2Tab);
			statement.execute(sqlCreateTempCombination3Tab);
			statement.execute(sqlCreateTempCombination4Tab);
			statement.execute(sqlCreateTempCombination5Tab);
			statement.execute(sqlCreateTempCombination6Tab);
			statement.execute(sqlCreateTempCombination7Tab);
			statement.execute(sqlCreateTempCombination8Tab);
			statement.execute(sqlCreateTempCombination9Tab);
			statement.execute(sqlCreateTempCombination10Tab);
			statement.execute(sqlCreateTempCombinationSummaryTab);
			statement.execute(sqlCreateTempCandidateHallmarkRankTab);
			statement.execute(sqlCreateTempCandidateAllTab);
			statement.execute(sqlCreateTempCandidateTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createPredictedCombiTables()
	{
		try {
			Statement statement= conn.createStatement();
			//drop temporary tables
			dropTable(initTableList(PREDICTED_COMBI_TABLE_NO_QUOTES));

			String sqlCreatePredictedCombiCombiTab="CREATE TABLE IF NOT EXISTS PREDICTEDCOMBI_COMBI (COMBI_ID INTEGER PRIMARY KEY NOT NULL, METHOD TEXT NOT NULL, SCORE TEXT NOT NULL, TARGET_1_NAME TEXT NOT NULL, TARGET_2_NAME TEXT NOT NULL, " +
					"TARGET_1_IN_CURATION INTEGER NOT NULL, TARGET_2_IN_CURATION INTEGER NOT NULL, COMBI_IN_CURATION INTEGER NOT NULL);";
			String sqlCreatePredictedCombiNCTIDTab="CREATE TABLE IF NOT EXISTS PREDICTEDCOMBI_NCTID (COMBI_ID INTEGER NOT NULL, NCTID TEXT NOT NULL, PRIMARY KEY (COMBI_ID, NCTID), FOREIGN KEY (COMBI_ID) REFERENCES PREDICTEDCOMBI_COMBI(COMBI_ID) ON DELETE CASCADE);";
			//will commit automatically			
			statement.execute(sqlCreatePredictedCombiCombiTab);
			statement.execute(sqlCreatePredictedCombiNCTIDTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createCuratedDrugTables()
	{
		try {
			Statement statement= conn.createStatement();
			//drop temporary tables
			dropTable(initTableList(CURATED_DRUG_TABLE_NO_QUOTES));

			String sqlCreateCuratedMonoTargetTab="CREATE TABLE IF NOT EXISTS CURATEDMONO_TARGET (TARGET_ID INTEGER PRIMARY KEY NOT NULL, TARGET_NAME TEXT NOT NULL);";
			String sqlCreateCuratedMonoDrugTab="CREATE TABLE IF NOT EXISTS CURATEDMONO_DRUG (DRUG TEXT NOT NULL, TARGET_ID INTEGER NOT NULL, PRIMARY KEY (DRUG, TARGET_ID), FOREIGN KEY (TARGET_ID) REFERENCES CURATEDMONO_TARGET(TARGET_ID) ON DELETE CASCADE);";
			//will commit automatically			
			statement.execute(sqlCreateCuratedMonoTargetTab);
			statement.execute(sqlCreateCuratedMonoDrugTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createCuratedCombiTables()
	{
		try {
			Statement statement= conn.createStatement();
			//drop temporary tables
			dropTable(initTableList(CURATED_COMBI_TABLE_NO_QUOTES));

			String sqlCreateCuratedCombiCombiTab="CREATE TABLE IF NOT EXISTS CURATEDCOMBI_COMBI (COMBI_ID INTEGER PRIMARY KEY NOT NULL, TARGET_1_NAME TEXT NOT NULL, TARGET_2_NAME TEXT NOT NULL);";
			String sqlCreateCuratedCombiNCTIDTab="CREATE TABLE IF NOT EXISTS CURATEDCOMBI_NCTID (COMBI_ID INTEGER NOT NULL, NCTID TEXT NOT NULL, PRIMARY KEY (COMBI_ID, NCTID), FOREIGN KEY (COMBI_ID) REFERENCES CURATEDCOMBI_COMBI(COMBI_ID) ON DELETE CASCADE);";
			String sqlCreateCuratedCombiDiseaseTab="CREATE TABLE IF NOT EXISTS CURATEDCOMBI_DISEASE (COMBI_ID INTEGER NOT NULL, DISEASE TEXT NOT NULL, PRIMARY KEY (COMBI_ID, DISEASE), FOREIGN KEY (COMBI_ID) REFERENCES CURATEDCOMBI_COMBI(COMBI_ID) ON DELETE CASCADE);";
			//will commit automatically			
			statement.execute(sqlCreateCuratedCombiCombiTab);
			statement.execute(sqlCreateCuratedCombiNCTIDTab);
			statement.execute(sqlCreateCuratedCombiDiseaseTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createHallmarkTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateHallmarkHallmarkTab="CREATE TABLE IF NOT EXISTS HALLMARK_HALLMARK (NODE_ID INTEGER PRIMARY KEY NOT NULL, PROLIFERATION TEXT, GROWTH_REPRESSOR TEXT, APOPTOSIS TEXT, "
					+ "REPLICATIVE_IMMORTALITY TEXT, ANGIOGENESIS TEXT, METASTASIS TEXT, METABOLISM TEXT, IMMUNE_DESTRUCTION TEXT, GENOME_INSTABILITY TEXT, TUMOR_PROMOTING_INFLAMMATION TEXT, " 
					+ "FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(NODE_ID) ON DELETE CASCADE);";
			String sqlCreateHallmarkAnnotationTab="CREATE TABLE IF NOT EXISTS HALLMARK_ANNOTATION (NODE_ID INTEGER NOT NULL, ANNOTATION_TYPE TEXT NOT NULL, ANNOTATION_ID TEXT NOT NULL, "
					+ "PRIMARY KEY (NODE_ID, ANNOTATION_TYPE, ANNOTATION_ID), FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (ANNOTATION_TYPE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateHallmarkGoMappingTab="CREATE TABLE IF NOT EXISTS HALLMARK_GO_MAPPING (HALLMARK_TYPE TEXT NOT NULL, GO_ID TEXT NOT NULL, GO_NAME TEXT NOT NULL, GO_TYPE TEXT NOT NULL, "
					+ "PRIMARY KEY (HALLMARK_TYPE, GO_ID));";
			//will commit automatically			
			statement.execute(sqlCreateHallmarkHallmarkTab);
			statement.execute(sqlCreateHallmarkAnnotationTab);
			statement.execute(sqlCreateHallmarkGoMappingTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createKineticsTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateKineticsRateAnnotationTab="CREATE TABLE IF NOT EXISTS KINETICS_RATE_ANNOTATION (RATE_ID INTEGER PRIMARY KEY NOT NULL, ORGANISM TEXT, CELL_LINE TEXT, SOURCE TEXT NOT NULL,"
					+ "PARAMETER TEXT NOT NULL, VALUE TEXT NOT NULL, FOREIGN KEY (SOURCE) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreateKineticsRateTab="CREATE TABLE IF NOT EXISTS KINETICS_RATE (ID INTEGER PRIMARY KEY NOT NULL, KINETICS_ID INTEGER NOT NULL, RATE_ID INTEGER NOT NULL, "
					+ "FOREIGN KEY (RATE_ID) REFERENCES KINETICS_RATE_ANNOTATION(RATE_ID) ON DELETE CASCADE);";
			String sqlCreateKineticsKineticsTab="CREATE TABLE IF NOT EXISTS KINETICS_KINETICS (SOURCE_NODE_ID INTEGER NOT NULL, SOURCE_NODE_NAME TEXT NOT NULL, TARGET_NODE_ID INTEGER NOT NULL,"
					+ "TARGET_NODE_NAME TEXT NOT NULL, EDGE_TYPE TEXT NOT NULL, KINETICS_ID INTEGER NOT NULL, PRIMARY KEY (SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE, KINETICS_ID));";
			//will commit automatically			
			statement.execute(sqlCreateKineticsRateAnnotationTab);
			statement.execute(sqlCreateKineticsRateTab);
			statement.execute(sqlCreateKineticsKineticsTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void createNodeAnnotationTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateAnnotationTab="CREATE TABLE NODE_ANNOTATION (NODE_ID INTEGER NOT NULL, SOURCE_NAME TEXT NOT NULL, SOURCE_ID TEXT NOT NULL, SOURCE_TYPE TEXT, "
					+ "PRIMARY KEY (NODE_ID, SOURCE_NAME, SOURCE_ID, SOURCE_TYPE), FOREIGN KEY (NODE_ID) REFERENCES CURR_NETWORK_NODE(NODE_ID) ON DELETE CASCADE, "
					+ "FOREIGN KEY (SOURCE_NAME) REFERENCES SOURCE(SOURCE_NAME) ON DELETE CASCADE);";
			String sqlCreatePathwayTab="CREATE TABLE PATHWAY (PATHWAY_ID TEXT PRIMARY KEY NOT NULL, PATHWAY_NAME TEXT NOT NULL);";
			//will commit automatically			
			statement.execute(sqlCreateAnnotationTab);
			statement.execute(sqlCreatePathwayTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private int updateTableWithStringArray(stringArray header, ArrayList<stringArray> arr, String tableName)
	{
		Statement statement=null;
		ResultSet result=null;
		String sqlStatement="";
		int maxID=0;

		try {

			if(tableName.compareTo("TEMP_TARGET")==0)
			{
				statement= conn.createStatement();
				sqlStatement="SELECT COUNT(ENTRY) FROM TEMP_TARGET;";
				result=statement.executeQuery(sqlStatement);

				if(result.next())
					maxID=result.getInt(1)+1;
				else
					maxID=1;

				statement.close();
				result.close();
			}

			System.out.println("maxID: "+maxID);

			for(int i=0; i<arr.size(); i++)
			{
				//check for existence
				if(tableName.compareTo("TEMP_TARGET")==0)
					sqlStatement="SELECT * FROM TEMP_TARGET WHERE ";
				else if(tableName.compareTo("TEMP_NETWORK")==0)
					sqlStatement="SELECT * FROM TEMP_NETWORK WHERE ";
				else if(tableName.compareTo("SOURCE")==0)
					sqlStatement="SELECT * FROM SOURCE WHERE ";

				if(tableName.compareTo("TEMP_TARGET")==0)
				{
					for(int j=1; j<header.size()-1; j++)
						sqlStatement=sqlStatement+header.getStringArrayAtIndex(j)+"='"+arr.get(i).getStringArrayAtIndex(j)+"' AND ";				
				}
				else
				{
					for(int j=0; j<header.size()-1; j++)
						sqlStatement=sqlStatement+header.getStringArrayAtIndex(j)+"='"+arr.get(i).getStringArrayAtIndex(j)+"' AND ";
				}
				sqlStatement=sqlStatement+header.getStringArrayAtIndex(header.size()-1)+"='"+arr.get(i).getStringArrayAtIndex(header.size()-1)+"';";
				System.out.println("sqlStatement: "+sqlStatement);
				Statement s1= conn.createStatement();
				ResultSet r=s1.executeQuery(sqlStatement);

				if(!r.next())
				{
					//insert into table
					if(tableName.compareTo("TEMP_TARGET")==0)
						sqlStatement="INSERT INTO TEMP_TARGET (";
					else if(tableName.compareTo("TEMP_NETWORK")==0)
						sqlStatement="INSERT INTO TEMP_NETWORK (";
					else if(tableName.compareTo("SOURCE")==0)
						sqlStatement="INSERT INTO SOURCE (";

					for(int j=0; j<header.size()-1; j++)
						sqlStatement=sqlStatement+header.getStringArrayAtIndex(j)+", ";
					sqlStatement=sqlStatement+header.getStringArrayAtIndex(header.size()-1)+") VALUES (";
					if(tableName.compareTo("TEMP_TARGET")==0)
					{
						sqlStatement=sqlStatement+"'"+maxID+"', ";
						for(int j=1; j<header.size()-1; j++)
							sqlStatement=sqlStatement+"'"+arr.get(i).getStringArrayAtIndex(j)+"', ";
						maxID++;
					}
					else
					{
						for(int j=0; j<header.size()-1; j++)
							sqlStatement=sqlStatement+"'"+arr.get(i).getStringArrayAtIndex(j)+"', ";
					}
					sqlStatement=sqlStatement+"'"+arr.get(i).getStringArrayAtIndex(header.size()-1)+"');";
					System.out.println("sqlStatement: "+sqlStatement);
					Statement s= conn.createStatement();
					s.execute(sqlStatement);
					s.close();
				}
				s1.close();
				r.close();
			}

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return maxID;
	}

	private int updateTableSingleEntry(int type)
	{
		String sqlStatement;
		String name="", source="", sourceID="";
		int maxID=0;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			//check if this network's disease is already in the table
			if(type==DISEASE)
				sqlStatement="SELECT * FROM DISEASE WHERE DISEASE_NAME IN (SELECT DISEASE_NAME FROM TEMP_NETWORK) AND "
						+ "DISEASE_SOURCE IN (SELECT DISEASE_SOURCE FROM TEMP_NETWORK) AND "
						+ "DISEASE_SOURCE_ID IN (SELECT DISEASE_SOURCE_ID FROM TEMP_NETWORK);";
			else if(type==NETWORK)
				sqlStatement="SELECT * FROM NETWORK WHERE NETWORK_NAME IN (SELECT NETWORK_NAME FROM TEMP_NETWORK) AND "
						+ "NETWORK_SOURCE IN (SELECT NETWORK_SOURCE FROM TEMP_NETWORK) AND "
						+ "NETWORK_SOURCE_ID IN (SELECT NETWORK_SOURCE_ID FROM TEMP_NETWORK);";
			else if(type==ORGANISM)
				sqlStatement="SELECT * FROM ORGANISM WHERE ORGANISM_NAME IN (SELECT ORGANISM_NAME FROM TEMP_NETWORK) AND "
						+ "ORGANISM_SOURCE IN (SELECT ORGANISM_SOURCE FROM TEMP_NETWORK) AND "
						+ "ORGANISM_SOURCE_ID IN (SELECT ORGANISM_SOURCE_ID FROM TEMP_NETWORK);";
			else
				sqlStatement="SELECT * FROM ORGANISM WHERE ORGANISM_NAME IN (SELECT ORGANISM_NAME FROM TEMP_NETWORK) AND "
						+ "ORGANISM_SOURCE IN (SELECT ORGANISM_SOURCE FROM TEMP_NETWORK) AND "
						+ "ORGANISM_SOURCE_ID IN (SELECT ORGANISM_SOURCE_ID FROM TEMP_NETWORK);";

			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				//find current maximum ID in table
				if(type==DISEASE)
					sqlStatement="SELECT MAX(DISEASE_ID) FROM DISEASE;";
				else if(type==NETWORK)
					sqlStatement="SELECT MAX(NETWORK_ID) FROM NETWORK;";
				else
					sqlStatement="SELECT MAX(ORGANISM_ID) FROM ORGANISM;";

				result=statement.executeQuery(sqlStatement);

				if(result.next())
					maxID=result.getInt(1)+1;
				else
					maxID=1;

				//get name, source and source_id information 
				if(type==DISEASE)
					sqlStatement="SELECT DISEASE_NAME, DISEASE_SOURCE, DISEASE_SOURCE_ID FROM TEMP_NETWORK;";
				else if(type==NETWORK)
					sqlStatement="SELECT NETWORK_NAME, NETWORK_SOURCE, NETWORK_SOURCE_ID FROM TEMP_NETWORK;";
				else
					sqlStatement="SELECT ORGANISM_NAME, ORGANISM_SOURCE, ORGANISM_SOURCE_ID FROM TEMP_NETWORK;";

				result=statement.executeQuery(sqlStatement);
				if(result.next())
				{
					name=result.getString(1);
					source=result.getString(2);
					sourceID=result.getString(3);
				}

				if(type==DISEASE)
					sqlStatement="INSERT INTO DISEASE (DISEASE_ID, DISEASE_NAME, DISEASE_SOURCE, DISEASE_SOURCE_ID) " + 
							"VALUES ('"+maxID+"', '"+name+"', '"+source+"', '"+sourceID+"');";
				else if(type==NETWORK)
					sqlStatement="INSERT INTO NETWORK (NETWORK_ID, NETWORK_NAME, NETWORK_SOURCE, NETWORK_SOURCE_ID) " + 
							"VALUES ('"+maxID+"', '"+name+"', '"+source+"', '"+sourceID+"');";
				else
					sqlStatement="INSERT INTO ORGANISM (ORGANISM_ID, ORGANISM_NAME, ORGANISM_SOURCE, ORGANISM_SOURCE_ID) " + 
							"VALUES ('"+maxID+"', '"+name+"', '"+source+"', '"+sourceID+"');";

				statement.execute(sqlStatement);
				//conn.commit();
			}

			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return maxID;
	}

	private void updateNetworkDiseaseOrganismTable(int networkID, int diseaseID, int organismID)
	{
		String sqlStatement;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			//check if this organism is already in the table
			sqlStatement="SELECT * FROM NETWORK_DISEASE_ORGANISM WHERE NETWORK_ID='"+networkID
					+ "' AND DISEASE_ID='"+diseaseID + "' AND ORGANISM_ID='"+organismID+"';";
			result=statement.executeQuery(sqlStatement);
			if(!result.next())
			{
				sqlStatement="INSERT INTO NETWORK_DISEASE_ORGANISM (NETWORK_ID, DISEASE_ID, ORGANISM_ID) VALUES ("+networkID
						+ ", "+diseaseID+", "+organismID+");";
				statement.execute(sqlStatement);
				//conn.commit();
			}

			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void closeConnection()
	{
		try {
			conn.close();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private ArrayList<Integer> updateTableMultiEntry(int type)
	{
		String sqlStatement;
		String name, source, sourceID;
		int maxID=0;
		ArrayList<Integer> list=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			//find current maximum ID in database
			if(type==TARGET)
				sqlStatement="SELECT MAX(TARGET_ID) FROM TARGET;";
			else if(type==DRUG)
				sqlStatement="SELECT MAX(DRUG_ID) FROM DRUG;";
			else
				sqlStatement="SELECT MAX(TRIAL_ID) FROM TRIAL;";

			result=statement.executeQuery(sqlStatement);

			if(result.next())
				maxID=result.getInt(1)+1;
			else
				maxID=1;

			//get list of unique entries in the temp table and add them in actual table if they do not already exist
			if(type==TARGET)
				sqlStatement="SELECT DISTINCT TARGET_NAME, TARGET_SOURCE, TARGET_SOURCE_ID FROM TEMP_TARGET;";
			else if(type==DRUG)
				sqlStatement="SELECT DISTINCT DRUG_NAME, DRUG_SOURCE, DRUG_SOURCE_ID FROM TEMP_TARGET WHERE DRUG_NAME<>'';";
			else
				sqlStatement="SELECT DISTINCT TRIAL_SOURCE, TRIAL_SOURCE, TRIAL_SOURCE_ID FROM TEMP_TARGET;";

			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				name=result.getString(1);
				source=result.getString(2);
				sourceID=result.getString(3);

				if(!(((type==TARGET || type==DRUG) && name.length()==0) || (type==TRIAL && source.length()==0)))
				{
					ArrayList<String> sourceIDList = getListFromString(sourceID, " ");

					for(int i=0; i<sourceIDList.size(); i++)
					{
						//check if entry exists in table
						if(type==TARGET)
							sqlStatement="SELECT * FROM TARGET WHERE TARGET_NAME='"+name+ "' AND TARGET_SOURCE='"+source 
							+ "' AND TARGET_SOURCE_ID='"+sourceIDList.get(i)+"';";
						else if(type==DRUG)
							sqlStatement="SELECT * FROM DRUG WHERE DRUG_NAME='"+name+ "' AND DRUG_SOURCE='"+source 
							+ "' AND DRUG_SOURCE_ID='"+sourceIDList.get(i)+"';";
						else
							sqlStatement="SELECT * FROM TRIAL WHERE TRIAL_SOURCE='"+source+ "' AND TRIAL_SOURCE_ID='"+sourceIDList.get(i)+"';";

						Statement tmpStatement=conn.createStatement();
						ResultSet tmpResult=tmpStatement.executeQuery(sqlStatement);
						if(!tmpResult.next())
						{
							list.add(maxID);
							if(type==TARGET)
								sqlStatement="INSERT INTO TARGET (TARGET_ID, TARGET_NAME, TARGET_SOURCE, TARGET_SOURCE_ID) VALUES ('"+maxID
								+ "', '"+name+"', '"+source+"', '"+sourceIDList.get(i)+"');";
							else if(type==DRUG)
								sqlStatement="INSERT INTO DRUG (DRUG_ID, DRUG_NAME, DRUG_SOURCE, DRUG_SOURCE_ID) VALUES ('"+maxID
								+ "', '"+name+"', '"+source+"', '"+sourceIDList.get(i)+"');";
							else
								sqlStatement="INSERT INTO TRIAL (TRIAL_ID, TRIAL_SOURCE, TRIAL_SOURCE_ID) VALUES ('"+maxID
								+ "', '"+source+"', '"+sourceIDList.get(i)+"');";

							tmpStatement.execute(sqlStatement);
							//conn.commit();
							maxID++;
						}
						else
							list.add(tmpResult.getInt(1));

						tmpStatement.close();
						tmpResult.close();
					}
				}
			}

			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		return list;
	}

	private void updateNetworkNodeTable(int networkID, ArrayList<Integer> nodeListID)
	{
		String sqlStatement;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			for(int i=0; i<nodeListID.size(); i++)
			{
				//check if <networkID,nodeID> entry exists in table
				sqlStatement="SELECT * FROM NETWORK_TARGET WHERE NETWORK_ID='"+networkID+ "' AND TARGET_ID='"+nodeListID.get(i)+"';";
				result=statement.executeQuery(sqlStatement);
				if(!result.next())
				{
					sqlStatement="INSERT INTO NETWORK_TARGET (NETWORK_ID, TARGET_ID) VALUES ('"+networkID+ "', '"+nodeListID.get(i)+"');";
					statement.execute(sqlStatement);
					//conn.commit();
				}
			}
			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void updateEvidenceTable(int diseaseID, int organismID, int type)
	{
		String sqlStatement, tmpSqlStatement1, tmpSqlStatement2;
		String nodeName, nodeSource, nodeSourceID, drugName, drugSource, drugSourceID;
		String evidenceSource, evidenceSourceID;
		int nodeID, drugID;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			//get appropriate columns of all entries
			if(type==DRUG_EVIDENCE)
				sqlStatement="SELECT TARGET_NAME, TARGET_SOURCE, TARGET_SOURCE_ID, DRUG_NAME, DRUG_SOURCE, DRUG_SOURCE_ID, "
						+ "EVIDENCE_SOURCE, EVIDENCE_SOURCE_ID FROM TEMP_TARGET;";
			else
				sqlStatement="SELECT TARGET_NAME, TARGET_SOURCE, TARGET_SOURCE_ID, DRUG_NAME, DRUG_SOURCE, DRUG_SOURCE_ID, "
						+ "EVIDENCE_SOURCE, EVIDENCE_SOURCE_ID FROM TEMP_TARGET WHERE DRUG_NAME='';";

			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				nodeName=result.getString(1);
				nodeSource=result.getString(2);
				nodeSourceID=result.getString(3);
				drugName=result.getString(4);
				drugSource=result.getString(5);
				drugSourceID=result.getString(6);
				evidenceSource=result.getString(7);
				evidenceSourceID=result.getString(8);

				//get nodeID and drugID
				tmpSqlStatement1="SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+nodeName+ "' AND TARGET_SOURCE='"+nodeSource 
						+ "' AND TARGET_SOURCE_ID='"+nodeSourceID+"';";

				if(type==DRUG_EVIDENCE)
					tmpSqlStatement2="SELECT DRUG_ID FROM DRUG WHERE DRUG_NAME='"+drugName+ "' AND DRUG_SOURCE='"+drugSource 
					+ "' AND DRUG_SOURCE_ID='"+drugSourceID+"';";
				else
					//tmpSqlStatement2 is actually not required here. 
					//Hack to make structure of function applicable to both DRUG_EVIDENCE and OTHER_EVIDENCE
					tmpSqlStatement2="SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+nodeName+ "' AND TARGET_SOURCE='"+nodeSource 
					+ "' AND TARGET_SOURCE_ID='"+nodeSourceID+"';";

				Statement tmpStatement1=conn.createStatement(), tmpStatement2=conn.createStatement();
				ResultSet tmpResult1=tmpStatement1.executeQuery(tmpSqlStatement1);
				ResultSet tmpResult2=tmpStatement2.executeQuery(tmpSqlStatement2);
				if(tmpResult1.next() && tmpResult2.next())
				{
					nodeID=tmpResult1.getInt(1);
					drugID=tmpResult2.getInt(1);

					//check existence of entry in table
					if(type==DRUG_EVIDENCE)
						tmpSqlStatement1="SELECT * FROM DRUG_EVIDENCE WHERE DISEASE_ID='"+diseaseID+ "' AND ORGANISM_ID='"+organismID 
						+ "' AND TARGET_ID='"+nodeID+"' AND DRUG_ID='"+drugID+"' AND EVIDENCE_SOURCE='"+evidenceSource
						+ "' AND EVIDENCE_SOURCE_ID='"+evidenceSourceID+"';";
					else
						tmpSqlStatement1="SELECT * FROM OTHER_EVIDENCE WHERE DISEASE_ID='"+diseaseID+ "' AND ORGANISM_ID='"+organismID 
						+ "' AND TARGET_ID='"+nodeID+"' AND EVIDENCE_SOURCE='"+evidenceSource+"' AND EVIDENCE_SOURCE_ID='"+evidenceSourceID+"';";

					tmpResult1=tmpStatement1.executeQuery(tmpSqlStatement1);
					if(!tmpResult1.next())
					{
						if(type==DRUG_EVIDENCE)
							tmpSqlStatement1="INSERT INTO DRUG_EVIDENCE (DISEASE_ID, ORGANISM_ID, TARGET_ID, DRUG_ID, EVIDENCE_SOURCE, EVIDENCE_SOURCE_ID) "
									+ "VALUES ('"+diseaseID+"', '"+organismID+"', '"+nodeID+"', '"+drugID+"', '"+evidenceSource+"', '"+evidenceSourceID+"');";
						else
							tmpSqlStatement1="INSERT INTO OTHER_EVIDENCE (DISEASE_ID, ORGANISM_ID, TARGET_ID, EVIDENCE_SOURCE, EVIDENCE_SOURCE_ID) "
									+ "VALUES ('"+diseaseID+"', '"+organismID+"', '"+nodeID+"', '"+evidenceSource+"', '"+evidenceSourceID+"');";

						tmpStatement1.execute(tmpSqlStatement1);
						//conn.commit();
					}
					tmpStatement1.close();
					tmpStatement2.close();
					tmpResult1.close();
					tmpResult2.close();
				}
			}

			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private ArrayList<String> getListFromString(String str, String delimiter)
	{
		ArrayList<String> list=new ArrayList<String>();
		int index;

		while(str!=null)
		{
			index=str.indexOf(delimiter);
			if(index>0)
			{
				list.add(str.substring(0, index));
				str=str.substring(index+1);
			}
			else
			{
				list.add(str);
				str=null;
			}
		}

		return list;
	}

	private void updateTrialDiseaseOrganismNodeDrugTable(int diseaseID, int organismID)
	{
		String sqlStatement, tmpSqlStatement1, tmpSqlStatement2, tmpSqlStatement3;
		String nodeName, nodeSource, nodeSourceID, drugName, drugSource, drugSourceID, trialSource, trialSourceID;
		int nodeID, drugID, trialID;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			//get appropriate columns of all entries
			sqlStatement="SELECT TARGET_NAME, TARGET_SOURCE, TARGET_SOURCE_ID, DRUG_NAME, DRUG_SOURCE, DRUG_SOURCE_ID, TRIAL_SOURCE, TRIAL_SOURCE_ID FROM TEMP_TARGET;";

			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				nodeName=result.getString(1);
				nodeSource=result.getString(2);
				nodeSourceID=result.getString(3);
				drugName=result.getString(4);
				drugSource=result.getString(5);
				drugSourceID=result.getString(6);
				trialSource=result.getString(7);
				trialSourceID=result.getString(8);

				ArrayList<String> sourceIDList = getListFromString(trialSourceID, " ");

				//get nodeID
				tmpSqlStatement1="SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+nodeName+ "' AND TARGET_SOURCE='"+nodeSource 
						+ "' AND TARGET_SOURCE_ID='"+nodeSourceID+"';";
				//get drugID
				tmpSqlStatement2="SELECT DRUG_ID FROM DRUG WHERE DRUG_NAME='"+drugName+ "' AND DRUG_SOURCE='"+drugSource 
						+ "' AND DRUG_SOURCE_ID='"+drugSourceID+"';";

				for(int i=0; i<sourceIDList.size(); i++)
				{
					//get trialID
					tmpSqlStatement3="SELECT TRIAL_ID FROM TRIAL WHERE TRIAL_SOURCE='"+trialSource+ "' AND TRIAL_SOURCE_ID='"+sourceIDList.get(i)+"';";
					Statement tmpStatement1=conn.createStatement(), tmpStatement2=conn.createStatement(), tmpStatement3=conn.createStatement();
					ResultSet tmpResult1=tmpStatement1.executeQuery(tmpSqlStatement1);
					ResultSet tmpResult2=tmpStatement2.executeQuery(tmpSqlStatement2);
					ResultSet tmpResult3=tmpStatement3.executeQuery(tmpSqlStatement3);

					if(tmpResult1.next() && tmpResult2.next() && tmpResult3.next())
					{
						nodeID=tmpResult1.getInt(1);
						drugID=tmpResult2.getInt(1);
						trialID=tmpResult3.getInt(1);

						//check existence of entry in table
						tmpSqlStatement3="SELECT * FROM TRIAL_DISEASE_ORGANISM_TARGET_DRUG WHERE TRIAL_ID='"+trialID+ "' AND DISEASE_ID='"+diseaseID+"' AND ORGANISM_ID='"+organismID
								+"' AND TARGET_ID='"+nodeID+"' AND DRUG_ID='"+drugID+"';";
						tmpResult3=tmpStatement1.executeQuery(tmpSqlStatement3);
						if(!tmpResult3.next())
						{
							tmpSqlStatement3="INSERT INTO TRIAL_DISEASE_ORGANISM_TARGET_DRUG (TRIAL_ID, DISEASE_ID, ORGANISM_ID, TARGET_ID, DRUG_ID) "
									+ "VALUES ('"+trialID+"', '"+diseaseID+"', '"+organismID+"', '"+ nodeID+"', '"+drugID+"');";
							tmpStatement3.execute(tmpSqlStatement3);
							//conn.commit();
						}
					}
					tmpStatement1.close();
					tmpStatement2.close();
					tmpStatement3.close();
					tmpResult1.close();
					tmpResult2.close();
					tmpResult3.close();
				}
			}

			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void createCombiTempTables() throws SQLException
	{
		//drop temporary tables
		dropTable(initTableList(TEMP_COMBI_TABLE_NO_QUOTES));
		//create temporary tables 
		createTargetCombiTempTables();
	}

	private void populateAllTables() throws SQLException
	{
		String fName, directory="C:"+"\\"+LIB_FOLDER+"\\";
		BufferedReader reader;
		excel2CSV convertExcel2CSV=new excel2CSV();
		int diseaseID, networkID, organismID;
		ArrayList<Integer> nodeListID=new ArrayList<Integer>();

		try {
			reader = new BufferedReader(new FileReader(directory+LIB_LIST_FILE));
			while ((fName = reader.readLine()) != null) 
			{
				//drop temporary tables
				dropTable(initTableList(TEMP_TABLE_NO_QUOTES));

				//create temporary tables 
				createTempTables();
				System.out.println("created temp tables");
				//create target.csv, source.csv and network.csv from the .xlsx file
				System.out.println("fName: "+fName);
				convertExcel2CSV.getAllStringArray(directory, fName);
				System.out.println("converted .xlsx to stringArray");
				updateTableWithStringArray(convertExcel2CSV.getTargetHeader(), convertExcel2CSV.getTargetStringArray(), "TEMP_TARGET");
				System.out.println("updated TEMP_TARGET table");
				updateTableWithStringArray(convertExcel2CSV.getNetworkHeader(), convertExcel2CSV.getNetworkStringArray(), "TEMP_NETWORK");
				System.out.println("updated TEMP_NETWORK table");
				updateTableWithStringArray(convertExcel2CSV.getSourceHeader(), convertExcel2CSV.getSourceStringArray(), "SOURCE");
				System.out.println("updated SOURCE table");
				//convertExcel2CSV.convert(directory, fName);
				//System.out.println("converted .xlsx to .csv");
				//read the .csv files into temp tables in postgreSQL
				//loadCSVToTempTables(directory);
				//System.out.println("loaded .csv to temp tables");

				//update DB tables using temp tables
				diseaseID=updateTableSingleEntry(DISEASE);
				System.out.println("updated DISEASE table");
				networkID=updateTableSingleEntry(NETWORK);
				System.out.println("updated NETWORK table");
				organismID=updateTableSingleEntry(ORGANISM);
				System.out.println("updated ORGANISM table");
				updateNetworkDiseaseOrganismTable(networkID, diseaseID, organismID);
				System.out.println("updated NETWORK_DISEASE_ORGANISM table");
				nodeListID=updateTableMultiEntry(TARGET);
				System.out.println("updated TARGET table");
				updateNetworkNodeTable(networkID, nodeListID);
				System.out.println("updated NETWORK_TARGET table");
				updateTableMultiEntry(DRUG);
				System.out.println("updated DRUG table");
				updateEvidenceTable(diseaseID, organismID, DRUG_EVIDENCE);
				System.out.println("updated DRUG_EVIDENCE table");
				updateEvidenceTable(diseaseID, organismID, OTHER_EVIDENCE);
				System.out.println("updated OTHER_EVIDENCE table");
				updateTableMultiEntry(TRIAL);
				System.out.println("updated TRIAL table");
				updateTrialDiseaseOrganismNodeDrugTable(diseaseID, organismID);
				System.out.println("updated TRIAL_DISEASE_ORGANISM_TARGET_DRUG table");

				//conn.commit();
			}
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private ArrayList<String> initTableList(int tableType)
	{
		ArrayList<String> l=new ArrayList<String>();

		System.out.println("tableType: "+tableType);

		if(tableType==TRAINING_NETWORK_TARGET_TABLE_WITH_QUOTES)
		{
			l.add("'target'");
			l.add("'network'");
			l.add("'disease'");
			l.add("'organism'");
			l.add("'drug'");
			l.add("'network_target'");
			l.add("'network_disease_organism'");
			l.add("'trial'");
			l.add("'other_evidence'");
			l.add("'drug_evidence'");
			l.add("'trial_disease_organism_target_drug'");
		}
		if(tableType==TRAINING_NETWORK_TARGET_TABLE_NO_QUOTES)
		{
			l.add("TARGET");
			l.add("NETWORK");
			l.add("DISEASE");
			l.add("ORGANISM");
			l.add("DRUG");
			l.add("NETWORK_TARGET");
			l.add("NETWORK_DISEASE_ORGANISM");
			l.add("TRIAL");
			l.add("OTHER_EVIDENCE");
			l.add("DRUG_EVIDENCE");
			l.add("TRIAL_DISEASE_ORGANISM_TARGET_DRUG");
		}
		if(tableType==THIS_NETWORK_WITH_QUOTES)
		{
			l.add("'curr_network_node'");
			l.add("'curr_network_edge'");
			l.add("'curr_network_node_normalized_ranks'");
			l.add("'curr_network_feature'");
			l.add("'curr_network_model_accuracy'");
			l.add("'curr_network_metadata'");
			l.add("'network_view_node'");
			l.add("'curr_network_node_ranks'");
			l.add("'curr_pathway_node'");
			l.add("'curr_pathway_node_ranks'");
			l.add("'curr_network_hallmark_characterization'");
		}
		if(tableType==THIS_NETWORK_NO_QUOTES)
		{
			l.add("CURR_NETWORK_NODE");
			l.add("CURR_NETWORK_EDGE");
			l.add("CURR_NETWORK_NODE_NORMALIZED_RANKS");
			l.add("CURR_NETWORK_FEATURE");
			l.add("CURR_NETWORK_MODEL_ACCURACY");
			l.add("CURR_NETWORK_METADATA");
			l.add("NETWORK_VIEW_NODE");
			l.add("CURR_NETWORK_NODE_RANKS");
			l.add("CURR_PATHWAY_NODE");
			l.add("CURR_PATHWAY_NODE_RANKS");
			l.add("CURR_NETWORK_HALLMARK_CHARACTERIZATION");
		}
		if(tableType==TEMP_TABLE_WITH_QUOTES)
		{
			l.add("'temp_network'");
			l.add("'temp_target'");
		}
		if(tableType==TEMP_TABLE_NO_QUOTES)
		{
			l.add("TEMP_NETWORK");
			l.add("TEMP_TARGET");
		}
		if(tableType==TEMP_COMBI_TABLE_WITH_QUOTES)
		{
			l.add("'temp_all_ancestors_of_disease_nodes'");
			l.add("'temp_combi_1'");
			l.add("'temp_combi_2'");
			l.add("'temp_combi_3'");
			l.add("'temp_combi_4'");
			l.add("'temp_combi_5'");
			l.add("'temp_combi_6'");
			l.add("'temp_combi_7'");
			l.add("'temp_combi_8'");
			l.add("'temp_combi_9'");
			l.add("'temp_combi_10'");
			l.add("'temp_combi_summary'");
			l.add("'temp_candidate_all'");
			l.add("'temp_candidate_hallmark_rank'");
			l.add("'temp_candidate'");
		}
		if(tableType==TEMP_COMBI_TABLE_NO_QUOTES)
		{
			l.add("TEMP_ALL_ANCESTORS_OF_DISEASE_NODES");
			l.add("TEMP_COMBI_1");
			l.add("TEMP_COMBI_2");
			l.add("TEMP_COMBI_3");
			l.add("TEMP_COMBI_4");
			l.add("TEMP_COMBI_5");
			l.add("TEMP_COMBI_6");
			l.add("TEMP_COMBI_7");
			l.add("TEMP_COMBI_8");
			l.add("TEMP_COMBI_9");
			l.add("TEMP_COMBI_10");
			l.add("TEMP_COMBI_SUMMARY");
			l.add("TEMP_CANDIDATE_ALL");
			l.add("TEMP_CANDIDATE_HALLMARK_RANK");
			l.add("TEMP_CANDIDATE");
		}
		if(tableType==HALLMARK_TABLE_WITH_QUOTES)
		{
			l.add("'hallmark_hallmark'");
			l.add("'hallmark_annotation'");
			l.add("'hallmark_go_mapping'");
		}
		if(tableType==HALLMARK_TABLE_NO_QUOTES)
		{
			l.add("HALLMARK_HALLMARK");
			l.add("HALLMARK_ANNOTATION");
			l.add("HALLMARK_GO_MAPPING");
		}
		if(tableType==KINETICS_TABLE_WITH_QUOTES)
		{
			l.add("'kinetics_kinetics'");
			l.add("'kinetics_rate'");
			l.add("'kinetics_rate_annotation'");
		}
		if(tableType==KINETICS_TABLE_NO_QUOTES)
		{
			l.add("KINETICS_KINETICS");
			l.add("KINETICS_RATE");
			l.add("KINETICS_RATE_ANNOTATION");
		}
		if(tableType==NODE_ANNOTATION_TABLE_WITH_QUOTES)
		{
			l.add("'node_annotation'");
			l.add("'pathway'");
		}
		if(tableType==NODE_ANNOTATION_TABLE_NO_QUOTES)
		{
			l.add("NODE_ANNOTATION");
			l.add("PATHWAY");
		}
		if(tableType==SHARED_WITH_QUOTES)
		{
			//used by ACTUAL_TABLE_WITH_QUOTES, HALLMARK_TABLE_WITH_QUOTES, KINETICS_TABLE_WITH_QUOTES 
			l.add("'source'");
		}
		if(tableType==SHARED_NO_QUOTES)
		{
			//used by ACTUAL_TABLE_NO_QUOTES, HALLMARK_TABLE_NO_QUOTES, KINETICS_TABLE_NO_QUOTES
			l.add("SOURCE"); 
		}
		if(tableType==TEMP_SORT_TABLE_WITH_QUOTES)
		{
			l.add("'temp_sort'");
		}
		if(tableType==TEMP_SORT_TABLE_NO_QUOTES)
		{
			l.add("TEMP_SORT");
		}
		if(tableType==CURATED_COMBI_TABLE_WITH_QUOTES)
		{
			l.add("'curatedcombi_combi'");
			l.add("'curatedcombi_nctid'");
			l.add("'curatedcombi_disease'");
		}
		if(tableType==CURATED_COMBI_TABLE_NO_QUOTES)
		{
			l.add("CURATEDCOMBI_COMBI");
			l.add("CURATEDCOMBI_NCTID");
			l.add("CURATEDCOMBI_DISEASE");
		}
		if(tableType==PREDICTED_COMBI_TABLE_WITH_QUOTES)
		{
			l.add("'predictedcombi_combi'");
			l.add("'predictedcombi_nctid'");
		}
		if(tableType==PREDICTED_COMBI_TABLE_NO_QUOTES)
		{
			l.add("PREDICTEDCOMBI_COMBI");
			l.add("PREDICTEDCOMBI_NCTID");
		}
		if(tableType==CURATED_DRUG_TABLE_WITH_QUOTES)
		{
			l.add("'curatedmono_target'");
			l.add("'curatedmono_drug'");
		}
		if(tableType==CURATED_DRUG_TABLE_NO_QUOTES)
		{
			l.add("CURATEDMONO_TARGET");
			l.add("CURATEDMONO_DRUG");
		}
		return l;
	}

	public void clearAccuracyTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE CURR_NETWORK_MODEL_ACCURACY;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearTempAllAncestorsOfDiseaseNodesTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE TEMP_ALL_ANCESTORS_OF_DISEASE_NODES;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearTempCandidateHallmarkRankTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE TEMP_CANDIDATE_HALLMARK_RANK;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearTempCombiTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE TEMP_COMBI;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearTempCandidateTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE TEMP_CANDIDATE;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearHallmarkCharacterizationTable()
	{
		Statement statement=null;

		try {
			statement = conn.createStatement();
			String sqlStatement=null;

			sqlStatement="TRUNCATE CURR_NETWORK_HALLMARK_CHARACTERIZATION;";
			statement.execute(sqlStatement);

			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearTopologicalFeatures()
	{
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			sqlStatement="UPDATE CURR_NETWORK_NODE SET IN_DEGREE=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET OUT_DEGREE=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET TOTAL_DEGREE=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET EIGENVECTOR=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET CLOSENESS=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET ECCENTRICITY=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET BETWEENNESS=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET BRIDGING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET BRIDGING_CENTRALITY=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET UNDIRECTED_CLUSTERING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET IN_CLUSTERING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET OUT_CLUSTERING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET CYCLE_CLUSTERING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET MIDDLEMAN_CLUSTERING_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET PROXIMITY_PRESTIGE=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET TARGET_DOWNSTREAM_EFFECT=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET PROFILE_SHAPE_SIMILARITY_DISTANCE=NULL";
			statement.execute(sqlStatement);
			sqlStatement="UPDATE CURR_NETWORK_NODE SET PROBABILITY_COEFFICIENT=NULL";
			statement.execute(sqlStatement);
			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void clearPathwayTopologicalFeatures()
	{
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			sqlStatement="TRUNCATE CURR_PATHWAY_NODE;";
			statement.execute(sqlStatement);
			sqlStatement="TRUNCATE CURR_PATHWAY_NODE_RANKS;";
			statement.execute(sqlStatement);
			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void loadTrainingNetworkTarget()
	{
		try {
			//Check if trainingNetwork has been previously loaded.
			//Assume that if tables are present, trainingNetwork is already loaded
			//Note that it's important to create shared tables first as other tables depend on it
			if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
			{
				//reset the DB by deleting all tables, recreating the tables and populating them
				createSharedTables();
			}
			if(checkTableExistence(initTableList(TRAINING_NETWORK_TARGET_TABLE_WITH_QUOTES))==false)
			{
				//reset the DB by deleting all tables, recreating the tables and populating them
				dropTable(initTableList(TRAINING_NETWORK_TARGET_TABLE_NO_QUOTES));
				createTrainingNetworkTargetTables();
				populateAllTables();
			}
			populateAllTables();

		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void loadPredictedCombi()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		System.out.println(checkTableExistence(initTableList(SHARED_WITH_QUOTES)));
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(PREDICTED_COMBI_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(PREDICTED_COMBI_TABLE_NO_QUOTES));
			createPredictedCombiTables();
		}
	}

	public void loadCuratedDrug()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		System.out.println(checkTableExistence(initTableList(SHARED_WITH_QUOTES)));
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(CURATED_DRUG_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(CURATED_DRUG_TABLE_NO_QUOTES));
			createCuratedDrugTables();
		}
	}

	public void loadCuratedCombi()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		System.out.println(checkTableExistence(initTableList(SHARED_WITH_QUOTES)));
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(CURATED_COMBI_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(CURATED_COMBI_TABLE_NO_QUOTES));
			createCuratedCombiTables();
		}
	}

	public void loadHallmark()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		System.out.println(checkTableExistence(initTableList(SHARED_WITH_QUOTES)));
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(HALLMARK_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(HALLMARK_TABLE_NO_QUOTES));
			createHallmarkTables();
		}
	}

	public void loadKinetics()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(KINETICS_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(KINETICS_TABLE_NO_QUOTES));
			createKineticsTables();
		}
	}

	public void loadNodeAnnotation()
	{
		//Note that it's important to create shared tables first as other tables depend on it
		if(checkTableExistence(initTableList(SHARED_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			createSharedTables();
		}
		if(checkTableExistence(initTableList(NODE_ANNOTATION_TABLE_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(NODE_ANNOTATION_TABLE_NO_QUOTES));
			createNodeAnnotationTables();
		}
	}

	public boolean loadThisNetwork()
	{
		//Check if trainingNetwork has been previously loaded.
		//Assume that if tables are present, trainingNetwork is already loaded
		if(checkTableExistence(initTableList(THIS_NETWORK_WITH_QUOTES))==false)
		{
			//reset the DB by deleting all tables, recreating the tables and populating them
			dropTable(initTableList(THIS_NETWORK_NO_QUOTES));
			createThisNetwork();
			initializeComputedFeature();
			initializeFeatureTable();
			return true;
		}
		return false;
	}

	public boolean isTarget(String disease, String organism, String nodeName) {
		Statement statement=null;
		ResultSet result=null;

		try {
			//Assumption1: there is a unique diseaseID for each given disease
			//Assumption2: there is a unique organismID for each given organism
			//There may be multiple network associated with the given disease and organism
			//There may be multiple nodes in each network
			int exist=0, diseaseID=0, organismID=0;

			statement = conn.createStatement();
			//get disease ID
			result = statement.executeQuery("SELECT DISEASE_ID FROM DISEASE WHERE DISEASE_NAME='"+disease+"';");
			if(result.next())
				diseaseID=result.getInt(1);

			//get organism ID
			result = statement.executeQuery("SELECT ORGANISM_ID FROM ORGANISM WHERE ORGANISM_NAME='"+organism+"';");
			if(result.next())
				organismID=result.getInt(1);

			//check existence of node in join tables
			result = statement.executeQuery("SELECT 1 FROM TARGET AS A, NETWORK_TARGET AS B, NETWORK_DISEASE_ORGANISM AS C WHERE "
					+ "DISEASE_ID='"+diseaseID+"' AND ORGANISM_ID='"+organismID+"' AND C.NETWORK_ID=B.NETWORK_ID AND "
					+ "B.TARGET_ID=A.TARGET_ID AND TARGET_NAME='"+nodeName+"';");
			if(result.next())
				exist=result.getInt(1);

			statement.close();
			result.close();

			if(exist==1)
				return true;

		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return false;
	}

	public ArrayList<String> getOrganismList() {
		ArrayList<String> list=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();

			//get list of organisms
			result = statement.executeQuery("SELECT ORGANISM_NAME FROM ORGANISM;");
			while(result.next())
				list.add(result.getString(1));

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return list;
	}

	private Connection getConnection()
	{
		Connection conn=null;
		try {
			conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/TROVE", "postgres", "trove");
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return conn;
	}

	public ArrayList<String> getDiseaseList() {
		ArrayList<String> list=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();

			//get list of disease
			result = statement.executeQuery("SELECT DISEASE_NAME FROM DISEASE;");
			while(result.next())
				list.add(result.getString(1));

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return list;
	}

	public ArrayList<ArrayList<String>> getDrugListOfTarget(String disease, String organism, String nodeName) {
		ArrayList<ArrayList<String>> twoDlist=new ArrayList<ArrayList<String>>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			int diseaseID=0, organismID=0, nodeID=0;

			//get disease ID
			result = statement.executeQuery("SELECT DISEASE_ID FROM DISEASE WHERE DISEASE_NAME='"+disease+"';");
			if(result.next())
				diseaseID=result.getInt(1);

			//get organism ID
			result = statement.executeQuery("SELECT ORGANISM_ID FROM ORGANISM WHERE ORGANISM_NAME='"+organism+"';");
			if(result.next())
				organismID=result.getInt(1);

			//get node ID
			result = statement.executeQuery("SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+nodeName+"';");
			if(result.next())
				nodeID=result.getInt(1);

			//join tables and get entries <drugName, drugSourceURL, drugSourceID, evidenceSourceURL, evidenceSourceID>
			result = statement.executeQuery("SELECT DRUG_NAME, DRUG_SOURCE_URL, DRUG_SOURCE_ID, EVIDENCE_SOURCE_URL, EVIDENCE_SOURCE_ID FROM "
					+ "(SELECT TARGET_ID, B.DRUG_ID, DRUG_NAME, SOURCE_URL AS DRUG_SOURCE_URL, DRUG_SOURCE_ID FROM DRUG AS A, DRUG_EVIDENCE AS B, SOURCE AS C WHERE "
					+ "DISEASE_ID='"+diseaseID+"' AND ORGANISM_ID='"+organismID+"' AND TARGET_ID='"+nodeID+"' AND A.DRUG_ID=B.DRUG_ID AND "
					+ "DRUG_SOURCE=SOURCE_NAME)  AS TABLE1 LEFT JOIN (SELECT TARGET_ID, DRUG_ID, SOURCE_URL AS EVIDENCE_SOURCE_URL, "
					+ "EVIDENCE_SOURCE_ID FROM DRUG_EVIDENCE AS A, SOURCE AS B WHERE DISEASE_ID='"+diseaseID+"' AND ORGANISM_ID='"+organismID+"' AND "
					+ "TARGET_ID='"+nodeID+"' AND EVIDENCE_SOURCE=SOURCE_NAME) AS TABLE2 ON TABLE1.TARGET_ID=TABLE2.TARGET_ID AND TABLE1.DRUG_ID=TABLE2.DRUG_ID;");

			while(result.next())
			{
				ArrayList<String> resultLine=new ArrayList<String>();
				resultLine.add(result.getString(1));
				resultLine.add(result.getString(2));
				resultLine.add(result.getString(3));
				resultLine.add(result.getString(4));
				resultLine.add(result.getString(5));
				twoDlist.add(resultLine);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return twoDlist;
	}

	public ArrayList<ArrayList<String>> getOtherEvidenceListOfTarget(String disease, String organism, String nodeName) {
		ArrayList<ArrayList<String>> twoDlist=new ArrayList<ArrayList<String>>();
		Statement statement=null;
		ResultSet result=null;

		try {
			conn = getConnection();
			statement = conn.createStatement();
			int diseaseID=0, organismID=0, nodeID=0;

			//get disease ID
			result = statement.executeQuery("SELECT DISEASE_ID FROM DISEASE WHERE DISEASE_NAME='"+disease+"';");
			if(result.next())
				diseaseID=result.getInt(1);

			//get organism ID
			result = statement.executeQuery("SELECT ORGANISM_ID FROM ORGANISM WHERE ORGANISM_NAME='"+organism+"';");
			if(result.next())
				organismID=result.getInt(1);

			//get node ID
			result = statement.executeQuery("SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+nodeName+"';");
			if(result.next())
				nodeID=result.getInt(1);

			result = statement.executeQuery("SELECT EVIDENCE_SOURCE, EVIDENCE_SOURCE_ID FROM OTHER_EVIDENCE WHERE DISEASE_ID='"+diseaseID
					+"' AND ORGANISM_ID='"+organismID+"' AND TARGET_ID='"+nodeID+"';");

			while(result.next())
			{
				ArrayList<String> resultLine=new ArrayList<String>();
				resultLine.add(result.getString(1));
				resultLine.add(result.getString(2));
				System.out.println(resultLine.toString());
				twoDlist.add(resultLine);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return twoDlist;
	}

	public ArrayList<ArrayList<String>> getTrialListOfNodeDrug(String disease, String organism, String node, String drug) {
		ArrayList<ArrayList<String>> twoDlist=new ArrayList<ArrayList<String>>();
		Statement statement=null;
		ResultSet result=null;

		try {
			conn = getConnection();
			statement = conn.createStatement();
			int diseaseID=0, organismID=0, nodeID=0, drugID=0;

			//get disease ID
			result = statement.executeQuery("SELECT DISEASE_ID FROM DISEASE WHERE DISEASE_NAME='"+disease+"';");
			if(result.next())
				diseaseID=result.getInt(1);

			//get organism ID
			result = statement.executeQuery("SELECT ORGANISM_ID FROM ORGANISM WHERE ORGANISM_NAME='"+organism+"';");
			if(result.next())
				organismID=result.getInt(1);

			//get node ID
			result = statement.executeQuery("SELECT TARGET_ID FROM TARGET WHERE TARGET_NAME='"+node+"';");
			if(result.next())
				nodeID=result.getInt(1);

			//get drug ID
			result = statement.executeQuery("SELECT DRUG_ID FROM DRUG WHERE DRUG_NAME='"+drug+"';");
			if(result.next())
				drugID=result.getInt(1);


			//join tables and get entries <drugName, drugSourceURL, drugSourceID, evidenceSourceURL, evidenceSourceID>
			result = statement.executeQuery("SELECT SOURCE_URL AS TRIAL_SOURCE_URL, TRIAL_SOURCE_ID FROM TRIAL AS A, SOURCE AS B, "
					+ "TRIAL_DISEASE_ORGANISM_TARGET_DRUG AS C WHERE DISEASE_ID='"+diseaseID+"' AND ORGANISM_ID='"+organismID
					+"' AND TARGET_ID='"+nodeID+"' AND DRUG_ID='"+drugID+ "' AND C.TRIAL_ID=A.TRIAL_ID AND TRIAL_SOURCE=SOURCE_NAME;");

			while(result.next())
			{
				ArrayList<String> resultLine=new ArrayList<String>();
				resultLine.add(result.getString(1));
				resultLine.add(result.getString(2));
				twoDlist.add(resultLine);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return twoDlist;
	}

	public boolean addNewRandomTargetCombinations(int size, int test, ArrayList<String> list) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;
		String[] nodeId=new String[5];
		boolean proceed=false;
		for(int i=0; i<size; i++)
		{
			String n=list.get(i);
			nodeId[i]=getNodeID(getNodeDBID(n));
		}

		for(int i=size; i<5; i++)
			nodeId[i]=null;
		boolean success=false;

		if(size==2 && nodeId[0]!=null && nodeId[1]!=null)
			proceed=true;
		if(size==3 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null)
			proceed=true;
		if(size==4 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null)
			proceed=true;
		if(size==5 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null && nodeId[4]!=null)
			proceed=true;

		if(proceed==true)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement = null;

				//check if this node is already in the table
				if(size==2 && nodeId[0]!=null && nodeId[1]!=null)
					sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
					" WHERE NODE_ID_1 IN ('"+nodeId[0]+"','"+nodeId[1]+"') AND " +
					"NODE_ID_2 IN ('"+nodeId[0]+"','"+nodeId[1]+"');";
				if(size==3 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null)
					sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
					" WHERE NODE_ID_1 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"') AND " +
					"NODE_ID_2 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"') AND " + 
					"NODE_ID_3 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"');";
				if(size==4 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null)
					sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
					" WHERE NODE_ID_1 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"') AND " +
					"NODE_ID_2 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"') AND " + 
					"NODE_ID_3 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"') AND " + 
					"NODE_ID_4 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"');";
				if(size==5 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null && nodeId[4]!=null)
					sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
					" WHERE NODE_ID_1 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"','"+nodeId[4]+"') AND " +
					"NODE_ID_2 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"','"+nodeId[4]+"') AND " + 
					"NODE_ID_3 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"','"+nodeId[4]+"') AND " + 
					"NODE_ID_4 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"','"+nodeId[4]+"') AND " +
					"NODE_ID_5 IN ('"+nodeId[0]+"','"+nodeId[1]+"','"+nodeId[2]+"','"+nodeId[3]+"','"+nodeId[4]+"');";

				result=statement.executeQuery(sqlStatement);

				if(!result.next())
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(COMBI_INDEX) FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+";";
					result=statement.executeQuery(sqlStatement);
					//System.out.println(sqlStatement);
					if(result.next())
						maxID=result.getInt(1)+1;
					else
						maxID=1;

					//System.out.println("size:"+size+" test:"+test+" maxID:"+maxID+": "+node1+"("+nodeId1+") ,"+node2+"("+nodeId2+")");
					if(size==2 && nodeId[0]!=null && nodeId[1]!=null)
						sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
						" (COMBI_INDEX, NODE_ID_1, NODE_ID_2) VALUES ('"+maxID+"', '"
						+nodeId[0]+"', '"+nodeId[1]+"');";
					if(size==3 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null)
						sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
						" (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3) VALUES ('"+maxID+"', '"
						+nodeId[0]+"', '"+nodeId[1]+"', '"+nodeId[2]+"');";
					if(size==4 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null)
						sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
						" (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3, NODE_ID_4) VALUES ('"+maxID+"', '"
						+nodeId[0]+"', '"+nodeId[1]+"', '"+nodeId[2]+"', '"+nodeId[3]+"');";
					if(size==5 && nodeId[0]!=null && nodeId[1]!=null && nodeId[2]!=null && nodeId[3]!=null && nodeId[4]!=null)
						sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+
						" (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3, NODE_ID_4, NODE_ID_5) VALUES ('"+maxID+"', '"
						+nodeId[0]+"', '"+nodeId[1]+"', '"+nodeId[2]+"', '"+nodeId[3]+"', '"+nodeId[4]+"');";

					statement.execute(sqlStatement);
					success=true;
				}
				statement.close();
				result.close();
			} catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			} 
		}
		return success;
	}

	public void clearRandomTargetCombinations(int size, int test) {
		Statement statement=null;
		try {
			statement = conn.createStatement();
			String sqlStatement;
			sqlStatement="TRUNCATE CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+";";
			statement.execute(sqlStatement);
			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void getNetworkViewNode_setRandomTargetSideEffects(int size, int test, int index, double essentialNodeFraction, double nonDiseaseOutDegreeFraction) {
		Statement statement=null;
		try {
			statement = conn.createStatement();
			String sqlStatement;
			sqlStatement="UPDATE CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+" set ESSENTIAL_NODE_FRACTION='"+essentialNodeFraction
					+"', NON_DISEASE_OUT_DEGREE_FRACTION='"+nonDiseaseOutDegreeFraction+"' WHERE COMBI_INDEX="+index+";";
			statement.executeUpdate(sqlStatement);
			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public ArrayList<ArrayList<String>> getRandomTargetCombinations(int size, int test) {
		Statement statement=null;
		ResultSet result=null;
		ArrayList<ArrayList<String>> list=new ArrayList<ArrayList<String>>();
		try {
			statement = conn.createStatement();
			String sqlStatement;
			String nodeString="";

			for(int i=0; i<size; i++)
			{
				nodeString=nodeString+"NODE_ID_"+(i+1);
				if(i<size-1)
					nodeString=nodeString+", ";
			}
			sqlStatement="SELECT "+nodeString+" FROM CANDIDATE_COMBI_SIZE"+size+"_TEST"+test+";";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				String[] node=new String[5];
				String[] nodeSBMLID=new String[5];

				for(int i=0; i<size; i++)
				{
					nodeSBMLID[i]=result.getString(i+1);
					node[i]=getNodeID(getNodeDBID(nodeSBMLID[i]));
				}
				System.out.println("node0:"+node[0]+" node1:"+node[1]+" node2:"+node[2]+" node3:"+node[3]+" node4:"+node[4]);
				ArrayList<String> listEntry=new ArrayList<String>();
				for(int i=0; i<size; i++)
					listEntry.add(node[i]);
				list.add(listEntry);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return list;
	}
	/*public void addNewCandidateCombi_size2(String node1, String node2) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;
		String nodeId1=getNodeID(getNodeDBID(node1));
		String nodeId2=getNodeID(getNodeDBID(node2));

		if(nodeId1!=null && nodeId2!=null)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement;

				//check if this node is already in the table
				sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE_2 WHERE NODE_ID_1 IN ('"+nodeId1+"','"+nodeId2+"') AND " +
						"NODE_ID_2 IN ('"+nodeId1+"','"+nodeId2+"');";
				result=statement.executeQuery(sqlStatement);

				if(!result.next())
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(COMBI_INDEX) FROM CANDIDATE_COMBI_SIZE_2;";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						maxID=result.getInt(1)+1;
					else
						maxID=1;

					System.out.println(maxID+": "+node1+"("+nodeId1+") ,"+node2+"("+nodeId2+")");

					sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE_2 (COMBI_INDEX, NODE_ID_1, NODE_ID_2) VALUES ('"+maxID+"', '"
							+nodeId1+"', '"+nodeId2+"');";
					statement.execute(sqlStatement);
				}
				statement.close();
				result.close();
			} catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			} 
		}
	}

	public void addNewCandidateCombi_size3(String node1, String node2, String node3) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;
		String nodeId1=getNodeID(getNodeDBID(node1));
		String nodeId2=getNodeID(getNodeDBID(node2));
		String nodeId3=getNodeID(getNodeDBID(node3));

		if(nodeId1!=null && nodeId2!=null && nodeId3!=null)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement;

				//check if this node is already in the table
				sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE_3 WHERE NODE_ID_1 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"') AND " +
						"NODE_ID_2 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"') AND NODE_ID_3 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"');";
				result=statement.executeQuery(sqlStatement);

				if(!result.next())
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(COMBI_INDEX) FROM CANDIDATE_COMBI_SIZE_3;";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						maxID=result.getInt(1)+1;
					else
						maxID=1;

					System.out.println(maxID+": "+node1+"("+nodeId1+") ,"+node2+"("+nodeId2+") ,"+node3+"("+nodeId3+")");

					sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE_3 (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3) VALUES ('"+maxID+"', '"
							+nodeId1+"', '"+nodeId2+"', '"+nodeId3+"');";
					statement.execute(sqlStatement);
				}
				statement.close();
				result.close();
			} catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			} 
		}
	}

	public void addNewCandidateCombi_size4(String node1, String node2, String node3, String node4) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;
		String nodeId1=getNodeID(getNodeDBID(node1));
		String nodeId2=getNodeID(getNodeDBID(node2));
		String nodeId3=getNodeID(getNodeDBID(node3));
		String nodeId4=getNodeID(getNodeDBID(node4));

		if(nodeId1!=null && nodeId2!=null && nodeId3!=null && nodeId4!=null)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement;

				//check if this node is already in the table
				sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE_4 WHERE NODE_ID_1 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"') AND " +
						"NODE_ID_2 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"') AND " + 
						"NODE_ID_3 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"') AND " +
						"NODE_ID_4 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"');";
				result=statement.executeQuery(sqlStatement);

				if(!result.next())
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(COMBI_INDEX) FROM CANDIDATE_COMBI_SIZE_4;";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						maxID=result.getInt(1)+1;
					else
						maxID=1;

					System.out.println(maxID+": "+node1+"("+nodeId1+") ,"+node2+"("+nodeId2+") ,"+node3+"("+nodeId3+") ,"+node4+"("+nodeId4+")");

					sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE_4 (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3, NODE_ID_4) VALUES ('"+maxID+"', '"
							+nodeId1+"', '"+nodeId2+"', '"+nodeId3+"', '"+nodeId4+"');";
					statement.execute(sqlStatement);
				}
				statement.close();
				result.close();
			} catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			} 
		}
	}

	public void addNewCandidateCombi_size5(String node1, String node2, String node3, String node4, String node5) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;
		String nodeId1=getNodeID(getNodeDBID(node1));
		String nodeId2=getNodeID(getNodeDBID(node2));
		String nodeId3=getNodeID(getNodeDBID(node3));
		String nodeId4=getNodeID(getNodeDBID(node4));
		String nodeId5=getNodeID(getNodeDBID(node5));

		if(nodeId1!=null && nodeId2!=null && nodeId3!=null && nodeId4!=null && nodeId5!=null)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement;

				//check if this node is already in the table
				sqlStatement="SELECT * FROM CANDIDATE_COMBI_SIZE_5 WHERE NODE_ID_1 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"','"+nodeId5+"') AND " +
						"NODE_ID_2 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"','"+nodeId5+"') AND " +
						"NODE_ID_3 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"','"+nodeId5+"') AND " +
						"NODE_ID_4 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"','"+nodeId5+"') AND " +
						"NODE_ID_5 IN ('"+nodeId1+"','"+nodeId2+"','"+nodeId3+"','"+nodeId4+"','"+nodeId5+"');";
				result=statement.executeQuery(sqlStatement);

				if(!result.next())
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(COMBI_INDEX) FROM CANDIDATE_COMBI_SIZE_5;";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						maxID=result.getInt(1)+1;
					else
						maxID=1;

					System.out.println(maxID+": "+node1+"("+nodeId1+") ,"+node2+"("+nodeId2+") ,"+node3+"("+nodeId3+") ,"+node4+"("+nodeId4+") ,"+node5+"("+nodeId5+")");

					sqlStatement="INSERT INTO CANDIDATE_COMBI_SIZE_5 (COMBI_INDEX, NODE_ID_1, NODE_ID_2, NODE_ID_3, NODE_ID_4, NODE_ID_5) VALUES ('"+maxID+"', '"
							+nodeId1+"', '"+nodeId2+"', '"+nodeId3+"', '"+nodeId4+"', '"+nodeId5+"');";
					statement.execute(sqlStatement);
				}
				statement.close();
				result.close();
			} catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			} 
		}
	}
	 */
	public void addNewViewNode_essentialGenes(String viewType, String entrez) {
		Statement statement=null, statement1=null;
		ResultSet result=null, result1=null;

		if(viewType.compareTo("TRIPLE_NEGATIVE_BREAST_CANCER")!=0)
			System.out.println("viewType: "+viewType);

		try {
			statement = conn.createStatement();
			statement1 = conn.createStatement();
			String sqlStatement;

			//check if this viewType-nodeId is already in the table
			sqlStatement="SELECT * FROM NETWORK_VIEW_NODE_ESSENTIAL WHERE VIEW_NAME='"+viewType+"' AND NODE_ID='"+entrez+"';";
			result=statement.executeQuery(sqlStatement);

			sqlStatement="SELECT * FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+entrez+"';";
			result1=statement1.executeQuery(sqlStatement);

			if(!result.next() && result1.next())
			{
				sqlStatement="INSERT INTO NETWORK_VIEW_NODE_ESSENTIAL (VIEW_NAME, NODE_ID) VALUES ('"+viewType+"', '"
						+entrez+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			statement1.close();
			result.close();
			result1.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void addNewViewNode_foldChange(String viewType, String entrez, String foldChange) {
		Statement statement=null, statement1=null;
		ResultSet result=null, result1=null;

		if(viewType.compareTo("TRIPLE_NEGATIVE_BREAST_CANCER")!=0)
			System.out.println("viewType: "+viewType);

		try {
			statement = conn.createStatement();
			statement1 = conn.createStatement();
			String sqlStatement;

			//check if this viewType-nodeId is already in the table
			sqlStatement="SELECT * FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+viewType+"' AND NODE_ID='"+entrez+"' AND FOLD_CHANGE='"+foldChange+"';";
			result=statement.executeQuery(sqlStatement);

			sqlStatement="SELECT * FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+entrez+"';";
			result1=statement1.executeQuery(sqlStatement);

			if(!result.next() && result1.next())
			{
				sqlStatement="INSERT INTO NETWORK_VIEW_NODE_FOLDCHANGE (VIEW_NAME, NODE_ID, FOLD_CHANGE) VALUES ('"+viewType+"', '"
						+entrez+"', '"+foldChange+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			statement1.close();
			result.close();
			result1.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void addNewViewNode_mutationFrequency(String viewType, String entrez, String percentage) {
		Statement statement=null, statement1=null;
		ResultSet result=null, result1=null;

		if(viewType.compareTo("TRIPLE_NEGATIVE_BREAST_CANCER")!=0)
			System.out.println("viewType: "+viewType);

		try {
			statement = conn.createStatement();
			statement1 = conn.createStatement();
			String sqlStatement;

			//check if this viewType-nodeId is already in the table
			sqlStatement="SELECT * FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+viewType+"' AND NODE_ID='"+entrez+"' AND PERCENTAGE='"+percentage+"';";
			result=statement.executeQuery(sqlStatement);

			sqlStatement="SELECT * FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+entrez+"';";
			result1=statement1.executeQuery(sqlStatement);

			if(!result.next() && result1.next())
			{
				sqlStatement="INSERT INTO NETWORK_VIEW_NODE_MUTATION (VIEW_NAME, NODE_ID, PERCENTAGE) VALUES ('"+viewType+"', '"
						+entrez+"', '"+percentage+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			statement1.close();
			result.close();
			result1.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void addNewMetadata(String networkName, String version) {
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			//check if this metadata is already in the table
			sqlStatement="SELECT * FROM CURR_NETWORK_METADATA WHERE NETWORK_NAME='"+networkName+"' AND VERSION='"+version+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				sqlStatement="INSERT INTO CURR_NETWORK_METADATA (NETWORK_NAME, VERSION) VALUES ('"+networkName+"', '"
						+version+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public ArrayList<String[]> getSource_sourceList(int numParam) {
		ArrayList<String[]> sourceName=new ArrayList<String[]>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			//node is either a source or a target
			sqlStatement="SELECT SOURCE_NAME, SOURCE_URL FROM SOURCE WHERE SOURCE_NUM_PARAM='"+numParam+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				int col=2;
				String[] sourceData=new String[col];
				for(int i=0; i<col; i++)
					sourceData[i]=r1.getString(i+1);
				sourceName.add(sourceData);
			}
			r1.close();
			s1.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return sourceName;
	}

	public ArrayList<ArrayList<String>> getNetworkEdge_inducedEdges(ArrayList<String> nodeList)
	{
		ArrayList<ArrayList<String>> inducedEdgeList=new ArrayList<ArrayList<String>>();
		ArrayList<Integer> nodeDBIDList=new ArrayList<Integer>();
		String nodeDBIDStr="";
		Statement statement=null;
		ResultSet result=null;
		
		for(int i=0; i<nodeList.size(); i++)
		{
			nodeDBIDList.add(getNodeDBID(nodeList.get(i)));
			nodeDBIDStr=nodeDBIDStr+nodeDBIDList.get(i);
			if(i<nodeList.size()-1)
				nodeDBIDStr=nodeDBIDStr+",";
		}
			
		try {
			statement = conn.createStatement();
			String sqlStatement="SELECT * FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID IN ("+nodeDBIDStr+") AND TARGET_NODE_ID IN ("+nodeDBIDStr+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int sourceID=result.getInt(1);
				int targetID=result.getInt(2);
				String source=getNodeName(sourceID);
				String target=getNodeName(targetID);
				String type=result.getString(3);
				ArrayList<String> element=new ArrayList<String>();
				element.add(source);
				element.add(target);
				element.add(type);
				inducedEdgeList.add(element);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return inducedEdgeList;
	}
	
	public ArrayList<edge> getNetworkEdge_edgeList(JLabel status) {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;
			int resultSize=0, count=1;
			float percentComplete;

			sqlStatement="SELECT COUNT(*) FROM (SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE) AS A;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				resultSize=result.getInt(1);
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE;";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				edgeList.add(newEdge);
				percentComplete=(float)(100.0*count/resultSize);
				DecimalFormat df = new DecimalFormat();
				df.setMaximumFractionDigits(2);
				status.setText("creating graph ...retrieving edge data from database ["+df.format(percentComplete)+"%]");
				count++;
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return edgeList;
	}

	public ArrayList<edge> getNetworkEdge_edgeListOfNode(String node) {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		Statement statement=null;
		ResultSet result=null;
		int nodeID;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			nodeID=getNodeDBID(node);

			//retrieve all edges where node is the source
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();

				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}

				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}

				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				edgeList.add(newEdge);

				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}

			//retrieve all edges where node is the target
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE TARGET_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();

				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}

				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}

				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				if(edgeList.contains(newEdge)==false)
					edgeList.add(newEdge);

				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return edgeList;
	}

	private String createNeighbourConstraintsString(String neighbourType, ArrayList<Integer> neighbourId)
	{
		String s="";
		for(int i=0; i<neighbourId.size(); i++)
		{
			if(i==0)
				s=s+neighbourType+"='"+neighbourId.get(i)+"'";
			else
				s=s+" OR "+neighbourType+"='"+neighbourId.get(i)+"'";
		}
		return s;
	}

	public ArrayList<String> getNetworkEdge_oneHopNeighbourNameListOfNodeList(ArrayList<String> nodeList) {
		ArrayList<String> neighbourList=new ArrayList<String>();
		ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;
		String targetString, sourceString;

		for(int i=0; i<nodeList.size(); i++)
			nodeIdList.add(getNodeDBID(nodeList.get(i)));
		sourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", nodeIdList);
		targetString=createNeighbourConstraintsString("TARGET_NODE_ID", nodeIdList);
		try {
			statement = conn.createStatement();
			String sqlStatement;
			//retrieve all edges where nodeList is the source
			sqlStatement="SELECT DISTINCT TARGET_NODE_ID AS NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+sourceString
					+ ") INTERSECT SELECT DISTINCT SOURCE_NODE_ID AS NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+targetString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int nodeDBID=result.getInt(1);
				Statement s1=conn.createStatement();
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
					neighbourList.add(r1.getString(1));
				s1.close();
				r1.close();
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return neighbourList;
	}

	public ArrayList<String> getNetworkEdge_twoHopNeighbourNameListOfNodeList(ArrayList<String> nodeList) {
		ArrayList<String> neighbourList=new ArrayList<String>();
		ArrayList<String> fromNeighbour=new ArrayList<String>();
		ArrayList<String> toNeighbour=new ArrayList<String>();
		ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
		ArrayList<Integer> fromNeighbourId=new ArrayList<Integer>();
		ArrayList<Integer> toNeighbourId=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;
		String targetString, sourceString, fromNeighbourTargetString, fromNeighbourSourceString, toNeighbourTargetString, toNeighbourSourceString;
		for(int i=0; i<nodeList.size(); i++)
			nodeIdList.add(getNodeDBID(nodeList.get(i)));
		sourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", nodeIdList);
		targetString=createNeighbourConstraintsString("TARGET_NODE_ID", nodeIdList);
		try {
			statement = conn.createStatement();
			String sqlStatement;
			//retrieve all edges where nodeList is the source
			sqlStatement="SELECT DISTINCT TARGET_NODE_ID AS NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+sourceString+")";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int nodeDBID=result.getInt(1);
				Statement s1=conn.createStatement();
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
					fromNeighbour.add(r1.getString(1));
				s1.close();
				r1.close();
			}
			for(int i=0; i<nodeList.size(); i++)
				fromNeighbourId.add(getNodeDBID(fromNeighbour.get(i)));
			fromNeighbourSourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", fromNeighbourId);
			fromNeighbourTargetString=createNeighbourConstraintsString("TARGET_NODE_ID", fromNeighbourId);
			//retrieve all edges where nodeList is the target
			sqlStatement="SELECT DISTINCT SOURCE_NODE_ID AS NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+targetString+")";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int nodeDBID=result.getInt(1);
				Statement s1=conn.createStatement();
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
					toNeighbour.add(r1.getString(1));
				s1.close();
				r1.close();
			}
			for(int i=0; i<nodeList.size(); i++)
				toNeighbourId.add(getNodeDBID(toNeighbour.get(i)));
			toNeighbourSourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", toNeighbourId);
			toNeighbourTargetString=createNeighbourConstraintsString("TARGET_NODE_ID", toNeighbourId);
			//retrieve all nodes for edges going from one of fromNeighbour to one of toNeighbour
			sqlStatement="SELECT DISTINCT SOURCE_NODE_ID, TARGET_NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+fromNeighbourSourceString
					+ ") AND ("+toNeighbourTargetString+")";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int nodeDBID1=result.getInt(1), nodeDBID2=result.getInt(2);
				Statement s1=conn.createStatement();
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID1+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(!neighbourList.contains(r1.getString(1)))
						neighbourList.add(r1.getString(1));
				}
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID2+"';";
				r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(!neighbourList.contains(r1.getString(1)))
						neighbourList.add(r1.getString(1));
				}
				s1.close();
				r1.close();
			}
			//retrieve all nodes for edges going from one of toNeighbour to one of fromNeighbour
			sqlStatement="SELECT DISTINCT SOURCE_NODE_ID, TARGET_NODE_ID FROM CURR_NETWORK_EDGE WHERE ("+toNeighbourSourceString
					+ ") AND ("+fromNeighbourTargetString+")";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int nodeDBID1=result.getInt(1), nodeDBID2=result.getInt(2);
				Statement s1=conn.createStatement();
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID1+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(!neighbourList.contains(r1.getString(1)))
						neighbourList.add(r1.getString(1));
				}
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID2+"';";
				r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(!neighbourList.contains(r1.getString(1)))
						neighbourList.add(r1.getString(1));
				}
				s1.close();
				r1.close();
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		System.out.println("nodeIdList:"+nodeIdList.toString());
		System.out.println("neighbourList:"+neighbourList.toString());

		return neighbourList;
	}

	public ArrayList<edge> getNetworkEdge_neighbourEdgeListOfNodeList(ArrayList<String> nodeList) {
		ArrayList<edge> neighbourEdgeList=new ArrayList<edge>();
		ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;
		String targetString, sourceString;

		for(int i=0; i<nodeList.size(); i++)
			nodeIdList.add(getNodeDBID(nodeList.get(i)));
		sourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", nodeIdList);
		targetString=createNeighbourConstraintsString("TARGET_NODE_ID", nodeIdList);

		try {
			statement = conn.createStatement();
			String sqlStatement;
			//retrieve all edges where nodeList is the source
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE ("+sourceString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				neighbourEdgeList.add(newEdge);
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}
			//retrieve all edges where nodeList is the target
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE ("+targetString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				neighbourEdgeList.add(newEdge);
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return neighbourEdgeList;
	}

	public ArrayList<edge> getNetworkEdge_edgeListOfInducedGraph(ArrayList<String> nodeList) {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;
		String targetString, sourceString;

		for(int i=0; i<nodeList.size(); i++)
			nodeIdList.add(getNodeDBID(nodeList.get(i)));
		sourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", nodeIdList);
		targetString=createNeighbourConstraintsString("TARGET_NODE_ID", nodeIdList);

		try {
			statement = conn.createStatement();
			String sqlStatement;
			//retrieve all edges where node is the source
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE ("+sourceString+") AND ("
					+ targetString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				edgeList.add(newEdge);
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return edgeList;
	}

	public ArrayList<edge> getNetworkEdge_edgeListOfNodeInInducedGraph(String node, ArrayList<String> nodeList) {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
		Statement statement=null;
		ResultSet result=null;
		String targetString, sourceString;

		for(int i=0; i<nodeList.size(); i++)
			nodeIdList.add(getNodeDBID(nodeList.get(i)));
		sourceString=createNeighbourConstraintsString("SOURCE_NODE_ID", nodeIdList);
		targetString=createNeighbourConstraintsString("TARGET_NODE_ID", nodeIdList);
		int nodeId=getNodeDBID(node);

		try {
			statement = conn.createStatement();
			String sqlStatement;
			//retrieve all edges where node is the source
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID='"+nodeId+"' AND ("
					+ targetString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				edgeList.add(newEdge);
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}
			//retrieve all edges where node is the target
			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE ("+sourceString+") AND TARGET_NODE_ID='"
					+ nodeId+"';";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				int DB_sourceNodeID=result.getInt(1), DB_targetNodeID=result.getInt(2);
				String edgeType=result.getString(3);
				String sourceNodeID=null, sourceNodeName=null, targetNodeID=null, targetNodeName=null;
				Statement s1=conn.createStatement(), s2=conn.createStatement();
				//obtain source node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_sourceNodeID+"';";
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					sourceNodeID=r1.getString(1);
					sourceNodeName=r1.getString(2);
				}
				//obtain target node information
				sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+DB_targetNodeID+"';";
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					targetNodeID=r2.getString(1);
					targetNodeName=r2.getString(2);
				}
				edge newEdge=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				edgeList.add(newEdge);
				s1.close();
				s2.close();
				r1.close();
				r2.close();
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return edgeList;
	}

	public ArrayList<String> getNetworkEdge_neighbourIDOfNode(String node) {
		//include node itself
		ArrayList<String> nodeIDList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;
		int nodeID;

		try {
			statement = conn.createStatement();
			String sqlStatement;
			nodeID=getNodeDBID(node);

			//include node itself
			sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
			statement=conn.createStatement();
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				nodeIDList.add(result.getString(1));

			//retrieve all target nodes where given node is the source
			sqlStatement="SELECT TARGET_NODE_ID FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				//obtain node information
				sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID='"+result.getInt(1)+"';";
				Statement s1=conn.createStatement();
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
					nodeIDList.add(r1.getString(1));

				s1.close();
				r1.close();
			}

			//retrieve all source nodes where given node is the target
			sqlStatement="SELECT SOURCE_NODE_ID FROM CURR_NETWORK_EDGE WHERE TARGET_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				//obtain node information
				sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID='"+result.getInt(1)+"';";
				Statement s1=conn.createStatement();
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(nodeIDList.contains(r1.getString(1))==false)
						nodeIDList.add(r1.getString(1));
				}
				s1.close();
				r1.close();
			}
			statement.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDList;
	}

	public ArrayList<String> getNetworkEdge_neighbourNameOfNode(String node) {
		//include node itself
		ArrayList<String> nodeNameList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;
		int nodeID;

		try {
			statement = conn.createStatement();
			String sqlStatement;
			nodeID=getNodeDBID(node);

			//include node itself
			sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
			statement=conn.createStatement();
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				nodeNameList.add(result.getString(1));

			//retrieve all target nodes where given node is the source
			sqlStatement="SELECT TARGET_NODE_ID FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				//obtain node information
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+result.getInt(1)+"';";
				Statement s1=conn.createStatement();
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
					nodeNameList.add(r1.getString(1));

				s1.close();
				r1.close();
			}

			//retrieve all source nodes where given node is the target
			sqlStatement="SELECT SOURCE_NODE_ID FROM CURR_NETWORK_EDGE WHERE TARGET_NODE_ID='"+nodeID+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				//obtain node information
				sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+result.getInt(1)+"';";
				Statement s1=conn.createStatement();
				ResultSet r1=s1.executeQuery(sqlStatement);
				if(r1.next())
				{
					if(nodeNameList.contains(r1.getString(1))==false)
						nodeNameList.add(r1.getString(1));
				}
				s1.close();
				r1.close();
			}
			statement.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeNameList;
	}

	public void addNewEdge(String sourceNodeID, String sourceNodeName, String targetNodeID, String targetNodeName, String edgeType) {
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;
			int DB_sourceNodeID, DB_targetNodeID;

			DB_sourceNodeID=getNodeDBID(sourceNodeName);
			DB_targetNodeID=getNodeDBID(targetNodeName);

			if(DB_sourceNodeID==-1) //this sourceNode is not in the table, add it to node table
				DB_sourceNodeID=addNewNode(sourceNodeID, sourceNodeName);
			if(DB_targetNodeID==-1) //this targetNode is not in the table, add it to node table
				DB_targetNodeID=addNewNode(targetNodeID, targetNodeName);
			//check if this edge is already in the table
			sqlStatement="SELECT * FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID='"+DB_sourceNodeID+"' AND TARGET_NODE_ID='"+DB_targetNodeID+"' AND EDGE_TYPE='"+edgeType+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				//insert new edge
				sqlStatement="INSERT INTO CURR_NETWORK_EDGE (SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE) VALUES ('"+DB_sourceNodeID+"', '"
						+DB_targetNodeID+"', '"+edgeType+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public int addNewNode(String sbml_node_id, String sbml_node_name) {
		Statement statement=null;
		ResultSet result=null;
		int maxID=0;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			//check if this node is already in the table
			sqlStatement="SELECT * FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				//find current maximum ID in table
				sqlStatement="SELECT MAX(NODE_ID) FROM CURR_NETWORK_NODE;";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					maxID=result.getInt(1)+1;
				else
					maxID=1;

				System.out.println(sbml_node_id+" "+maxID);

				sqlStatement="INSERT INTO CURR_NETWORK_NODE (NODE_ID, SBML_NODE_ID, SBML_NODE_NAME) VALUES ('"+maxID+"', '"
						+sbml_node_id+"', '"+sbml_node_name+"');";
				statement.execute(sqlStatement);

				sqlStatement="INSERT INTO CURR_NETWORK_NODE_NORMALIZED_RANKS (NODE_ID, SBML_NODE_ID, SBML_NODE_NAME) VALUES ('"+maxID+"', '"
						+sbml_node_id+"', '"+sbml_node_name+"');";
				statement.execute(sqlStatement);

				sqlStatement="INSERT INTO CURR_NETWORK_NODE_RANKS (NODE_ID, SBML_NODE_ID, SBML_NODE_NAME) VALUES ('"+maxID+"', '"
						+sbml_node_id+"', '"+sbml_node_name+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return maxID;
	}

	public void addNewPathwayNode(String sbml_node_id, String sbml_node_name) {
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			int maxID=0;
			String sqlStatement;

			//check if this node is already in the table
			sqlStatement="SELECT * FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				//find current maximum ID in table
				sqlStatement="SELECT MAX(NODE_ID) FROM CURR_PATHWAY_NODE;";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					maxID=result.getInt(1)+1;
				else
					maxID=1;

				System.out.println(sbml_node_id+" "+maxID);

				sqlStatement="INSERT INTO CURR_PATHWAY_NODE (NODE_ID, SBML_NODE_ID, SBML_NODE_NAME) VALUES ('"+maxID+"', '"
						+sbml_node_id+"', '"+sbml_node_name+"');";
				statement.execute(sqlStatement);

				sqlStatement="INSERT INTO CURR_PATHWAY_NODE_RANKS (NODE_ID, SBML_NODE_ID, SBML_NODE_NAME) VALUES ('"+maxID+"', '"
						+sbml_node_id+"', '"+sbml_node_name+"');";
				statement.execute(sqlStatement);
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void addNewModelAccuracy(String accuracy, ArrayList<String> featuresToRemove) {
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			int maxID=0;
			String sqlStatement;
			ArrayList<Integer> featureToRemoveValues=new ArrayList<Integer>();

			//find current maximum ID in table
			sqlStatement="SELECT COUNT(MODEL_ID) FROM CURR_NETWORK_MODEL_ACCURACY;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxID=result.getInt(1)+1;
			else
				maxID=1;

			if(featuresToRemove.contains(IN_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(OUT_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(TOTAL_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(EIGENVECTOR)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(CLOSENESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(ECCENTRICITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BETWEENNESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_CENTRALITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(UNDIRECTED_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(IN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(OUT_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(CYCLE_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(MIDDLEMAN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(PROXIMITY_PRESTIGE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(TARGET_DOWNSTREAM_EFFECT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			sqlStatement="INSERT INTO CURR_NETWORK_MODEL_ACCURACY (MODEL_ID, ACCURACY, IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, "
					+ "EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, BRIDGING_COEFFICIENT, BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, "
					+ "IN_CLUSTERING_COEFFICIENT, OUT_CLUSTERING_COEFFICIENT, CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, "
					+ "PROXIMITY_PRESTIGE, TARGET_DOWNSTREAM_EFFECT) VALUES ('"+maxID+"', '"+accuracy+"', '"+featureToRemoveValues.get(0)+"', '"+featureToRemoveValues.get(1)
					+ "', '"+featureToRemoveValues.get(2)+"', '"+featureToRemoveValues.get(3)+"', '"+featureToRemoveValues.get(4)+"', '"+featureToRemoveValues.get(5)
					+ "', '"+featureToRemoveValues.get(6)+"', '"+featureToRemoveValues.get(7)+"', '"+featureToRemoveValues.get(8)+"', '"+featureToRemoveValues.get(9)
					+ "', '"+featureToRemoveValues.get(10)+"', '"+featureToRemoveValues.get(11)+"', '"+featureToRemoveValues.get(12)+"', '"+featureToRemoveValues.get(13)
					+ "', '"+featureToRemoveValues.get(14)+"', '"+featureToRemoveValues.get(15)+"');";
			statement.execute(sqlStatement);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void addNewHallmarkCharacterization(String hallmark, String modelFilename, ArrayList<String> predictiveFeatures,
			int wt, double CExp, double accuracy) {
		try {
			Statement statement = conn.createStatement();
			String sqlStatement;
			sqlStatement="SELECT HALLMARK FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet result=statement.executeQuery(sqlStatement);
			ArrayList<Integer> val=new ArrayList<Integer>();
			if(predictiveFeatures.contains(IN_DEGREE)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(OUT_DEGREE)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(TOTAL_DEGREE)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(EIGENVECTOR)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(CLOSENESS)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(ECCENTRICITY)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(BETWEENNESS)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(BRIDGING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);

			if(predictiveFeatures.contains(BRIDGING_CENTRALITY)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(UNDIRECTED_CLUSTERING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(IN_CLUSTERING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(OUT_CLUSTERING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(CYCLE_CLUSTERING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(MIDDLEMAN_CLUSTERING_COEFFICIENT)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(PROXIMITY_PRESTIGE)==true)
				val.add(1);
			else
				val.add(0);			

			if(predictiveFeatures.contains(TARGET_DOWNSTREAM_EFFECT)==true)
				val.add(1);
			else
				val.add(0);
			if(!result.next())
			{
				sqlStatement="INSERT INTO CURR_NETWORK_HALLMARK_CHARACTERIZATION (HALLMARK, MODEL_FILENAME, WEIGHT, C, ACCURACY, IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, "
						+ "EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, BRIDGING_COEFFICIENT, BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, "
						+ "IN_CLUSTERING_COEFFICIENT, OUT_CLUSTERING_COEFFICIENT, CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, PROXIMITY_PRESTIGE, "
						+ "TARGET_DOWNSTREAM_EFFECT) VALUES ('"+hallmark+"', '"+modelFilename+"', '"+ wt+"', '"+CExp+"', '"+accuracy
						+ "', '"+val.get(0)+"', '"+val.get(1)+ "', '"+val.get(2)+"', '"+val.get(3)+"', '"+val.get(4)+"', '"+val.get(5)
						+ "', '"+val.get(6)+"', '"+val.get(7)+"', '"+val.get(8)+"', '"+val.get(9)+ "', '"+val.get(10)+"', '"+val.get(11)
						+ "', '"+val.get(12)+"', '"+val.get(13)+ "', '"+val.get(14)+"', '"+val.get(15)+"');";
				statement.execute(sqlStatement);
			}
			else
			{
				sqlStatement="UPDATE CURR_NETWORK_HALLMARK_CHARACTERIZATION SET MODEL_FILENAME='"+modelFilename+"', WEIGHT='"+wt+"', C='"+CExp
						+ "', ACCURACY='"+accuracy+"', IN_DEGREE='"+val.get(0)+"', OUT_DEGREE='"+val.get(1)+"', TOTAL_DEGREE='"+val.get(2)
						+ "', EIGENVECTOR='"+val.get(3)+"', CLOSENESS='"+val.get(4)+"', ECCENTRICITY='"+val.get(5)+"', BETWEENNESS='"+val.get(6)
						+ "', BRIDGING_COEFFICIENT='"+val.get(7)+"', BRIDGING_CENTRALITY='"+val.get(8)+"', UNDIRECTED_CLUSTERING_COEFFICIENT='"+val.get(9)
						+ "', IN_CLUSTERING_COEFFICIENT='"+val.get(10)+"', OUT_CLUSTERING_COEFFICIENT='"+val.get(11)+"', CYCLE_CLUSTERING_COEFFICIENT='"+val.get(12)
						+ "', MIDDLEMAN_CLUSTERING_COEFFICIENT='"+val.get(13)+"', PROXIMITY_PRESTIGE'"+val.get(14)+"', TARGET_DOWNSTREAM_EFFECT'"+val.get(15)
						+ "' WHERE HALLMARK='"+hallmark+"';";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> getFeatureToRemoveOfModel(String modelAccuracy) {
		ArrayList<String> listToRemove=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, BRIDGING_COEFFICIENT, "
					+ "BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, IN_CLUSTERING_COEFFICIENT, OUT_CLUSTERING_COEFFICIENT, "
					+ "CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, PROXIMITY_PRESTIGE, TARGET_DOWNSTREAM_EFFECT "
					+ "FROM CURR_NETWORK_MODEL_ACCURACY WHERE ACCURACY='"+modelAccuracy+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				if(result.getInt(1)==1)
					listToRemove.add(IN_DEGREE);
				if(result.getInt(2)==1)
					listToRemove.add(OUT_DEGREE);
				if(result.getInt(3)==1)
					listToRemove.add(TOTAL_DEGREE);
				if(result.getInt(4)==1)
					listToRemove.add(EIGENVECTOR);
				if(result.getInt(5)==1)
					listToRemove.add(CLOSENESS);
				if(result.getInt(6)==1)
					listToRemove.add(ECCENTRICITY);
				if(result.getInt(7)==1)
					listToRemove.add(BETWEENNESS);
				if(result.getInt(8)==1)
					listToRemove.add(BRIDGING_COEFFICIENT);
				if(result.getInt(9)==1)
					listToRemove.add(BRIDGING_CENTRALITY);
				if(result.getInt(10)==1)
					listToRemove.add(UNDIRECTED_CLUSTERING_COEFFICIENT);
				if(result.getInt(11)==1)
					listToRemove.add(IN_CLUSTERING_COEFFICIENT);
				if(result.getInt(12)==1)
					listToRemove.add(OUT_CLUSTERING_COEFFICIENT);
				if(result.getInt(13)==1)
					listToRemove.add(CYCLE_CLUSTERING_COEFFICIENT);
				if(result.getInt(14)==1)
					listToRemove.add(MIDDLEMAN_CLUSTERING_COEFFICIENT);
				if(result.getInt(15)==1)
					listToRemove.add(PROXIMITY_PRESTIGE);
				if(result.getInt(16)==1)
					listToRemove.add(TARGET_DOWNSTREAM_EFFECT);
			}

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return listToRemove;
	}

	public String getMaxAccuracy() {
		String maxAccuracy=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT MAX(ACCURACY) FROM CURR_NETWORK_MODEL_ACCURACY;";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
				maxAccuracy=result.getString(1);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return maxAccuracy;
	}

	public String getAccuracy(ArrayList<String> featuresToRemove) {
		String accuracy=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;
			ArrayList<Integer> featureToRemoveValues=new ArrayList<Integer>();

			if(featuresToRemove.contains(IN_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(OUT_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(TOTAL_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(EIGENVECTOR)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(CLOSENESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(ECCENTRICITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BETWEENNESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_CENTRALITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(UNDIRECTED_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(IN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(OUT_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(CYCLE_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(MIDDLEMAN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(PROXIMITY_PRESTIGE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(TARGET_DOWNSTREAM_EFFECT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			sqlStatement="SELECT ACCURACY FROM CURR_NETWORK_MODEL_ACCURACY WHERE IN_DEGREE='"+featureToRemoveValues.get(0)+"' AND OUT_DEGREE='"+featureToRemoveValues.get(1)
					+ "' AND TOTAL_DEGREE='"+featureToRemoveValues.get(2)+"' AND EIGENVECTOR='"+featureToRemoveValues.get(3)+"' AND CLOSENESS='"+featureToRemoveValues.get(4)
					+ "' AND ECCENTRICITY='"+featureToRemoveValues.get(5)+"' AND BETWEENNESS='"+featureToRemoveValues.get(6)+"' AND BRIDGING_COEFFICIENT='"+featureToRemoveValues.get(7)
					+ "' AND BRIDGING_CENTRALITY='"+featureToRemoveValues.get(8)+"' AND UNDIRECTED_CLUSTERING_COEFFICIENT='"+featureToRemoveValues.get(9)+"' AND IN_CLUSTERING_COEFFICIENT='"
					+ featureToRemoveValues.get(10)+"' AND OUT_CLUSTERING_COEFFICIENT='"+featureToRemoveValues.get(11)+"' AND CYCLE_CLUSTERING_COEFFICIENT='"+featureToRemoveValues.get(12)
					+ "' AND MIDDLEMAN_CLUSTERING_COEFFICIENT='"+featureToRemoveValues.get(13)+"' AND PROXIMITY_PRESTIGE='"+featureToRemoveValues.get(14)+"' AND TARGET_DOWNSTREAM_EFFECT='"
					+ featureToRemoveValues.get(15)+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
				accuracy=result.getString(1);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
		return accuracy;
	}

	//return true if CURR_NETWORK_HALLMARK_CHARACTERIZATION is not empty
	public boolean getHallmark_hallmarkCharacterized()
	{
		int row=0; 
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT COUNT(*) FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				row=r1.getInt(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		if(row==0)
			return false;
		else
			return true;
	}

	public float getHallmarkCharacterization_accuracy(String hallmark)
	{
		float accuracy=0;
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT ACCURACY FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				accuracy=r1.getFloat(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return accuracy;
	}

	public float getHallmarkCharacterization_C(String hallmark)
	{
		float c=0;
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT C FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				c=r1.getFloat(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return c;
	}

	public float getHallmarkCharacterization_weight(String hallmark)
	{
		float weight=0;
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT WEIGHT FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				weight=r1.getFloat(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return weight;
	}

	public String getHallmarkCharacterization_modelFileName(String hallmark)
	{
		String modelFilename="";
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT MODEL_FILENAME FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				modelFilename=r1.getString(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return modelFilename;
	}

	public ArrayList<String> getHallmarkCharacterization_predictiveFeature(String hallmark)
	{
		ArrayList<String> predictiveFeature=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, "
					+ " BRIDGING_COEFFICIENT, BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, IN_CLUSTERING_COEFFICIENT, "
					+ " OUT_CLUSTERING_COEFFICIENT, CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, PROXIMITY_PRESTIGE, "
					+ " TARGET_DOWNSTREAM_EFFECT FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION WHERE HALLMARK='"+hallmark+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			ArrayList<Integer> predictiveFeatureValue=new ArrayList<Integer>();
			if(r1.next())
			{
				for(int i=0; i<16; i++)
					predictiveFeatureValue.add(r1.getInt(i+1));
			}
			if(predictiveFeatureValue.get(0)==1)
				predictiveFeature.add(IN_DEGREE);
			if(predictiveFeatureValue.get(1)==1)
				predictiveFeature.add(OUT_DEGREE);
			if(predictiveFeatureValue.get(2)==1)
				predictiveFeature.add(TOTAL_DEGREE);
			if(predictiveFeatureValue.get(3)==1)
				predictiveFeature.add(EIGENVECTOR);
			if(predictiveFeatureValue.get(4)==1)
				predictiveFeature.add(CLOSENESS);
			if(predictiveFeatureValue.get(5)==1)
				predictiveFeature.add(ECCENTRICITY);
			if(predictiveFeatureValue.get(6)==1)
				predictiveFeature.add(BETWEENNESS);
			if(predictiveFeatureValue.get(7)==1)
				predictiveFeature.add(BRIDGING_COEFFICIENT);
			if(predictiveFeatureValue.get(8)==1)
				predictiveFeature.add(BRIDGING_CENTRALITY);
			if(predictiveFeatureValue.get(9)==1)
				predictiveFeature.add(UNDIRECTED_CLUSTERING_COEFFICIENT);
			if(predictiveFeatureValue.get(10)==1)
				predictiveFeature.add(IN_CLUSTERING_COEFFICIENT);
			if(predictiveFeatureValue.get(11)==1)
				predictiveFeature.add(OUT_CLUSTERING_COEFFICIENT);
			if(predictiveFeatureValue.get(12)==1)
				predictiveFeature.add(CYCLE_CLUSTERING_COEFFICIENT);
			if(predictiveFeatureValue.get(13)==1)
				predictiveFeature.add(MIDDLEMAN_CLUSTERING_COEFFICIENT);
			if(predictiveFeatureValue.get(14)==1)
				predictiveFeature.add(PROXIMITY_PRESTIGE);
			if(predictiveFeatureValue.get(15)==1)
				predictiveFeature.add(TARGET_DOWNSTREAM_EFFECT);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return predictiveFeature;
	}

	public int getTotalNumberOfNodesInWholeNetwork()
	{
		int row=0; 
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT COUNT(*) FROM CURR_NETWORK_NODE;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				row=r1.getInt(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return row;
	}

	//return 0 if feature contains no null features - imply feature has been computed
	public int getFeature_featureComputed(String feature)
	{
		int row=0; 
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT COUNT(*) FROM CURR_NETWORK_NODE WHERE "+feature+" IS NULL;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				row=r1.getInt(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return row;
	}

	//return 0 if feature contains no null features - imply feature has been computed
	public int getFeature_featureNormRankComputed(String feature)
	{
		int row=0; 
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT COUNT(*) FROM CURR_NETWORK_NODE_NORMALIZED_RANKS WHERE "+feature+"_rank IS NULL;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				row=r1.getInt(1);
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return row;
	}

	private void initializeFeatureTable() {
		Statement statement=null;
		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<featureList.size(); i++)
			{
				sqlStatement="INSERT INTO CURR_NETWORK_FEATURE (FEATURE_ID, FEATURE_NAME) VALUES ('"+(i+1)+"', '"
						+featureList.get(i)+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public ArrayList<String> getAllFeatureHeadersOfNode() {
		ArrayList<String> list=new ArrayList<String>();

		list.add(IN_DEGREE);
		list.add(OUT_DEGREE);
		list.add(TOTAL_DEGREE);
		list.add(EIGENVECTOR);
		list.add(CLOSENESS);
		list.add(ECCENTRICITY);
		list.add(BETWEENNESS);
		list.add(BRIDGING_COEFFICIENT);
		list.add(BRIDGING_CENTRALITY);
		list.add(UNDIRECTED_CLUSTERING_COEFFICIENT);
		list.add(IN_CLUSTERING_COEFFICIENT);
		list.add(OUT_CLUSTERING_COEFFICIENT);
		list.add(CYCLE_CLUSTERING_COEFFICIENT);
		list.add(MIDDLEMAN_CLUSTERING_COEFFICIENT);
		list.add(PROXIMITY_PRESTIGE);
		list.add(TARGET_DOWNSTREAM_EFFECT);

		return list;
	}

	public ArrayList<String> getAllFeatureValuesOfNode(String node) {
		ArrayList<String> list=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			int nodeID=getNodeDBID(node);
			//join tables and get entries <drugName, drugSourceURL, drugSourceID, evidenceSourceURL, evidenceSourceID>
			result = statement.executeQuery("SELECT IN_DEGREE_RANK, OUT_DEGREE_RANK, TOTAL_DEGREE_RANK, EIGENVECTOR_RANK, CLOSENESS_RANK, "
					+ "ECCENTRICITY_RANK, BETWEENNESS_RANK, BRIDGING_COEFFICIENT_RANK, BRIDGING_CENTRALITY_RANK, "
					+ "UNDIRECTED_CLUSTERING_COEFFICIENT_RANK, IN_CLUSTERING_COEFFICIENT_RANK, OUT_CLUSTERING_COEFFICIENT_RANK, "
					+ "CYCLE_CLUSTERING_COEFFICIENT_RANK, MIDDLEMAN_CLUSTERING_COEFFICIENT_RANK, PROXIMITY_PRESTIGE_RANK, "
					+ "TARGET_DOWNSTREAM_EFFECT_RANK FROM CURR_NETWORK_NODE_NORMALIZED_RANKS WHERE NODE_ID='"+nodeID+"';");
			while(result.next())
			{
				for(int i=1; i<=MAX_FEATURES; i++)
					list.add(result.getString(i));
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	private String getFeatureRankString(ArrayList<String> list)
	{
		String s="";
		for(int i=0; i<list.size(); i++)
		{
			s=s+list.get(i)+"_rank";
			if(i<list.size()-1)
				s=s+", ";
		}
		return s;
	}

	public ArrayList<String> getFeatureValuesOfNode(ArrayList<String>featureList, String node) {
		ArrayList<String> list=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			int nodeID=getNodeDBID(node);
			//join tables and get entries <drugName, drugSourceURL, drugSourceID, evidenceSourceURL, evidenceSourceID>
			String sqlStatement="SELECT "+getFeatureRankString(featureList)+" FROM CURR_NETWORK_NODE_NORMALIZED_RANKS WHERE NODE_ID='"+nodeID+"';";
			//System.out.println("getFeatureValuesOfNode: "+sqlStatement);
			result = statement.executeQuery(sqlStatement);
			while(result.next())
			{
				for(int i=0; i<featureList.size(); i++)
					list.add(result.getString(i+1));
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public void updateNormalizedNodeRanks(ArrayList<String> selectedFeatures, JLabel status) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();
		int maxRank;
		String node, rank;
		int nodeDBID;
		float percentComplete1, percentComplete2;
		int totalCount1=selectedFeatures.size(), totalCount2;
		System.out.println("selectedFeatures "+selectedFeatures.toString());
		for(int i=0; i<totalCount1; i++)
		{
			DecimalFormat df = new DecimalFormat();
			df.setMaximumFractionDigits(2);
			if(totalCount1==1)
				percentComplete1=(float)100.0;
			else
				percentComplete1=(float)(100.0*i/(totalCount1-1));
			if(selectedFeatures.get(i).compareTo(TARGET_DOWNSTREAM_EFFECT)==0)
			{
				rankedList=get_featureAscRankAll(selectedFeatures.get(i));
				maxRank=get_featureAscMaxRank(selectedFeatures.get(i));
			}
			else
			{
				System.out.println("get_featureDesRankAll "+selectedFeatures.get(i));
				rankedList=get_featureDesRankAll(selectedFeatures.get(i));
				maxRank=get_featureDesMaxRank(selectedFeatures.get(i));
			}
			totalCount2=rankedList.size();
			for(int j=0; j<totalCount2; j++)
			{
				percentComplete2=(float)(100.0*j/(totalCount2-1));
				status.setText("updating normalized node ranks...for feature ["+selectedFeatures.get(i)+", "+df.format(percentComplete1)+"%] update each node ["+df.format(percentComplete2)+"%]");
				String[] s=new String[2];
				s=rankedList.get(j);
				node=s[0];
				rank=s[1];
				Double normRank=Double.valueOf(rank)/(Double.valueOf(maxRank));
				System.out.println("node:"+node+" rank:"+rank+" normRank:"+normRank+" maxRank:"+maxRank);
				nodeDBID=getNodeDBID(node);
				update_featureNormRank(getNodeID(nodeDBID), getNodeName(nodeDBID), selectedFeatures.get(i)+"_rank", normRank);
			}
		}
	}

	public void updateNodeRanks(ArrayList<String> selectedFeatures, JLabel status) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();
		String node, rank;
		int nodeDBID;
		float percentComplete1, percentComplete2;
		int totalCount1=selectedFeatures.size(), totalCount2;
		System.out.println("selectedFeatures "+selectedFeatures.toString());
		for(int i=0; i<totalCount1; i++)
		{
			DecimalFormat df = new DecimalFormat();
			df.setMaximumFractionDigits(2);
			if(totalCount1==1)
				percentComplete1=(float)100.0;
			else
				percentComplete1=(float)(100.0*i/(totalCount1-1));
			if(selectedFeatures.get(i).compareTo(TARGET_DOWNSTREAM_EFFECT)==0)
			{
				rankedList=get_featureAscRankAll(selectedFeatures.get(i));
			}
			else
			{
				System.out.println("get_featureDesRankAll "+selectedFeatures.get(i));
				rankedList=get_featureDesRankAll(selectedFeatures.get(i));
			}
			totalCount2=rankedList.size();
			for(int j=0; j<totalCount2; j++)
			{
				percentComplete2=(float)(100.0*j/(totalCount2-1));
				status.setText("updating node ranks...for each feature ["+df.format(percentComplete1)+"%] update each node ["+df.format(percentComplete2)+"%]");
				String[] s=new String[2];
				s=rankedList.get(j);
				node=s[0];
				rank=s[1];
				//System.out.println("node:"+node+" rank:"+rank);

				nodeDBID=getNodeDBID(node);
				update_featureRank(getNodeID(nodeDBID), getNodeName(nodeDBID), selectedFeatures.get(i)+"_rank", rank);
			}
		}
	}

	public void updatePathwayNodeRanks(ArrayList<String> selectedFeatures, JLabel status) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();
		String node, rank;
		int nodeDBID;
		float percentComplete1, percentComplete2;
		int totalCount1=selectedFeatures.size(), totalCount2;
		for(int i=0; i<totalCount1; i++)
		{
			DecimalFormat df = new DecimalFormat();
			df.setMaximumFractionDigits(2);
			if(totalCount1==1)
				percentComplete1=(float)100.0;
			else
				percentComplete1=(float)(100.0*i/(totalCount1-1));
			if(selectedFeatures.get(i).compareTo(TARGET_DOWNSTREAM_EFFECT)==0)
				rankedList=get_pathwayFeatureAscRankAll(selectedFeatures.get(i));
			else
				rankedList=get_pathwayFeatureDesRankAll(selectedFeatures.get(i));
			totalCount2=rankedList.size();
			for(int j=0; j<totalCount2; j++)
			{
				percentComplete2=(float)(100.0*j/(totalCount2-1));
				status.setText("updating node ranks...for each feature ["+df.format(percentComplete1)+"%] update each node ["+df.format(percentComplete2)+"%]");
				String[] s=new String[2];
				s=rankedList.get(j);
				node=s[0];
				rank=s[1];
				nodeDBID=getNodeDBID(node);
				update_pathwayFeatureRank(getNodeID(nodeDBID), getNodeName(nodeDBID), selectedFeatures.get(i)+"_rank", rank);
			}
		}
	}
	/*
	public void add_temp_common_ancestor(String node, String diseaseNodeList, String essential_offTargetStr, String outDegree_offTargetStr, boolean useEssentialRule, boolean useOutDegreeRule, String essentialWtStr, String outDegreeWtStr, String numDiseaseNode) {
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT * FROM TEMP_COMMON_ANCESTORS WHERE NODE='"+node+"';");

			if(!result.next())
			{
				double offTargetScore;
				if(useEssentialRule==true && useOutDegreeRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2)+Math.pow((outDegreeWt*outDegree),2));
				}
				else if(useEssentialRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2));
				}
				else
				{
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((outDegreeWt*outDegree),2));
				}
				sqlStatement="INSERT INTO TEMP_COMMON_ANCESTORS (NODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM) VALUES ('"+node+"', '"
						+diseaseNodeList+"', '"+essential_offTargetStr+"', '"+outDegree_offTargetStr+"', '"+offTargetScore+"', '"+numDiseaseNode+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	 */

	public void add_temp_candidate_all(String metanode, String diseaseNodeList, int numDiseaseNode) {
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT * FROM TEMP_CANDIDATE_ALL WHERE METANODE='"+metanode+"';");

			if(!result.next())
			{
				sqlStatement="INSERT INTO TEMP_CANDIDATE_ALL (METANODE, DISEASE_NODE_LIST, DISEASE_NODE_NUM) VALUES ('"+metanode+"', '"
						+diseaseNodeList+"', '"+numDiseaseNode+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void add_temp_candidate(String node, String diseaseNodeList, String essential_offTargetStr, String outDegree_offTargetStr, boolean useEssentialRule, boolean useOutDegreeRule, String essentialWtStr, String outDegreeWtStr, String numDiseaseNode) {
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT * FROM TEMP_CANDIDATE WHERE NEXTNODE='"+node+"';");

			if(!result.next())
			{
				double offTargetScore;
				if(useEssentialRule==true && useOutDegreeRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2)+Math.pow((outDegreeWt*outDegree),2));
				}
				else if(useEssentialRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2));
				}
				else
				{
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((outDegreeWt*outDegree),2));
				}
				sqlStatement="INSERT INTO TEMP_CANDIDATE (NEXTNODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM) VALUES ('"+node+"', '"
						+diseaseNodeList+"', '"+essential_offTargetStr+"', '"+outDegree_offTargetStr+"', '"+offTargetScore+"', '"+numDiseaseNode+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void removeMaxCoveringCandidateMetaNode() {
		try {
			Statement statement = conn.createStatement();
			statement.execute("DELETE FROM TEMP_CANDIDATE_ALL WHERE DISEASE_NODE_NUM=(SELECT MAX(DISEASE_NODE_NUM) FROM TEMP_CANDIDATE_ALL);");
			statement.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> getMaxCoveringCandidateMetaNode(ArrayList<String> diseaseNodeCovered) {
		ArrayList<String> metaNodeList=new ArrayList<String>();
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT METANODE FROM TEMP_CANDIDATE_ALL WHERE DISEASE_NODE_NUM=(SELECT MAX(DISEASE_NODE_NUM) FROM TEMP_CANDIDATE_ALL);");

			while(result.next())
			{
				String metaNode=result.getString(1);
				if(metaNodeList.contains(metaNode)==false)
					metaNodeList.add(metaNode);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return metaNodeList;
	}

	public ArrayList<String> getTopTempCombi(int topN) {
		ArrayList<String> nodeList=new ArrayList<String>();
		try {
			Statement statement = conn.createStatement();
			ResultSet result = statement.executeQuery("WITH cte AS (SELECT NEXTNODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM"+
					" FROM TEMP_COMBI AS NEW_TABLE ORDER BY DISEASE_NODE_NUM DESC, OFFTARGET_SCORE ASC) SELECT * FROM cte LIMIT "+topN+";");
			while(result.next())
			{
				String n=result.getString(1);
				if(nodeList.contains(n)==false)
					nodeList.add(n);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return nodeList;
	}

	public ArrayList<String> getTopTempCandidate(int topN) {
		ArrayList<String> nodeList=new ArrayList<String>();
		try {
			Statement statement = conn.createStatement();
			ResultSet result;
			if(topN>0)
				result= statement.executeQuery("WITH cte AS (SELECT NEXTNODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM"+
						" FROM TEMP_CANDIDATE AS NEW_TABLE ORDER BY DISEASE_NODE_NUM DESC, OFFTARGET_SCORE ASC) SELECT * FROM cte LIMIT "+topN+";");
			else
				result= statement.executeQuery("WITH cte AS (SELECT NEXTNODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM"+
						" FROM TEMP_CANDIDATE AS NEW_TABLE ORDER BY DISEASE_NODE_NUM DESC, OFFTARGET_SCORE ASC) SELECT * FROM cte;");
			while(result.next())
			{
				String n=result.getString(1);
				if(nodeList.contains(n)==false)
					nodeList.add(n);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return nodeList;
	}
	/*
	public ArrayList<String> getTopCommonAncestor(int topN) {
		ArrayList<String> nodeList=new ArrayList<String>();
		try {
			Statement statement = conn.createStatement();
			ResultSet result = statement.executeQuery("WITH cte AS (SELECT NODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM"+
					" FROM TEMP_COMMON_ANCESTORS AS NEW_TABLE ORDER BY DISEASE_NODE_NUM DESC, OFFTARGET_SCORE ASC) SELECT * FROM cte LIMIT "+topN+";");
			while(result.next())
			{
				String n=result.getString(1);
				if(nodeList.contains(n)==false)
					nodeList.add(n);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return nodeList;
	}
	 */
	public void update_feature(String sbml_node_id, String sbml_node_name, String feature, String value) {
		try {
			Statement statement = conn.createStatement();
			int nodeID=0;
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="UPDATE CURR_NETWORK_NODE SET "+feature+"='"+value+"' WHERE NODE_ID='"+nodeID+"';";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_pathwayFeature(String sbml_node_id, String sbml_node_name, String feature, String value) {
		try {
			Statement statement = conn.createStatement();
			int nodeID=0;
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="UPDATE CURR_PATHWAY_NODE SET "+feature+"='"+value+"' WHERE NODE_ID='"+nodeID+"';";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_featureNormRank(String sbml_node_id, String sbml_node_name, String feature, Double value) {
		try {
			Statement statement = conn.createStatement();
			int nodeID=0;
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE_NORMALIZED_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="UPDATE CURR_NETWORK_NODE_NORMALIZED_RANKS SET "+feature+"='"+value+"' WHERE NODE_ID='"+nodeID+"';";
				//System.out.println(sqlStatement);
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_featureRank(String sbml_node_id, String sbml_node_name, String feature, String value) {
		try {
			Statement statement = conn.createStatement();
			int nodeID=0;
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="UPDATE CURR_NETWORK_NODE_RANKS SET "+feature+"='"+value+"' WHERE NODE_ID='"+nodeID+"';";
				//System.out.println(sqlStatement);
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_pathwayFeatureRank(String sbml_node_id, String sbml_node_name, String feature, String value) {
		try {
			Statement statement = conn.createStatement();
			int nodeID=0;
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="UPDATE CURR_PATHWAY_NODE_RANKS SET "+feature+"='"+value+"' WHERE NODE_ID='"+nodeID+"';";
				//System.out.println(sqlStatement);
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_pValue(String feature, String value) {
		Statement statement=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			int featureID=0;
			String sqlStatement=null;

			//get featureID
			result = statement.executeQuery("SELECT FEATURE_ID FROM CURR_NETWORK_FEATURE WHERE FEATURE_NAME='"+feature+"';");
			if(result.next())
			{
				featureID=result.getInt(1);

				sqlStatement="UPDATE CURR_NETWORK_FEATURE SET WILCOXON_PVALUE='"+value+"' WHERE FEATURE_ID='"+featureID+"';";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_predicted_combi_mono_curation(String method, ArrayList<String> combi, String score) {
		int maxID=0;

		//at the moment dealing with 2-sized combi
		String target1=combi.get(0);
		String target2=combi.get(1);
		String firstTarget, secondTarget;
		//we always store the combi's target in alphabetical order (i.e., firstTarget is alphabetically ordered in front of secondTarget)
		if(target1.compareTo(target2)<0)
		{
			firstTarget=target1;
			secondTarget=target2;
		}
		else
		{
			firstTarget=target2;
			secondTarget=target1;
		}

		try {
			//check if this combi is already in the table
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT COMBI_ID FROM PREDICTEDCOMBI_COMBI WHERE METHOD='"+method+"' AND TARGET_1_NAME='"+firstTarget+"' AND TARGET_2_NAME='"+secondTarget+"' AND SCORE='"+score+"';";
			ResultSet result=statement.executeQuery(sqlStatement);

			System.out.println("to insert:"+firstTarget+", "+secondTarget+" :"+method+" "+score);

			if(!result.next())
			{
				//find current maximum ID in table
				sqlStatement="SELECT MAX(COMBI_ID) FROM PREDICTEDCOMBI_COMBI;";
				Statement statement2=conn.createStatement();
				ResultSet result2=statement2.executeQuery(sqlStatement);

				if(result2.next())
					maxID=result2.getInt(1)+1;
				else
					maxID=1;

				System.out.println(firstTarget+","+secondTarget+": "+maxID);
				//check if firstTarget is used in any combination
				int firstTargetInCuration=0;
				sqlStatement="SELECT TARGET_ID FROM CURATEDMONO_TARGET WHERE TARGET_NAME='"+firstTarget+"';";
				Statement statement1=conn.createStatement();
				ResultSet result1=statement1.executeQuery(sqlStatement);
				if(result1.next())
					firstTargetInCuration=1;
				statement1.close();
				result1.close();
				//check if secondTarget is used in any combination
				int secondTargetInCuration=0;
				sqlStatement="SELECT TARGET_ID FROM CURATEDMONO_TARGET WHERE TARGET_NAME='"+secondTarget+"';";
				statement1=conn.createStatement();
				result1=statement1.executeQuery(sqlStatement);
				if(result1.next())
					secondTargetInCuration=1;
				statement1.close();
				result1.close();
				//check if combi as a whole exist in curated combination
				int combiInCuration=0;
				//sqlStatement="SELECT COMBI_ID FROM CURATEDCOMBI_COMBI WHERE TARGET_1_NAME='"+firstTarget+"' AND TARGET_2_NAME='"+secondTarget+"';";
				//statement1=conn.createStatement();
				//result1=statement1.executeQuery(sqlStatement);
				//if(result1.next())
				//	combiInCuration=1;
				//statement1.close();
				//result1.close();

				//insert into predictedCombi_combi table
				sqlStatement="INSERT INTO PREDICTEDCOMBI_COMBI (COMBI_ID, METHOD, SCORE, TARGET_1_NAME, TARGET_2_NAME, TARGET_1_IN_CURATION, TARGET_2_IN_CURATION, COMBI_IN_CURATION) VALUES ('"+maxID+"', '"
						+method+"', '"+score+"', '"+firstTarget+"', '"+secondTarget+"', '"+firstTargetInCuration+"', '"+secondTargetInCuration+"', '"+combiInCuration+"');";
				statement2.execute(sqlStatement);
				result2.close();
				statement2.close();
			}
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void update_predicted_combi_combi_curation(String method, ArrayList<String> combi, String score) {
		int maxID=0;

		//at the moment dealing with 2-sized combi
		String target1=combi.get(0);
		String target2=combi.get(1);
		String firstTarget, secondTarget;
		//we always store the combi's target in alphabetical order (i.e., firstTarget is alphabetically ordered in front of secondTarget)
		if(target1.compareTo(target2)<0)
		{
			firstTarget=target1;
			secondTarget=target2;
		}
		else
		{
			firstTarget=target2;
			secondTarget=target1;
		}

		try {
			//check if this combi is already in the table
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT COMBI_ID FROM PREDICTEDCOMBI_COMBI WHERE METHOD='"+method+"' AND TARGET_1_NAME='"+firstTarget+"' AND TARGET_2_NAME='"+secondTarget+"' AND SCORE='"+score+"';";
			ResultSet result=statement.executeQuery(sqlStatement);

			System.out.println("to insert:"+firstTarget+", "+secondTarget+" :"+method+" "+score);

			if(!result.next())
			{
				//find current maximum ID in table
				sqlStatement="SELECT MAX(COMBI_ID) FROM PREDICTEDCOMBI_COMBI;";
				Statement statement2=conn.createStatement();
				ResultSet result2=statement2.executeQuery(sqlStatement);

				if(result2.next())
					maxID=result2.getInt(1)+1;
				else
					maxID=1;

				System.out.println(firstTarget+","+secondTarget+": "+maxID);
				//check if firstTarget is used in any combination
				int firstTargetInCuration=0;
				sqlStatement="SELECT COMBI_ID FROM CURATEDCOMBI_COMBI WHERE TARGET_1_NAME='"+firstTarget+"' OR TARGET_2_NAME='"+firstTarget+"';";
				Statement statement1=conn.createStatement();
				ResultSet result1=statement1.executeQuery(sqlStatement);
				if(result1.next())
					firstTargetInCuration=1;
				statement1.close();
				result1.close();
				//check if secondTarget is used in any combination
				int secondTargetInCuration=0;
				sqlStatement="SELECT COMBI_ID FROM CURATEDCOMBI_COMBI WHERE TARGET_1_NAME='"+secondTarget+"' OR TARGET_2_NAME='"+secondTarget+"';";
				statement1=conn.createStatement();
				result1=statement1.executeQuery(sqlStatement);
				if(result1.next())
					secondTargetInCuration=1;
				statement1.close();
				result1.close();
				//check if combi as a whole exist in curated combination
				int combiInCuration=0;
				sqlStatement="SELECT COMBI_ID FROM CURATEDCOMBI_COMBI WHERE TARGET_1_NAME='"+firstTarget+"' AND TARGET_2_NAME='"+secondTarget+"';";
				statement1=conn.createStatement();
				result1=statement1.executeQuery(sqlStatement);
				if(result1.next())
					combiInCuration=1;
				statement1.close();
				result1.close();

				//insert into predictedCombi_combi table
				sqlStatement="INSERT INTO PREDICTEDCOMBI_COMBI (COMBI_ID, METHOD, SCORE, TARGET_1_NAME, TARGET_2_NAME, TARGET_1_IN_CURATION, TARGET_2_IN_CURATION, COMBI_IN_CURATION) VALUES ('"+maxID+"', '"
						+method+"', '"+score+"', '"+firstTarget+"', '"+secondTarget+"', '"+firstTargetInCuration+"', '"+secondTargetInCuration+"', '"+combiInCuration+"');";
				statement2.execute(sqlStatement);
				result2.close();
				statement2.close();
			}
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void update_curated_drug(String disease, String drug, ArrayList<String> targetList) {
		int maxID=0;

		try {
			for(int i=0; i<targetList.size(); i++)
			{
				String target=targetList.get(i);
				//check if this target is already in the table
				Statement statement = conn.createStatement();
				String sqlStatement="SELECT TARGET_ID FROM CURATEDMONO_TARGET WHERE TARGET_NAME='"+target+"';";
				ResultSet result=statement.executeQuery(sqlStatement);

				System.out.println("to insert:"+target);

				if(result.next())
				{
					int target_id=result.getInt(1);
					System.out.println("************* target_id:"+target_id);
					//insert into curateMono_drug table if its not present
					Statement statement1=conn.createStatement();
					sqlStatement="SELECT * FROM CURATEDMONO_DRUG WHERE DRUG='"+drug+"' AND TARGET_ID='"+target_id+"';";
					ResultSet result1=statement1.executeQuery(sqlStatement);
					if(!result1.next())
					{
						sqlStatement="INSERT INTO CURATEDMONO_DRUG (DRUG, TARGET_ID) VALUES ('"+drug+"', '"
								+target_id+"');";
						statement.execute(sqlStatement);
					}
					statement1.close();
					result1.close();
				}
				else
				{
					//find current maximum ID in table
					sqlStatement="SELECT MAX(TARGET_ID) FROM CURATEDMONO_TARGET;";
					Statement statement2=conn.createStatement();
					ResultSet result2=statement2.executeQuery(sqlStatement);

					if(result2.next())
						maxID=result2.getInt(1)+1;
					else
						maxID=1;

					System.out.println(target+": "+maxID);
					//insert into curatedMono_target table
					sqlStatement="INSERT INTO CURATEDMONO_TARGET (TARGET_ID, TARGET_NAME) VALUES ('"+maxID+"', '"
							+target+"');";
					statement2.execute(sqlStatement);
					//insert into curatedMono_drug table
					sqlStatement="INSERT INTO CURATEDMONO_DRUG (DRUG, TARGET_ID) VALUES ('"+drug+"', '"
							+maxID+"');";
					statement2.execute(sqlStatement);
				}//end else
				result.close();
				statement.close();
			}//end for
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void update_curated_combi(String disease, ArrayList<String> nctid, ArrayList<String> target1, ArrayList<String> target2, ArrayList<String> allNodeList) {
		int maxID=0;

		if(allNodeList.size()==0)
		{
			JOptionPane.showMessageDialog(new JFrame(), "Please select load the network first before populating curated combinations or drugs so that we only populate those valid combinations with all components in the network", "Error", JOptionPane.ERROR_MESSAGE);
		}
		//we are looking at unique combination where target1<>target2
		target2.removeAll(target1);

		try {
			//we always store the combi's target in alphabetical order (i.e., firstTarget is alphabetically ordered in front of secondTarget)
			for(int i=0; i<target1.size(); i++)
			{
				for(int j=0; j<target2.size(); j++)
				{
					String firstTarget, secondTarget;
					if(target1.get(i).compareTo(target2.get(j))<0)
					{
						firstTarget=target1.get(i);
						secondTarget=target2.get(j);
					}
					else
					{
						firstTarget=target2.get(j);
						secondTarget=target1.get(i);
					}
					//check if this combi is valid
					if(allNodeList.contains(firstTarget) && allNodeList.contains(secondTarget))
					{	

						//check if this combi is already in the table
						Statement statement = conn.createStatement();
						String sqlStatement="SELECT COMBI_ID FROM CURATEDCOMBI_COMBI WHERE TARGET_1_NAME='"+firstTarget+"' AND TARGET_2_NAME='"+secondTarget+"';";
						ResultSet result=statement.executeQuery(sqlStatement);

						System.out.println("to insert:"+firstTarget+", "+secondTarget);

						if(result.next())
						{
							int combi_id=result.getInt(1);
							System.out.println("************* combi_id:"+combi_id);
							//insert into curateCombi_nctid table if its not present
							for(int k=0; k<nctid.size(); k++)
							{
								Statement statement1=conn.createStatement();
								sqlStatement="SELECT * FROM CURATEDCOMBI_NCTID WHERE COMBI_ID='"+combi_id+"' AND NCTID='"+nctid.get(k)+"';";
								ResultSet result1=statement1.executeQuery(sqlStatement);

								if(!result1.next())
								{
									sqlStatement="INSERT INTO CURATEDCOMBI_NCTID (COMBI_ID, NCTID) VALUES ('"+combi_id+"', '"
											+nctid.get(k)+"');";
									statement.execute(sqlStatement);
								}
								statement1.close();
								result1.close();
							}
							//insert into curatedCombi_disease table if its not present
							Statement statement1=conn.createStatement();
							sqlStatement="SELECT * FROM CURATEDCOMBI_DISEASE WHERE COMBI_ID='"+combi_id+"' AND DISEASE='"+disease+"';";
							ResultSet result1=statement1.executeQuery(sqlStatement);

							if(!result1.next())
							{
								sqlStatement="INSERT INTO CURATEDCOMBI_DISEASE (COMBI_ID, DISEASE) VALUES ('"+combi_id+"', '"
										+disease+"');";
								statement.execute(sqlStatement);
							}
							statement1.close();
							result1.close();
						}
						else
						{
							//find current maximum ID in table
							sqlStatement="SELECT MAX(COMBI_ID) FROM CURATEDCOMBI_COMBI;";
							Statement statement2=conn.createStatement();
							ResultSet result2=statement2.executeQuery(sqlStatement);

							if(result2.next())
								maxID=result2.getInt(1)+1;
							else
								maxID=1;

							System.out.println(firstTarget+","+secondTarget+": "+maxID);
							//insert into curatedCombi_combi table
							sqlStatement="INSERT INTO CURATEDCOMBI_COMBI (COMBI_ID, TARGET_1_NAME, TARGET_2_NAME) VALUES ('"+maxID+"', '"
									+firstTarget+"', '"+secondTarget+"');";
							statement2.execute(sqlStatement);
							//insert into curatedCombi_disease table
							sqlStatement="INSERT INTO CURATEDCOMBI_DISEASE (COMBI_ID, DISEASE) VALUES ('"+maxID+"', '"
									+disease+"');";
							statement2.execute(sqlStatement);
							//insert into curateCombi_nctid table
							for(int k=0; k<nctid.size(); k++)
							{
								sqlStatement="INSERT INTO CURATEDCOMBI_NCTID (COMBI_ID, NCTID) VALUES ('"+maxID+"', '"
										+nctid.get(k)+"');";
								statement2.execute(sqlStatement);
							}
							result2.close();
							statement2.close();
						}//end else
						result.close();
						statement.close();
					}//end if combi is valid
				}//end for
			}//end for
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public void update_source(String source_name, String source_url, String source_param) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;

			//check if source exists
			ResultSet r1 = s1.executeQuery("SELECT SOURCE_NAME FROM SOURCE WHERE SOURCE_NAME='"+source_name+"' AND SOURCE_URL='"+source_url+"' AND SOURCE_NUM_PARAM='"+source_param+"';");
			if(!r1.next())
			{
				sqlStatement="INSERT INTO SOURCE (SOURCE_NAME, SOURCE_URL, SOURCE_NUM_PARAM) VALUES ('"+source_name+"', '"+source_url+"', '"+source_param+"');";
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> getHallmark_retrieveHallmarkBasedOnGivenGOAnnotation(ArrayList<ArrayList<String>> GOList)
	{
		ArrayList<String> hallmarkList=new ArrayList<String>();

		if(GOList.size()>0)
		{
			String GOListString="";
			for(int i=0; i<GOList.size(); i++)
			{
				GOListString=GOListString+"'"+GOList.get(i).get(0)+"'";
				if(i<GOList.size()-1)
					GOListString=GOListString+", ";
			}
			try {
				Statement s = conn.createStatement();
				//extra all records
				ResultSet r = s.executeQuery("SELECT DISTINCT HALLMARK_TYPE FROM HALLMARK_GO_MAPPING WHERE GO_ID IN ("+GOListString+");");
				while(r.next())
					hallmarkList.add(r.getString(1));
				s.close();
				r.close();
			}catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			}
		}

		return hallmarkList;
	}

	public ArrayList<ArrayList<String>> getHallmark_nodeListOfHallmarkList(ArrayList<String> hallmarkList)
	{
		ArrayList<ArrayList<String>> nodeIDNameList=new ArrayList<ArrayList<String>>();
		ArrayList<Integer> nodeDBIDList=new ArrayList<Integer>();
		String hallmarkString="";
		for(int i=0; i<hallmarkList.size(); i++)
		{
			hallmarkString=hallmarkString+hallmarkList.get(i)+"='1'";
			if(i<hallmarkList.size()-1)
				hallmarkString=hallmarkString+" AND ";
		}

		try {
			Statement s = conn.createStatement();
			//get original hallmarkGO list
			ResultSet r = s.executeQuery("SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmarkString+";");
			while(r.next())
				nodeDBIDList.add(r.getInt(1));

			for(int i=0; i<nodeDBIDList.size(); i++)
			{
				r = s.executeQuery("SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID="+nodeDBIDList.get(i)+";");
				if(r.next())
				{
					ArrayList<String> element=new ArrayList<String>();
					element.add(r.getString(1));
					element.add(r.getString(2));
					nodeIDNameList.add(element);
				}
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDNameList;
	}

	public ArrayList<ArrayList<String>> getHallmark_nodeListOfHallmark(String hallmark)
	{
		ArrayList<ArrayList<String>> nodeIDNameList=new ArrayList<ArrayList<String>>();
		ArrayList<Integer> nodeDBIDList=new ArrayList<Integer>();

		try {
			Statement s = conn.createStatement();
			//get original hallmarkGO list
			ResultSet r = s.executeQuery("SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmark+"='1';");
			while(r.next())
				nodeDBIDList.add(r.getInt(1));

			for(int i=0; i<nodeDBIDList.size(); i++)
			{
				r = s.executeQuery("SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID="+nodeDBIDList.get(i)+";");
				if(r.next())
				{
					ArrayList<String> element=new ArrayList<String>();
					element.add(r.getString(1));
					element.add(r.getString(2));
					nodeIDNameList.add(element);
				}
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDNameList;
	}

	public ArrayList<String> getHallmark_nodesAnnotatedWithAllSelectedHallmarks(ArrayList<String> selectedHallmark)
	{
		ArrayList<String> nodeList=new ArrayList<String>();
		String hallmarkString="";
		for(int i=0; i<selectedHallmark.size(); i++)
		{
			hallmarkString=hallmarkString+selectedHallmark.get(i)+"='1'";
			if(i<selectedHallmark.size()-1)
				hallmarkString=hallmarkString+" AND ";
		}
		System.out.println("hallmarkString:"+hallmarkString);

		try {
			Statement s = conn.createStatement();
			//get original hallmarkGO list
			ResultSet r = s.executeQuery("SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmarkString+";");
			while(r.next())
			{
				int nodeDBID=r.getInt(1);
				nodeList.add(getNodeName(nodeDBID));
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return nodeList;
	}

	public void update_hallmarkGO(String node, ArrayList<ArrayList<String>> GOList)
	{
		ArrayList<String> OriginalGOList=new ArrayList<String>();
		ArrayList<ArrayList<String>> OriginalGOListDetails=new ArrayList<ArrayList<String>>();
		ArrayList<String> GOListIDOnly=new ArrayList<String>();
		ArrayList<String> toAdd=new ArrayList<String>();
		ArrayList<ArrayList<String>> toAddDetails=new ArrayList<ArrayList<String>>();
		ArrayList<String> toRemove=new ArrayList<String>();
		ArrayList<ArrayList<String>> toRemoveDetails=new ArrayList<ArrayList<String>>();
		int nodeDBID=getNodeDBID(node);
		String nodeID=getNodeID(nodeDBID);

		for(int i=0; i<GOList.size(); i++)
			GOListIDOnly.add(GOList.get(i).get(0));

		try {
			Statement s = conn.createStatement();
			//get original hallmarkGO list
			ResultSet r = s.executeQuery("SELECT SOURCE_ID, SOURCE_TYPE FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeDBID+"' AND SOURCE_NAME='GO'" +
					"AND SOURCE_ID IN (SELECT GO_ID FROM HALLMARK_GO_MAPPING);");
			while(r.next())
			{
				OriginalGOList.add(r.getString(1));
				ArrayList<String> element=new ArrayList<String>();
				element.add(r.getString(1));
				element.add(r.getString(2));
				OriginalGOListDetails.add(element);
			}
			//find toAdd GO annotations - those in GOList, but not in OriginalGOList
			for(int i=0; i<GOListIDOnly.size(); i++)
				toAdd.add(GOListIDOnly.get(i));
			toAdd.removeAll(OriginalGOList);
			for(int i=0; i<toAdd.size(); i++)
			{
				int index=GOListIDOnly.indexOf(toAdd.get(i));
				toAddDetails.add(GOList.get(index));
			}

			//find toRemove GO annotations - those in OriginalGOList, but not in GOList
			for(int i=0; i<OriginalGOList.size(); i++)
				toRemove.add(OriginalGOList.get(i));
			toRemove.removeAll(GOListIDOnly);
			for(int i=0; i<toRemove.size(); i++)
			{
				int index=OriginalGOList.indexOf(toRemove.get(i));
				toRemoveDetails.add(OriginalGOListDetails.get(index));
			}

			if(toAddDetails.size()>0)
			{
				for(int i=0; i<toAddDetails.size(); i++)
					update_nodeAnnotation(nodeID, "GO", toAddDetails.get(i).get(0), toAddDetails.get(i).get(1)+",,");
			}
			if(toRemove.size()>0)
			{
				for(int i=0; i<toRemoveDetails.size(); i++)
					remove_nodeAnnotation(node, "GO", toRemoveDetails.get(i).get(0), toRemoveDetails.get(i).get(1));
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> getHallmark_retrieveGOOfNodeInHallmarkGOMapping(String node)
	{
		ArrayList<String> GOList=new ArrayList<String>();
		int nodeDBID=getNodeDBID(node);
		try {
			Statement s = conn.createStatement();
			//extract all records
			ResultSet r = s.executeQuery("SELECT SOURCE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeDBID+"' AND SOURCE_NAME='GO'" +
					"AND SOURCE_ID IN (SELECT GO_ID FROM HALLMARK_GO_MAPPING);");
			while(r.next())
				GOList.add(r.getString(1));
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return GOList;
	}

	public ArrayList<ArrayList<String>> getHallmark_entireGOIDNameList()
	{
		ArrayList<ArrayList<String>> list=new ArrayList<ArrayList<String>>();

		try {
			Statement s = conn.createStatement();
			//extra all records
			ResultSet r = s.executeQuery("SELECT GO_ID, GO_NAME FROM HALLMARK_GO_MAPPING;");
			while(r.next())
			{
				ArrayList<String> element=new ArrayList<String>();
				element.add(r.getString(1));
				element.add(r.getString(2));
				list.add(element);
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return list;
	}

	public void insert_hallmark_go_mapping(String hallmark_type, String GO_id, String GO_name, String GO_type) {
		try {
			Statement s = conn.createStatement();
			String sqlStatement=null;

			//check if record exists
			ResultSet r = s.executeQuery("SELECT * FROM HALLMARK_GO_MAPPING WHERE HALLMARK_TYPE='"+hallmark_type+"' AND " +
					"GO_ID='"+GO_id+"' AND GO_NAME='"+GO_name+"' AND GO_TYPE='"+GO_type+"';");
			if(!r.next())
			{
				sqlStatement="INSERT INTO HALLMARK_GO_MAPPING (HALLMARK_TYPE, GO_ID, GO_NAME, GO_TYPE) VALUES ('"
						+hallmark_type+"', '"+GO_id+"', '"+GO_name+"', '"+GO_type+"');";
				System.out.println("sql:"+sqlStatement);
				s.execute(sqlStatement);
			}
			s.close();
			r.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void insert_hallmark(String node, ArrayList<String> hallmark) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(node);
			//check if node exists
			ResultSet r1 = s1.executeQuery("SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE NODE_ID='"+nodeID+"';");
			System.out.println("hallmark:"+hallmark.toString());
			if(!r1.next())
			{
				//System.out.println("NOT found "+node+" "+hallmark.toString());
				sqlStatement="INSERT INTO HALLMARK_HALLMARK (NODE_ID, PROLIFERATION, GROWTH_REPRESSOR, APOPTOSIS, "
						+"REPLICATIVE_IMMORTALITY, ANGIOGENESIS, METASTASIS, METABOLISM, IMMUNE_DESTRUCTION, GENOME_INSTABILITY, TUMOR_PROMOTING_INFLAMMATION) VALUES ('"
						+nodeID+"', '"+hallmark.get(0)+"', '"+hallmark.get(1)+"', '"+hallmark.get(2)+"', '"
						+hallmark.get(3)+"', '"+hallmark.get(4)+"', '"+hallmark.get(5)+"', '"+hallmark.get(6)+"', '"
						+hallmark.get(7)+"', '"+hallmark.get(8)+"', '"+hallmark.get(9)+"');";
				System.out.println("sql:"+sqlStatement);
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_hallmark(String node, ArrayList<String> hallmark) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(node);
			//check if node exists
			ResultSet r1 = s1.executeQuery("SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE NODE_ID='"+nodeID+"';");
			System.out.println("hallmark:"+hallmark.toString());
			if(r1.next())
			{
				//System.out.println("NOT found "+node+" "+hallmark.toString());
				sqlStatement="UPDATE HALLMARK_HALLMARK SET PROLIFERATION='"+hallmark.get(0)+"', GROWTH_REPRESSOR='"+hallmark.get(1)+"', APOPTOSIS='"+hallmark.get(2)+"', "
						+"REPLICATIVE_IMMORTALITY='"+hallmark.get(3)+"', ANGIOGENESIS='"+hallmark.get(4)+"', METASTASIS='"+hallmark.get(5)+"', METABOLISM='"+hallmark.get(6)+"', "
						+"IMMUNE_DESTRUCTION='"+hallmark.get(7)+"', GENOME_INSTABILITY='"+hallmark.get(8)+"', TUMOR_PROMOTING_INFLAMMATION='"+hallmark.get(9)+"' WHERE NODE_ID="+nodeID+";";
				System.out.println("sql:"+sqlStatement);
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_hallmark_annotation(String node, String source, String source_id) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(node);
			//check if node exists
			ResultSet r1 = s1.executeQuery("SELECT NODE_ID FROM HALLMARK_ANNOTATION WHERE NODE_ID='"+nodeID
					+"' AND ANNOTATION_TYPE='"+source+"' AND ANNOTATION_ID='"+source_id+"';");
			if(!r1.next())
			{
				//System.out.println("NOT found "+node+" "+source+" "+source_id);
				sqlStatement="INSERT INTO HALLMARK_ANNOTATION (NODE_ID, ANNOTATION_TYPE, ANNOTATION_ID) VALUES ('"
						+nodeID+"', '"+source+"', '"+source_id+"');";
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_kineticsRateAnnotation(String rateID, String organism, String cellLine, String source, String rateParam, String rateValue)
	{
		String sqlStatement;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			sqlStatement="SELECT RATE_ID FROM KINETICS_RATE_ANNOTATION WHERE RATE_ID='"+rateID+"' AND ORGANISM='"+organism+"' AND CELL_LINE='"
					+ cellLine+"' AND SOURCE='"+source+"' AND PARAMETER='"+rateParam+"' AND VALUE='"+rateValue+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				sqlStatement="INSERT INTO KINETICS_RATE_ANNOTATION (RATE_ID, ORGANISM, CELL_LINE, SOURCE, PARAMETER, VALUE) "
						+ "VALUES ('"+rateID+"', '"+organism+"', '"+cellLine+"', '"+source+"', '"+rateParam+"', '"+rateValue+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void update_kineticsRate(String kineticsID, String rateID)
	{
		String sqlStatement;
		Statement statement=null;
		ResultSet result=null;
		int maxID;

		try {
			statement= conn.createStatement();

			sqlStatement="SELECT COUNT(ID) FROM KINETICS_RATE;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxID=result.getInt(1)+1;
			else
				maxID=1;

			sqlStatement="SELECT ID FROM KINETICS_RATE WHERE KINETICS_ID='"+kineticsID+"' AND RATE_ID='"+rateID+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				sqlStatement="INSERT INTO KINETICS_RATE (ID, KINETICS_ID, RATE_ID) VALUES ('"+maxID+"', '"+kineticsID+"', '"+rateID+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void update_kinetics(String sourceID, String sourceName, String targetID, String targetName, String edgeType, String kineticsID)
	{
		String sqlStatement;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement= conn.createStatement();

			sqlStatement="SELECT KINETICS_ID FROM KINETICS_KINETICS WHERE SOURCE_NODE_ID='"+sourceID+"' AND SOURCE_NODE_NAME='"+sourceName
					+ "' AND TARGET_NODE_ID='"+ targetID+"' AND TARGET_NODE_NAME='"+targetName+"' AND EDGE_TYPE='"+edgeType+"' AND KINETICS_ID='"+kineticsID+"';";
			result=statement.executeQuery(sqlStatement);

			if(!result.next())
			{
				sqlStatement="INSERT INTO KINETICS_KINETICS (SOURCE_NODE_ID, SOURCE_NODE_NAME, TARGET_NODE_ID, TARGET_NODE_NAME, EDGE_TYPE, KINETICS_ID) "
						+ "VALUES ('"+sourceID+"', '"+sourceName+"', '"+targetID+"', '"+targetName+"', '"+edgeType+"', '"+kineticsID+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void remove_pathway(String pathwayName) {
		try {
			Statement s = conn.createStatement();
			s.execute("DELETE FROM PATHWAY WHERE PATHWAY_NAME='"+pathwayName+"';");
			s.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_pathway(String pathwayID, String pathwayName, boolean showSuccessDialog) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			//check if pathway exists
			ResultSet r1 = s1.executeQuery("SELECT PATHWAY_ID FROM PATHWAY WHERE PATHWAY_ID='"+pathwayID
					+"' AND PATHWAY_NAME='"+pathwayName+"';");
			if(!r1.next())
			{
				sqlStatement="INSERT INTO PATHWAY (PATHWAY_ID, PATHWAY_NAME) VALUES ('"
						+pathwayID+"', '"+pathwayName+"');";
				s2.execute(sqlStatement);
				if(showSuccessDialog)
					JOptionPane.showMessageDialog(new JFrame(), "Pathway added. Pathway ID="+pathwayID+", Pathway name="+pathwayName, "Update successful", JOptionPane.INFORMATION_MESSAGE);
			}
			else
			{
				if(showSuccessDialog)
					JOptionPane.showMessageDialog(new JFrame(), "Pathway not added. Pathway ID="+pathwayID+" already exists in database.", "Update failed", JOptionPane.ERROR_MESSAGE);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void update_nodeAnnotation(String entrezID, String sourceName, String sourceID, String sourceType) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(entrezID);

			//check if node exists
			ResultSet r1 = s1.executeQuery("SELECT NODE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID
					+"' AND SOURCE_NAME='"+sourceName+"' AND SOURCE_ID='"+sourceID+"' AND SOURCE_TYPE='"+sourceType+"';");
			if(!r1.next())
			{
				sqlStatement="INSERT INTO NODE_ANNOTATION (NODE_ID, SOURCE_NAME, SOURCE_ID, SOURCE_TYPE) VALUES ('"
						+nodeID+"', '"+sourceName+"', '"+sourceID+"', '"+sourceType+"');";
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void remove_nodeAnnotation(String node, String sourceName, String sourceID, String sourceType) {
		try {
			Statement s1 = conn.createStatement(), s2=conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(node);

			//check if node exists
			ResultSet r1 = s1.executeQuery("SELECT NODE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID
					+"' AND SOURCE_NAME='"+sourceName+"' AND SOURCE_ID='"+sourceID+"' AND SOURCE_TYPE='"+sourceType+"';");
			if(r1.next())
			{
				sqlStatement="DELETE FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID+"' AND SOURCE_NAME='"+sourceName
						+"' AND SOURCE_ID='"+sourceID+"' AND SOURCE_TYPE='"+sourceType+"';";
				s2.execute(sqlStatement);
			}
			s2.close();
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void remove_node(String name, String id) {
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement=null;
			int nodeID;

			//get nodeID
			nodeID=getNodeDBID(name);
			if(nodeID!=-1)
			{
				sqlStatement="DELETE FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"' AND SBML_NODE_ID='"+id
						+"' AND SBML_NODE_NAME='"+name+"';";
				s1.execute(sqlStatement);
			}
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> getNode_orderByFeatureRankAsc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+"_RANK, SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+"_RANK ASC, SBML_NODE_NAME ASC) FROM CURR_NETWORK_NODE_RANKS) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayFeatureRankAsc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+"_RANK, SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+"_RANK ASC, SBML_NODE_NAME ASC) FROM CURR_PATHWAY_NODE_RANKS) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByFeatureRankDesc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+"_RANK, SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+"_RANK DESC, SBML_NODE_NAME ASC) FROM CURR_NETWORK_NODE_RANKS) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayFeatureRankDesc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+"_RANK, SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+"_RANK DESC, SBML_NODE_NAME ASC) FROM CURR_PATHWAY_NODE_RANKS) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByFeatureAsc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+" ASC, SBML_NODE_NAME ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayFeatureAsc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+" ASC, SBML_NODE_NAME ASC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByFeatureDesc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+" DESC, SBML_NODE_NAME ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayFeatureDesc(String feature)
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY "+feature+" DESC, SBML_NODE_NAME ASC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByNodeAsc()
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY SBML_NODE_NAME ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayNodeAsc()
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY SBML_NODE_NAME ASC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByNodeDesc()
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY SBML_NODE_NAME DESC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getNode_orderByPathwayNodeDesc()
	{
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME FROM (SELECT SBML_NODE_NAME, NODE_ID, DENSE_RANK() "
					+ "OVER (ORDER BY SBML_NODE_NAME DESC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<annotation> getNode_annotationOfNode(String node, String source_mode, String source_type) {
		ArrayList<annotation> annotationList=new ArrayList<annotation>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			int nodeID=getNodeDBID(node);

			if(source_mode.compareTo(staticString.getDBGO())!=0)
			{
				if(source_mode.compareTo(staticString.getDBKEGGPathway())==0)
					sqlStatement="SELECT SOURCE_NAME, SOURCE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID+"' AND SOURCE_NAME='KEGG pathway';";
				else
					sqlStatement="SELECT SOURCE_NAME, SOURCE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID+"' AND SOURCE_NAME<>'GO' AND SOURCE_NAME<>'KEGG pathway';";
			}
			else
				sqlStatement="SELECT SOURCE_NAME, SOURCE_ID FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID+"' AND SOURCE_NAME='GO' AND SOURCE_TYPE='"+source_type+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				String source=r1.getString(1);
				String id=r1.getString(2);

				System.out.println("source:"+source+" id:"+id);

				sqlStatement="SELECT SOURCE_URL FROM SOURCE WHERE SOURCE_NAME='"+source+"';";
				Statement s2=conn.createStatement();
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					annotation a=new annotation(source, id, r2.getString(1), null);
					a.print();
					annotationList.add(a);
				}
				r2.close();
				s2.close();
			}
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return annotationList;
	}

	public ArrayList<annotation> getNode_allAnnotationOfNode(String node) {
		ArrayList<annotation> annotationList=new ArrayList<annotation>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			int nodeID=getNodeDBID(node);

			sqlStatement="SELECT SOURCE_NAME, SOURCE_ID, SOURCE_TYPE FROM NODE_ANNOTATION WHERE NODE_ID='"+nodeID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				String source=r1.getString(1);
				String id=r1.getString(2);
				String type=r1.getString(3);

				System.out.println("source:"+source+" id:"+id);

				sqlStatement="SELECT SOURCE_URL FROM SOURCE WHERE SOURCE_NAME='"+source+"';";
				Statement s2=conn.createStatement();
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					annotation a=new annotation(source, id, r2.getString(1), type);
					a.print();
					annotationList.add(a);
				}
				r2.close();
				s2.close();
			}
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return annotationList;
	}

	public ArrayList<String> getPathway_pathwayNameList() {
		ArrayList<String> list=new ArrayList<String>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			sqlStatement="SELECT PATHWAY_NAME FROM PATHWAY ORDER BY PATHWAY_NAME;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getPathway_getNodeInPathway(String pathwayName) {
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement(), s2 = conn.createStatement();
			String sqlStatement;
			String pathwayId;
			sqlStatement="SELECT PATHWAY_ID FROM PATHWAY WHERE PATHWAY_NAME='"+pathwayName+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
			{
				pathwayId=r1.getString(1);
				sqlStatement="SELECT B.SBML_NODE_NAME FROM CURR_NETWORK_NODE AS B WHERE B.NODE_ID IN (SELECT NODE_ID FROM NODE_ANNOTATION WHERE SOURCE_ID='"+pathwayId+"');";
				ResultSet r2=s2.executeQuery(sqlStatement);
				while(r2.next())
					list.add(r2.getString(1));
			}
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> getPathway_pathwayNameListHavingNodes(ArrayList<String> nodeList) {
		ArrayList<String> list=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement="SELECT DISTINCT SOURCE_ID FROM NODE_ANNOTATION WHERE SOURCE_NAME='KEGG pathway' AND (";
			for(int i=0; i<nodeList.size(); i++)
			{
				sqlStatement=sqlStatement+"NODE_ID='"+getNodeDBID(nodeList.get(i))+"'";
				if(i<nodeList.size()-1)
					sqlStatement=sqlStatement+" OR ";
				else
					sqlStatement=sqlStatement+");";
			}
			ResultSet r1=s1.executeQuery(sqlStatement);
			ArrayList<String> pathwayId=new ArrayList<String>();
			while(r1.next())
				pathwayId.add(r1.getString(1));
			sqlStatement="SELECT DISTINCT PATHWAY_NAME FROM PATHWAY WHERE ";
			for(int i=0; i<pathwayId.size(); i++)
			{
				sqlStatement=sqlStatement+"PATHWAY_ID='"+pathwayId.get(i)+"'";
				if(i<pathwayId.size()-1)
					sqlStatement=sqlStatement+" OR ";
				else
					sqlStatement=sqlStatement+" ORDER BY PATHWAY_NAME ASC;";
			}
			System.out.println(sqlStatement);
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				list.add(r1.getString(1));
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<rate> getKinetics_rateAnnotation() {
		String sqlStatement=null;
		Statement s1=null, s2=null;
		ResultSet r1=null, r2=null;

		String organism, cellLine, source, parameter, value, url;
		ArrayList<rate> rateList=new ArrayList<rate>();

		try {
			s1 = conn.createStatement();
			sqlStatement="SELECT ORGANISM, CELL_LINE, SOURCE, PARAMETER, VALUE FROM KINETICS_RATE_ANNOTATION;";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				organism=r1.getString(1);
				cellLine=r1.getString(2);
				source=r1.getString(3);
				parameter=r1.getString(4);
				value=r1.getString(5);
				sqlStatement="SELECT SOURCE_URL FROM SOURCE WHERE SOURCE_NAME='"+source+"';";
				s2 = conn.createStatement();
				r2=s2.executeQuery(sqlStatement);
				if(r2.next())
					url=r2.getString(1);
				else
				{
					System.err.println("postgreSQL.java [getKinetics_rateAnnotation]: URL is null!");
					url=null;
				}
				rateList.add(new rate(organism, cellLine, source, url, parameter, value));	
				s2.close();
				r2.close();
			}
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return rateList;
	}

	//get edges that are annotated with kinetics information
	public ArrayList<edge> getKinetics_edgeList() {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		String sqlStatement=null;
		Statement s1=null;
		ResultSet r1=null;

		//get edges
		try {
			s1 = conn.createStatement();
			sqlStatement="SELECT SOURCE_NODE_ID, SOURCE_NODE_NAME, TARGET_NODE_ID, TARGET_NODE_NAME, EDGE_TYPE FROM KINETICS_KINETICS;";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				edge e=new edge(r1.getString(1), r1.getString(2), r1.getString(3), r1.getString(4), r1.getString(5));
				edgeList.add(e);
			}
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return edgeList;
	}

	public ArrayList<String> getKinetics_kineticList(String sourceNode, String targetNode, String edgeType) {
		String sqlStatement=null;
		Statement s1=null, s2=null;
		ResultSet r1=null, r2=null;

		int sourceDBID, targetDBID, kineticsID;
		String sourceName, targetName, rateIDList="";
		ArrayList<String> kineticsList=new ArrayList<String>();

		//get nodeName
		sourceDBID=getNodeDBID(sourceNode);
		targetDBID=getNodeDBID(targetNode);
		sourceName=getNodeName(sourceDBID);
		targetName=getNodeName(targetDBID);

		//get kinetics_id
		try {
			s1 = conn.createStatement();
			sqlStatement="SELECT KINETICS_ID FROM KINETICS_KINETICS WHERE SOURCE_NODE_NAME='"+sourceName
					+ "' AND TARGET_NODE_NAME='"+targetName+"' AND EDGE_TYPE='"+edgeType+"';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				rateIDList="";
				kineticsID=r1.getInt(1);
				sqlStatement="SELECT RATE_ID FROM KINETICS_RATE WHERE KINETICS_ID='"+kineticsID+"';";
				s2 = conn.createStatement();
				r2=s2.executeQuery(sqlStatement);
				while(r2.next())
					rateIDList=rateIDList+r2.getInt(1)+",";
				kineticsList.add(rateIDList);
				s2.close();
				r2.close();
			}
			s1.close();
			r1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return kineticsList;
	}

	public ArrayList<String> getFeaturesWithThreshold(String pValueThreshold, String rocThreshold) {
		ArrayList<String> featureList=new ArrayList<String>();
		String sqlStatement=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();

			sqlStatement="SELECT A.FEATURE_NAME FROM (SELECT FEATURE_NAME FROM CURR_NETWORK_FEATURE WHERE (CAST (WILCOXON_PVALUE AS numeric) <= "
					+ pValueThreshold+")) AS A INNER JOIN (SELECT FEATURE_NAME FROM CURR_NETWORK_FEATURE WHERE (CAST (ROC_AUC AS numeric) >= "
					+ rocThreshold+")) AS B ON A.FEATURE_NAME=B.FEATURE_NAME;";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
				featureList.add(result.getString(1));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return featureList;
	}

	public void update_rocValue(String feature, String value) {
		Statement statement=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			int featureID=0;
			String sqlStatement=null;

			//get featureID
			result = statement.executeQuery("SELECT FEATURE_ID FROM CURR_NETWORK_FEATURE WHERE FEATURE_NAME='"+feature+"';");
			if(result.next())
			{
				featureID=result.getInt(1);

				sqlStatement="UPDATE CURR_NETWORK_FEATURE SET ROC_AUC='"+value+"' WHERE FEATURE_ID='"+featureID+"';";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> get_multipleFeatureRanks(String sbml_node_id, String sbml_node_name, ArrayList<String> featureList) {
		ArrayList<String> list=new ArrayList<String>();
		int nodeID=0;
		String sqlStatement=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();

			//get nodeID
			result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="SELECT "+getMultipleFeatureString(featureList, "_rank")+" FROM CURR_NETWORK_NODE_RANKS WHERE NODE_ID='"+nodeID+"';";
				if(featureList.size()>0)
				{
					result=statement.executeQuery(sqlStatement);
					if(result.next())
					{
						for(int i=0; i<featureList.size(); i++)
							list.add(result.getString(i+1));
					}
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> get_multiplePathwayFeatureRanks(String sbml_node_id, String sbml_node_name, ArrayList<String> featureList) {
		ArrayList<String> list=new ArrayList<String>();
		int nodeID=0;
		String sqlStatement=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();

			//get nodeID
			result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="SELECT "+getMultipleFeatureString(featureList, "_rank")+" FROM CURR_PATHWAY_NODE_RANKS WHERE NODE_ID='"+nodeID+"';";
				if(featureList.size()>0)
				{
					result=statement.executeQuery(sqlStatement);
					if(result.next())
					{
						for(int i=0; i<featureList.size(); i++)
							list.add(result.getString(i+1));
					}
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public String get_featureRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT "+feature+"_RANK FROM CURR_NETWORK_NODE_RANKS WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_pathwayFeatureRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE_RANKS WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT "+feature+"_RANK FROM CURR_PATHWAY_NODE_RANKS WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	private String getMultipleFeatureString(ArrayList<String> featureList, String suffix)
	{
		String s="";
		for(int i=0; i<featureList.size(); i++)
		{
			s=s+featureList.get(i)+suffix;
			if(i<featureList.size()-1)
				s=s+", ";
		}
		return s;
	}

	public ArrayList<String> get_multipleFeatures(String sbml_node_id, String sbml_node_name, ArrayList<String> featureList) {
		ArrayList<String> list=new ArrayList<String>();
		int nodeID=0;
		String sqlStatement=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			//get nodeID
			result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="SELECT "+getMultipleFeatureString(featureList, "")+" FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
				if(featureList.size()>0)
				{
					result=statement.executeQuery(sqlStatement);
					if(result.next())
					{
						for(int i=0; i<featureList.size(); i++)
							list.add(result.getString(i+1));
					}
				}
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public ArrayList<String> get_multiplePathwayFeatures(String sbml_node_id, String sbml_node_name, ArrayList<String> featureList) {
		ArrayList<String> list=new ArrayList<String>();
		int nodeID=0;
		String sqlStatement=null;
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			//get nodeID
			result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				sqlStatement="SELECT "+getMultipleFeatureString(featureList, "")+" FROM CURR_PATHWAY_NODE WHERE NODE_ID='"+nodeID+"';";
				if(featureList.size()>0)
				{
					result=statement.executeQuery(sqlStatement);
					if(result.next())
					{
						for(int i=0; i<featureList.size(); i++)
							list.add(result.getString(i+1));
					}
				}
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public String get_feature(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT "+feature+" FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_pathwayFeature(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT "+feature+" FROM CURR_PATHWAY_NODE WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_featureDesMaxRank(String sbml_node_id, String sbml_node_name, String feature) {
		String value=null;
		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT MAX(DENSE_RANK) FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" DESC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			if(result.next())
				value=result.getString(1);
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public ArrayList<String[]> get_featureDesRankAll(String feature) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();

		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME, DENSE_RANK FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" DESC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String[] val=new String[2];
				val[0]=result.getString(1);
				val[1]=result.getString(2);
				rankedList.add(val);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return rankedList;
	}

	public ArrayList<String[]> get_pathwayFeatureDesRankAll(String feature) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();

		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME, DENSE_RANK FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" DESC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String[] val=new String[2];
				val[0]=result.getString(1);
				val[1]=result.getString(2);
				rankedList.add(val);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return rankedList;
	}

	public int get_featureAscMaxRank(String feature) {
		int maxRank=0;
		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT MAX(DENSE_RANK) FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxRank=result.getInt(1);
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return maxRank;
	}

	public ArrayList<String[]> get_featureAscRankAll(String feature) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();

		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME, DENSE_RANK FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String[] val=new String[2];
				val[0]=result.getString(1);
				val[1]=result.getString(2);
				rankedList.add(val);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return rankedList;
	}

	public ArrayList<String[]> get_pathwayFeatureAscRankAll(String feature) {
		ArrayList<String[]> rankedList=new ArrayList<String[]>();

		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT SBML_NODE_NAME, DENSE_RANK FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" ASC) FROM CURR_PATHWAY_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String[] val=new String[2];
				val[0]=result.getString(1);
				val[1]=result.getString(2);
				rankedList.add(val);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return rankedList;
	}

	public int get_featureDesMaxRank(String feature) {
		int maxRank=0;
		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT MAX(DENSE_RANK) FROM (SELECT "+feature+", SBML_NODE_NAME, NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" DESC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxRank=result.getInt(1);
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return maxRank;
	}

	public String get_featureDesRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT DENSE_RANK FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
						+" DESC) FROM CURR_NETWORK_NODE) AS A WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_pathwayFeatureDesRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT DENSE_RANK FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
						+" DESC) FROM CURR_PATHWAY_NODE) AS A WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_featureAscMaxRank(String sbml_node_id, String sbml_node_name, String feature) {
		String value=null;
		try {
			Statement statement = conn.createStatement();
			String sqlStatement="SELECT MAX(DENSE_RANK) FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
					+" ASC) FROM CURR_NETWORK_NODE) AS A;";
			ResultSet result=statement.executeQuery(sqlStatement);
			if(result.next())
				value=result.getString(1);
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_featureAscRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT DENSE_RANK FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
						+" ASC) FROM CURR_NETWORK_NODE) AS A WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public String get_pathwayFeatureAscRank(String sbml_node_id, String sbml_node_name, String feature) {
		int nodeID=0;
		String value=null;
		try {
			Statement statement = conn.createStatement();
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT NODE_ID FROM CURR_PATHWAY_NODE WHERE SBML_NODE_ID='"+sbml_node_id+"' AND SBML_NODE_NAME='"+sbml_node_name+"';");
			if(result.next())
			{
				nodeID=result.getInt(1);
				String sqlStatement="SELECT DENSE_RANK FROM (SELECT "+feature+", NODE_ID, DENSE_RANK() OVER (ORDER BY "+feature
						+" ASC) FROM CURR_PATHWAY_NODE) AS A WHERE NODE_ID='"+nodeID+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					value=result.getString(1);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return value;
	}

	public int getNodeDBID(String node) {
		int nodeID=-1;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+node+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(!r1.next())
			{
				sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_NAME='"+node+"';";
				Statement s2=conn.createStatement();
				ResultSet r2=s2.executeQuery(sqlStatement);

				if(!r2.next())
				{
					System.out.println("postgreSQL.java [getNetworkEdge_reactionList] ERROR: can't find node_ID for "+node);
					return nodeID;
				}
				else
					nodeID=r2.getInt(1);

				r2.close();
				s2.close();
			}
			else
				nodeID=r1.getInt(1);
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeID;
	}

	public String getNodeName(int nodeDBID) {
		String nodeName=null;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				nodeName=r1.getString(1);
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeName;
	}

	public String getNodeID(int nodeDBID) {
		String nodeName=null;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeDBID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				nodeName=r1.getString(1);
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeName;
	}


	public String getSourceURL(String sourceName) {
		String url=null;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SOURCE_URL FROM SOURCE WHERE SOURCE_NAME='"+sourceName+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				url=r1.getString(1);

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return url;
	}

	public boolean checkNodeNameExists(String name) {
		boolean EXIST=false;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_NAME='"+name+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				EXIST=true;

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return EXIST;
	}

	public boolean checkNodeIDExists(String id) {
		boolean EXIST=false;

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+id+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				EXIST=true;

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return EXIST;
	}

	public String getSBMLNodeID(String node) {
		String sbmlNodeID=null;
		int nodeID=getNodeDBID(node);

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				sbmlNodeID=r1.getString(1);

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return sbmlNodeID;
	}

	public String getSBMLNodeName(String node) {
		String sbmlNodeName=null;
		int nodeID=getNodeDBID(node);

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+nodeID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
				sbmlNodeName=r1.getString(1);

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return sbmlNodeName;
	}

	public ArrayList<String> getHallmark_characterizedHallmarkList() {
		ArrayList<String> characterizedHallmarkList=new ArrayList<String>();
		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT HALLMARK FROM CURR_NETWORK_HALLMARK_CHARACTERIZATION;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				characterizedHallmarkList.add(r1.getString(1));

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return characterizedHallmarkList;
	}

	public allHallmark getHallmark_hallmark() {
		allHallmark hallmarkList=new allHallmark();

		try {
			Statement s1 = conn.createStatement();
			ResultSet r1;
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.PROLIFERATION FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.PROLIFERATION<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getProliferation().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.GROWTH_REPRESSOR FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.GROWTH_REPRESSOR<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getGrowthRepressor().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.APOPTOSIS FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.APOPTOSIS<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getApoptosis().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.REPLICATIVE_IMMORTALITY FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.REPLICATIVE_IMMORTALITY<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getReplicativeImmortality().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.ANGIOGENESIS FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.ANGIOGENESIS<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getAngiogenesis().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.METASTASIS FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.METASTASIS<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getMetastasis().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.METABOLISM FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.METABOLISM<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getMetabolism().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.IMMUNE_DESTRUCTION FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.IMMUNE_DESTRUCTION<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getImmuneDestruction().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.GENOME_INSTABILITY FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.GENOME_INSTABILITY<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getGenomeInstability().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			sqlStatement="SELECT A.SBML_NODE_ID, A.SBML_NODE_NAME, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A "
					+ "INNER JOIN HALLMARK_HALLMARK AS B ON A.NODE_ID=B.NODE_ID AND B.TUMOR_PROMOTING_INFLAMMATION<>'0';";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
				hallmarkList.getTumorPromotingInflammation().add(r1.getString(1), r1.getString(2), r1.getInt(3));

			r1.close();
			s1.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return hallmarkList;
	}

	public ArrayList<Integer> getHallmark_hallmarkOfNode(String node) {
		ArrayList<Integer> hallmarkList=new ArrayList<Integer>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			int nodeID=getNodeDBID(node);

			sqlStatement="SELECT PROLIFERATION, GROWTH_REPRESSOR, APOPTOSIS, REPLICATIVE_IMMORTALITY, ANGIOGENESIS, "
					+ "METASTASIS, METABOLISM, IMMUNE_DESTRUCTION, GENOME_INSTABILITY, TUMOR_PROMOTING_INFLAMMATION FROM HALLMARK_HALLMARK WHERE NODE_ID='"+nodeID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			if(r1.next())
			{
				hallmarkList.add(r1.getInt(1));
				hallmarkList.add(r1.getInt(2));
				hallmarkList.add(r1.getInt(3));
				hallmarkList.add(r1.getInt(4));
				hallmarkList.add(r1.getInt(5));
				hallmarkList.add(r1.getInt(6));
				hallmarkList.add(r1.getInt(7));
				hallmarkList.add(r1.getInt(8));
				hallmarkList.add(r1.getInt(9));
				hallmarkList.add(r1.getInt(10));
			}
			r1.close();
			s1.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return hallmarkList;
	}

	public ArrayList<String> getHallmark_nodeNameCombinedListOfSelectedHallmarks(ArrayList<String> hallmark) {
		ArrayList<String> nodeList=new ArrayList<String>();

		try {
			ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
			String sqlStatement="";
			if(hallmark.size()>0)
			{	
				Statement s1 = conn.createStatement();
				ResultSet r1;
				//get nodeDBID
				if(hallmark.size()==1)
					sqlStatement="SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmark.get(0)+"<>'0';";
				else
				{
					for(int i=0; i<hallmark.size(); i++)
					{
						sqlStatement=sqlStatement+"(SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmark.get(i)+"<>'0')";
						if(i<hallmark.size()-1)
							sqlStatement=sqlStatement+" UNION ";
						else
							sqlStatement=sqlStatement+";";
					}
				}
				System.out.println(sqlStatement);
				r1=s1.executeQuery(sqlStatement);
				while(r1.next())
					nodeIdList.add(r1.getInt(1));
				//get nodeName
				if(nodeIdList.size()>0)
				{
					sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE ";
					for(int i=0; i<nodeIdList.size(); i++)
					{
						sqlStatement=sqlStatement+"NODE_ID='"+nodeIdList.get(i)+"'";
						if(i<nodeIdList.size()-1)
							sqlStatement=sqlStatement+" OR ";
						else
							sqlStatement=sqlStatement+";";
					}
					System.out.println(sqlStatement);
					r1=s1.executeQuery(sqlStatement);
					while(r1.next())
						nodeList.add(r1.getString(1));
				}
				r1.close();
				s1.close();
			}
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeList;
	}

	public ArrayList<ArrayList<String>> getHallmark_nodeNameIndividualListOfSelectedHallmarks(ArrayList<String> hallmark) {
		ArrayList<ArrayList<String>> list=new ArrayList<ArrayList<String>>();

		try {
			String sqlStatement="";
			if(hallmark.size()>0)
			{	
				//get nodeDBID
				for(int i=0; i<hallmark.size(); i++)
				{
					Statement s1 = conn.createStatement();
					sqlStatement="SELECT NODE_ID FROM HALLMARK_HALLMARK WHERE "+hallmark.get(i)+"<>'0';";
					ResultSet r1=s1.executeQuery(sqlStatement);
					ArrayList<Integer> nodeIdList=new ArrayList<Integer>();
					while(r1.next())
						nodeIdList.add(r1.getInt(1));
					//get nodeName
					if(nodeIdList.size()>0)
					{
						sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE ";
						for(int j=0; j<nodeIdList.size(); j++)
						{
							sqlStatement=sqlStatement+"NODE_ID='"+nodeIdList.get(j)+"'";
							if(j<nodeIdList.size()-1)
								sqlStatement=sqlStatement+" OR ";
							else
								sqlStatement=sqlStatement+";";
						}
						//System.out.println(sqlStatement);
						r1=s1.executeQuery(sqlStatement);
						ArrayList<String> nodeName=new ArrayList<String>();
						while(r1.next())
							nodeName.add(r1.getString(1));
						list.add(nodeName);
					}
					r1.close();
					s1.close();
				}
			}
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return list;
	}

	public ArrayList<Integer> getHallmark_numNodeOfAllSelectedHallmark(ArrayList<String> hallmarkList, ArrayList<String> existentNode) {
		ArrayList<Integer> numlist=new ArrayList<Integer>();

		try {
			String sqlStatement;
			String existentNodeStr="";

			for(int i=0; i<existentNode.size(); i++)
			{
				existentNodeStr=existentNodeStr+"'"+existentNode.get(i)+"'";
				if(i<existentNode.size()-1)
					existentNodeStr=existentNodeStr+", ";
			}

			for(int i=0; i<hallmarkList.size(); i++)
			{
				Statement s1 = conn.createStatement();
				sqlStatement="SELECT COUNT(*) FROM HALLMARK_HALLMARK LEFT JOIN CURR_NETWORK_NODE " +
						"ON CURR_NETWORK_NODE.NODE_ID=HALLMARK_HALLMARK.NODE_ID	WHERE CURR_NETWORK_NODE.SBML_NODE_NAME IN ("+existentNodeStr+") AND " +
						"(HALLMARK_HALLMARK."+hallmarkList.get(i)+"='1');";
				ResultSet r1=s1.executeQuery(sqlStatement);
				while(r1.next())
					numlist.add(r1.getInt(1));
				r1.close();
				s1.close();
			}
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return numlist;
	}

	public ArrayList<ArrayList<String>> getHallmark_nodeListOfAllSelectedHallmark(ArrayList<String> hallmarkList, ArrayList<String> existentNode) {
		ArrayList<ArrayList<String>> list=new ArrayList<ArrayList<String>>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			String hallmarkTableStr="";
			String existentNodeStr="";
			String hallmarkConditionStr="";

			for(int i=0; i<hallmarkList.size(); i++)
			{
				hallmarkTableStr=hallmarkTableStr+"HALLMARK_HALLMARK."+hallmarkList.get(i);
				hallmarkConditionStr=hallmarkConditionStr+"HALLMARK_HALLMARK."+hallmarkList.get(i)+"='1'";
				if(i<hallmarkList.size()-1)
				{
					hallmarkTableStr=hallmarkTableStr+", ";
					hallmarkConditionStr=hallmarkConditionStr+" OR ";
				}
			}
			for(int i=0; i<existentNode.size(); i++)
			{
				existentNodeStr=existentNodeStr+"'"+existentNode.get(i)+"'";
				if(i<existentNode.size()-1)
					existentNodeStr=existentNodeStr+", ";
			}

			sqlStatement="SELECT CURR_NETWORK_NODE.SBML_NODE_NAME, "+hallmarkTableStr+" FROM HALLMARK_HALLMARK LEFT JOIN CURR_NETWORK_NODE " +
					"ON CURR_NETWORK_NODE.NODE_ID=HALLMARK_HALLMARK.NODE_ID	WHERE CURR_NETWORK_NODE.SBML_NODE_NAME IN ("+existentNodeStr+") AND " +
					"("+hallmarkConditionStr+");";
			System.out.println("getHallmark_nodeListOfAllSelectedHallmark: sqlStatement="+sqlStatement);
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				ArrayList<String> element=new ArrayList<String>();
				element.add(r1.getString(1));//nodeName
				for(int i=0; i<hallmarkList.size(); i++)
					element.add(r1.getString(i+2));//get hallmark 
				list.add(element);
			}
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return list;
	}

	public ArrayList<annotation> getHallmark_annotationOfNode(String node) {
		ArrayList<annotation> annotationList=new ArrayList<annotation>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			int nodeID=getNodeDBID(node);

			sqlStatement="SELECT ANNOTATION_TYPE, ANNOTATION_ID FROM HALLMARK_ANNOTATION WHERE NODE_ID='"+nodeID+"';";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				String source=r1.getString(1);
				String id=r1.getString(2);

				System.out.println("source:"+source+" id:"+id);

				sqlStatement="SELECT SOURCE_URL FROM SOURCE WHERE SOURCE_NAME='"+source+"';";
				Statement s2=conn.createStatement();
				ResultSet r2=s2.executeQuery(sqlStatement);
				if(r2.next())
				{
					annotation a=new annotation(source, id, r2.getString(1), null);
					a.print();
					annotationList.add(a);
				}
				r2.close();
				s2.close();
			}
			r1.close();
			s1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return annotationList;
	}

	public ArrayList<edge> getNetworkEdge_reactionList(String node) {
		ArrayList<edge> reactionList=new ArrayList<edge>();

		try {
			Statement s1 = conn.createStatement();
			String sqlStatement;
			int nodeID=getNodeDBID(node);
			String sbml_node_id, sbml_node_name;

			//find nodeID
			sbml_node_id=getSBMLNodeID(node);
			sbml_node_name=getSBMLNodeName(node);

			//node is either a source or a target
			sqlStatement="SELECT B.SBML_NODE_ID, B.SBML_NODE_NAME, A.EDGE_TYPE FROM CURR_NETWORK_EDGE AS A "+
					"INNER JOIN CURR_NETWORK_NODE AS B ON A.SOURCE_NODE_ID='"+nodeID+"' AND A.TARGET_NODE_ID=B.NODE_ID;";
			ResultSet r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				edge e=new edge(sbml_node_id, sbml_node_name, r1.getString(1), r1.getString(2), r1.getString(3));
				reactionList.add(e);
			}

			sqlStatement="SELECT B.SBML_NODE_ID, B.SBML_NODE_NAME, A.EDGE_TYPE FROM CURR_NETWORK_EDGE AS A "+
					"INNER JOIN CURR_NETWORK_NODE AS B ON A.TARGET_NODE_ID='"+nodeID+"' AND A.SOURCE_NODE_ID=B.NODE_ID;";
			r1=s1.executeQuery(sqlStatement);
			while(r1.next())
			{
				edge e=new edge(r1.getString(1), r1.getString(2), sbml_node_id, sbml_node_name, r1.getString(3));
				reactionList.add(e);
			}

			r1.close();
			s1.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return reactionList;
	}

	public ArrayList<String[]> getNetworkNode_nodeList() {
		ArrayList<String[]> nodeList=new ArrayList<String[]>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE ORDER BY SBML_NODE_NAME ASC;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				int col=2;
				String[] node=new String[col];
				for(int i=0; i<col; i++)
					node[i]=result.getString(i+1);
				nodeList.add(node);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeList;
	}

	public ArrayList<String> getNetworkNode_nodeIDList() {
		ArrayList<String> nodeIDList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE ORDER BY SBML_NODE_NAME ASC;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
				nodeIDList.add(result.getString(1));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDList;
	}

	public ArrayList<String> getNetworkNode_nodeNameList() {
		ArrayList<String> nodeNameList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE ORDER BY SBML_NODE_NAME ASC;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
				nodeNameList.add(result.getString(2));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeNameList;
	}

	public ArrayList<String> getNetworkViewNode_foldChange_viewList() {
		ArrayList<String> viewList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT VIEW_NAME FROM NETWORK_VIEW_NODE_FOLDCHANGE;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(viewList.contains(result.getString(1))==false)
					viewList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return viewList;
	}

	public ArrayList<String> getNetworkViewNode_foldChange_nodeIDList(String view) {
		ArrayList<String> nodeIDList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NODE_ID FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"';";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeIDList.contains(result.getString(1))==false)
					nodeIDList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDList;
	}

	public Double getNetworkViewNode_foldChange_foldChangeOfNode(String view, String node) {
		Statement statement=null;
		ResultSet result=null;
		Double foldChange=(double) 0;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			String nodeEntrez=getNodeID(getNodeDBID(node));
			sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND NODE_ID='"+nodeEntrez+"';";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				String value=result.getString(1);
				if(value.length()>0)
					foldChange=Double.valueOf(value);
				else
					foldChange=(double)0;
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return foldChange;
	}

	public ArrayList<Double> getNetworkViewNode_foldChange_foldChangeList(String view, ArrayList<String> nodeList) {
		ArrayList<Double> foldChangeList=new ArrayList<Double>();
		for(int i=0; i<nodeList.size(); i++)
		{
			Double fc=getNetworkViewNode_foldChange_foldChangeOfNode(view, nodeList.get(i));
			foldChangeList.add(fc);
		}
		return foldChangeList;
	}

	public Double getNetworkViewNode_mutation_percentageOfNode(String view, String node) {
		Statement statement=null;
		ResultSet result=null;
		Double percentage=(double) 0;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			String nodeEntrez=getNodeID(getNodeDBID(node));
			sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND NODE_ID='"+nodeEntrez+"';";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				String value=result.getString(1);
				if(value.length()>0)
					percentage=Double.valueOf(value);
				else
					percentage=(double)0;
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return percentage;
	}

	public ArrayList<Double> getNetworkViewNode_mutation_PercentageList(String view, ArrayList<String> nodeList) {
		ArrayList<Double> percentageList=new ArrayList<Double>();
		for(int i=0; i<nodeList.size(); i++)
		{
			Double fc=getNetworkViewNode_mutation_percentageOfNode(view, nodeList.get(i));
			percentageList.add(fc);
		}
		return percentageList;
	}

	public ArrayList<Double> getNetworkViewNode_foldChange_NonZerofoldChangeList(String view, ArrayList<String> nodeList) {
		ArrayList<Double> foldChangeList=new ArrayList<Double>();
		for(int i=0; i<nodeList.size(); i++)
		{
			Double fc=getNetworkViewNode_foldChange_foldChangeOfNode(view, nodeList.get(i));
			if(fc!=0)
				foldChangeList.add(fc);
		}
		return foldChangeList;
	}

	public ArrayList<String> getNetworkViewNode_foldChange_nodeNameList(String view) {
		ArrayList<String> nodeNameList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_NAME FROM CURR_NETWORK_NODE AS A INNER JOIN NETWORK_VIEW_NODE_FOLDCHANGE AS B ON A.SBML_NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeNameList.contains(result.getString(1))==false)
					nodeNameList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeNameList;
	}

	public ArrayList<String> getNetworkViewNode_mutation_nodeNameList(String view) {
		ArrayList<String> nodeNameList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_NAME FROM CURR_NETWORK_NODE AS A INNER JOIN NETWORK_VIEW_NODE_MUTATION AS B ON A.SBML_NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeNameList.contains(result.getString(1))==false)
					nodeNameList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeNameList;
	}

	public ArrayList<String> getNetworkViewNode_foldChange_networkViewExtension(ArrayList<String> originalNodeList) {
		ArrayList<Integer> originalNodeId=new ArrayList<Integer>();
		ArrayList<String> newNodeList=new ArrayList<String>();
		ArrayList<Integer> potentialSource=new ArrayList<Integer>();
		ArrayList<Integer> potentialTarget=new ArrayList<Integer>();
		ArrayList<Integer> oneHopNode=new ArrayList<Integer>();
		//originalNodeList contains the sbml_node_id 
		String originalNodeIDListString="", oneHopString="";

		Statement statement=null;
		ResultSet result=null;

		//System.out.println("***************** originalNodeList:"+originalNodeList.toString());

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<originalNodeList.size(); i++)
			{
				if(i>0)
					originalNodeIDListString=originalNodeIDListString+",";
				originalNodeIDListString=originalNodeIDListString+"'"+originalNodeList.get(i)+"'";
			}
			//obtain the postgreSQL node id of originalNodeList
			sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID IN ("+originalNodeIDListString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				if(originalNodeId.contains(result.getInt(1))==false)
					originalNodeId.add(result.getInt(1));
			}
			//System.out.println("[getNetworkViewNode_foldChange_networkViewExtension] originalNodeId:"+originalNodeId.toString());


			//obtain the list of postgreSQL node id of target nodes where source node are in originalNodeIDListString
			sqlStatement="SELECT TARGET_NODE_ID FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID IN ("+originalNodeIDListString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				if(potentialTarget.contains(result.getInt(1))==false)
					potentialTarget.add(result.getInt(1));
			}
			//System.out.println("[getNetworkViewNode_foldChange_networkViewExtension] potentialTarget:"+potentialTarget.toString());


			//obtain the list of postgreSQL node id of source nodes where target node are in originalNodeIDListString
			sqlStatement="SELECT SOURCE_NODE_ID FROM CURR_NETWORK_EDGE WHERE TARGET_NODE_ID IN ("+originalNodeIDListString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				if(potentialSource.contains(result.getInt(1))==false)
					potentialSource.add(result.getInt(1));
			}
			//System.out.println("[getNetworkViewNode_foldChange_networkViewExtension] potentialSource:"+potentialSource.toString());

			//obtain list of postgreSQL node id of one hop node (those in potentialSource and in potentialTarget) 
			for(int i=0; i<potentialTarget.size(); i++)
			{
				if(potentialSource.contains(potentialTarget.get(i))==true && oneHopNode.contains(potentialTarget.get(i))==false)
					oneHopNode.add(potentialTarget.get(i)); //postgreSQL NODE_ID of one hop node
			}
			//System.out.println("[getNetworkViewNode_foldChange_networkViewExtension] oneHopNode:"+oneHopNode.toString());


			//obtain list of sbml_node_id of one hop node
			for(int i=0; i<oneHopNode.size(); i++)
			{
				if(i>0)
					oneHopString=oneHopString+",";
				oneHopString=oneHopString+oneHopNode.get(i);
			}
			sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE NODE_ID IN ("+oneHopString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				if(newNodeList.contains(result.getString(1))==false)
					newNodeList.add(result.getString(1));
			}
			//System.out.println("[getNetworkViewNode_foldChange_networkViewExtension] newNodeList:"+newNodeList.toString());

			//add in those originalNodeList's nodes that are not in the one hop node list
			for(int i=0; i<originalNodeList.size(); i++)
			{
				if(newNodeList.contains(originalNodeList.get(i))==false)
					newNodeList.add(originalNodeList.get(i));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return newNodeList;
	}

	private ArrayList<Integer> createReferenceHallmarkArray(ArrayList<String> hallmarkList)
	{
		ArrayList<Integer> refHallmark=new ArrayList<Integer>();

		if(hallmarkList.contains(staticString.getGUIProliferation())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIGrowthRepressor())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIApoptosis())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIReplicativeImmortality())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIAngiogenesis())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIMetastasis())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIMetabolism())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIImmuneDestruction())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUIGenomeInstability())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		if(hallmarkList.contains(staticString.getGUITumorPromotingInflammation())==true)
			refHallmark.add(1);
		else
			refHallmark.add(0);

		return refHallmark;
	}

	public diseaseNode getNetworkViewNode_getDiseaseNodeFromHallmark(String view, ArrayList<String> hallmarkList, Double hallmarkThreshold){
		diseaseNode diseaseNodeList=new diseaseNode();

		System.out.println("[getNetworkViewNode_getDiseaseNodeFromHallmark] hallmarkList:"+hallmarkList.toString());
		Statement statement=null, statement1=null;
		ResultSet result=null, result1=null;

		ArrayList<Integer> referenceHallmark=new ArrayList<Integer>();
		referenceHallmark=createReferenceHallmarkArray(hallmarkList);
		System.out.println("referenceHallmark:"+referenceHallmark.toString());
		try {
			statement = conn.createStatement();
			statement1 = conn.createStatement();
			String sqlStatement;
			int numA=0, numB=0, numAIntersectB;

			//obtain the hallmarks of nodes in that view and store if jaccard>=0.8 
			sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);
			for(int i=0; i<referenceHallmark.size(); i++)
			{
				if(referenceHallmark.get(i)>1)
					numA=numA+referenceHallmark.get(i);
			}

			while(result.next())
			{
				String nodeName=result.getString(1);
				String nodeId=result.getString(2);
				ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
				for(int i=3; i<13; i++)
					nodeHallmark.add(result.getInt(i));
				//compute jaccard similarity
				Double jaccard, numerator, denominator;
				numB=0;
				numAIntersectB=0;
				for(int i=0; i<nodeHallmark.size(); i++)
				{
					if(nodeHallmark.get(i)==1)
					{
						if(referenceHallmark.get(i)>0)
						{
							numAIntersectB=numAIntersectB+referenceHallmark.get(i);
							numB=numB+referenceHallmark.get(i);
						}
						else
							numB=numB+1;
					}
					//if(nodeHallmark.get(i)==referenceHallmark.get(i))
					//	numAIntersectB++;
				}
				numerator=(double) numAIntersectB;
				denominator=(double) (numA+numB-numAIntersectB);
				if(denominator==0)//an empty set compared to empty set
					jaccard=(double)1;
				else
					jaccard=numerator/denominator;
				//System.out.println("numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
				if(jaccard>=hallmarkThreshold)
				{
					double foldChange, mutation;
					sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND " +
							"NODE_ID='"+nodeId+"';";
					result1=statement1.executeQuery(sqlStatement);
					if(result1.next())
						foldChange=Double.valueOf(result1.getString(1));
					else
						foldChange=Double.valueOf(1);

					sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND " +
							"NODE_ID='"+nodeId+"';";
					result1=statement1.executeQuery(sqlStatement);
					if(result1.next())
						mutation=Double.valueOf(result1.getString(1));
					else
						mutation=Double.valueOf(0);
					diseaseNodeList.add(nodeName, null, foldChange, mutation);

					System.out.println("jaccard:"+jaccard+" "+nodeName);
					result1.close();
				}
			}

			statement.close();
			statement1.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public diseaseNode getNetworkViewNode_getDiseaseNodeFromHallmarkAndRule(String view, boolean foldChangeRule, boolean mutationFreqRule, String mutationFreqOperator, double foldChangeValue, double mutationFreqValue, ArrayList<String> hallmarkList, Double hallmarkThreshold){
		diseaseNode diseaseNodeList=new diseaseNode();

		System.out.println("[getNetworkViewNode_getDiseaseNodeFromHallmarkAndRule] hallmarkList:"+hallmarkList.toString());
		Statement statement=null, statement1=null;
		ResultSet result=null, result1=null;

		ArrayList<Integer> referenceHallmark=new ArrayList<Integer>();
		referenceHallmark=createReferenceHallmarkArray(hallmarkList);
		System.out.println("referenceHallmark:"+referenceHallmark.toString());
		try {
			statement = conn.createStatement();
			statement1 = conn.createStatement();
			String sqlStatement;
			int numA=0, numB=0, numAIntersectB;

			//obtain the hallmarks of nodes in that view and store if jaccard>=0.8 
			sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);
			for(int i=0; i<referenceHallmark.size(); i++)
			{
				if(referenceHallmark.get(i)>1)
					numA=numA+referenceHallmark.get(i);
			}

			while(result.next())
			{
				String nodeName=result.getString(1);
				String nodeId=result.getString(2);
				ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
				for(int i=3; i<13; i++)
					nodeHallmark.add(result.getInt(i));
				//compute jaccard similarity
				Double jaccard, numerator, denominator;
				numB=0;
				numAIntersectB=0;
				for(int i=0; i<nodeHallmark.size(); i++)
				{
					//if(nodeHallmark.get(i)==referenceHallmark.get(i))
					//	numAIntersectB++;
					if(nodeHallmark.get(i)==1)
					{
						if(referenceHallmark.get(i)>0)
						{
							numAIntersectB=numAIntersectB+referenceHallmark.get(i);
							numB=numB+referenceHallmark.get(i);
						}
						else
							numB=numB+1;
					}
				}
				numerator=(double) numAIntersectB;
				denominator=(double) (numA+numB-numAIntersectB);
				if(denominator==0)//an empty set compared to empty set
					jaccard=(double)1;
				else
					jaccard=numerator/denominator;
				//System.out.println("numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
				if(jaccard>=hallmarkThreshold)
				{
					double foldChange, mutation;
					sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND " +
							"NODE_ID='"+nodeId+"';";
					result1=statement1.executeQuery(sqlStatement);
					if(result1.next())
						foldChange=Double.valueOf(result1.getString(1));
					else
						foldChange=Double.valueOf(0);

					sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND " +
							"NODE_ID='"+nodeId+"';";
					result1=statement1.executeQuery(sqlStatement);
					if(result1.next())
						mutation=Double.valueOf(result1.getString(1));
					else
						mutation=Double.valueOf(0);

					//single rule
					if(foldChangeRule==true && mutationFreqRule==false)
					{
						System.out.println("foldChange:"+foldChange+" foldChangeValue:"+foldChangeValue);
						if(Math.abs(foldChange)>=foldChangeValue)
							diseaseNodeList.add(nodeName, null, foldChange, mutation);
					}
					else if(foldChangeRule==false && mutationFreqRule==true)
					{
						System.out.println("mutation:"+mutation+" mutationFreqValue:"+mutationFreqValue);
						if(Math.abs(mutation)>=mutationFreqValue)
							diseaseNodeList.add(nodeName, null, foldChange, mutation);
					}
					else //double rules
					{
						System.out.println("foldChange:"+foldChange+" foldChangeValue:"+foldChangeValue);
						System.out.println("mutation:"+mutation+" mutationFreqValue:"+mutationFreqValue);
						//AND rule
						if(mutationFreqOperator.compareTo("AND")==0)
						{
							if(Math.abs(foldChange)>=foldChangeValue && Math.abs(mutation)>=mutationFreqValue)
								diseaseNodeList.add(nodeName, null, foldChange, mutation);
						}
						//OR rule
						if(mutationFreqOperator.compareTo("OR")==0)
						{
							if(Math.abs(foldChange)>=foldChangeValue || Math.abs(mutation)>=mutationFreqValue)
								diseaseNodeList.add(nodeName, null, foldChange, mutation);
						}
					}	

					System.out.println("jaccard:"+jaccard+" "+nodeName);
					result1.close();
				}
			}

			statement.close();
			statement1.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public diseaseNode getNetworkViewNode_getDiseaseNodeFromNodeListAndRule(String view, boolean foldChangeRule, boolean mutationFreqRule, String mutationFreqOperator, double foldChangeValue, double mutationFreqValue, ArrayList<String> nodeList){
		diseaseNode diseaseNodeList=new diseaseNode();

		System.out.println("[getNetworkViewNode_getDiseaseNodeFromNodeListAndRule] nodeList:"+nodeList.toString());

		ArrayList<String> nodeSBMLID=new ArrayList<String>();
		for(int i=0; i<nodeList.size(); i++)
		{
			String sbmlID=getNodeID(getNodeDBID(nodeList.get(i)));
			if(sbmlID!=null && nodeSBMLID.contains(sbmlID)==false)
				nodeSBMLID.add(sbmlID);
		}

		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<nodeSBMLID.size(); i++)
			{
				String sbmlNodeId=nodeSBMLID.get(i);
				String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
				double foldChange, mutation;

				sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND " +
						"NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					foldChange=Double.valueOf(result.getString(1));
				else
					foldChange=Double.valueOf(1);

				sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND " +
						"NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					mutation=Double.valueOf(result.getString(1));
				else
					mutation=Double.valueOf(0);

				System.out.println("nodeName:"+nodeName+" "+foldChange+" "+mutation);

				//single rule
				if(foldChangeRule==true && mutationFreqRule==false)
				{
					if(Math.abs(foldChange)>=foldChangeValue)
						diseaseNodeList.add(nodeName, null, foldChange, mutation);
				}
				else if(foldChangeRule==false && mutationFreqRule==true)
				{
					if(Math.abs(mutation)>=mutationFreqValue)
						diseaseNodeList.add(nodeName, null, foldChange, mutation);
				}
				else //double rules
				{
					//AND rule
					if(mutationFreqOperator.compareTo("AND")==0)
					{
						if(Math.abs(foldChange)>=foldChangeValue && Math.abs(mutation)>=mutationFreqValue)
							diseaseNodeList.add(nodeName, null, foldChange, mutation);
					}
					//OR rule
					if(mutationFreqOperator.compareTo("OR")==0)
					{
						if(Math.abs(foldChange)>=foldChangeValue || Math.abs(mutation)>=mutationFreqValue)
							diseaseNodeList.add(nodeName, null, foldChange, mutation);
					}
				}		
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public diseaseNode getNetworkViewNode_getDiseaseNodeFromRule(String view, boolean foldChangeRule, boolean mutationFreqRule, String mutationFreqOperator, double foldChangeValue, double mutationFreqValue){
		diseaseNode diseaseNodeList=new diseaseNode();

		ArrayList<String> FoldChange_sbmlNodeID=new ArrayList<String>();
		ArrayList<Double> FoldChange_foldChange=new ArrayList<Double>();
		ArrayList<String> MutationFreq_sbmlNodeID=new ArrayList<String>();
		ArrayList<Double> MutationFreq_percentage=new ArrayList<Double>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			//obtain the postgreSQL node id and fold change of this view with |fold_change|>=2.33 
			sqlStatement="SELECT NODE_ID, FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"';";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String nodeId=result.getString(1);
				double foldChange=Double.valueOf(result.getString(2));
				if(FoldChange_sbmlNodeID.contains(nodeId)==false)
				{
					FoldChange_sbmlNodeID.add(nodeId);
					FoldChange_foldChange.add(foldChange);
				}
			}

			//obtain the postgreSQL node id of this view with mutation>=2 
			sqlStatement="SELECT NODE_ID, PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"';";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String nodeId=result.getString(1);
				double mutation=Double.valueOf(result.getString(2));

				if(MutationFreq_sbmlNodeID.contains(nodeId)==false)
				{
					MutationFreq_sbmlNodeID.add(nodeId);
					MutationFreq_percentage.add(mutation);
				}
			}

			//single rule
			if(foldChangeRule==true && mutationFreqRule==false)
			{
				for(int i=0; i<FoldChange_foldChange.size(); i++)
				{
					if(Math.abs(FoldChange_foldChange.get(i))>=foldChangeValue)
					{
						String sbmlNodeId=FoldChange_sbmlNodeID.get(i);
						String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
						Double fc=FoldChange_foldChange.get(i);
						Double percent;
						sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND "
								+" NODE_ID='"+sbmlNodeId+"';";
						result=statement.executeQuery(sqlStatement);
						if(result.next())
							percent=Double.valueOf(result.getString(1));
						else
							percent=Double.valueOf(0);
						diseaseNodeList.add(nodeName, null, fc, percent);
					}
				}
			}
			else if(foldChangeRule==false && mutationFreqRule==true)
			{
				for(int i=0; i<MutationFreq_percentage.size(); i++)
				{
					if(MutationFreq_percentage.get(i)>=mutationFreqValue)
					{
						String sbmlNodeId=MutationFreq_sbmlNodeID.get(i);
						String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
						Double fc;
						Double percent=MutationFreq_percentage.get(i);
						sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND "
								+" NODE_ID='"+sbmlNodeId+"';";
						result=statement.executeQuery(sqlStatement);
						if(result.next())
							fc=Double.valueOf(result.getString(1));
						else
							fc=Double.valueOf(1);
						diseaseNodeList.add(nodeName, null, fc, percent);
					}
				}
			}
			else //double rules
			{
				//AND rule
				if(mutationFreqOperator.compareTo("AND")==0)
				{
					for(int i=0; i<FoldChange_foldChange.size(); i++)
					{
						if(Math.abs(FoldChange_foldChange.get(i))>=foldChangeValue)
						{
							String sbmlNodeId=FoldChange_sbmlNodeID.get(i);
							int mutationFreqSbmlNodeIDIndex=MutationFreq_sbmlNodeID.indexOf(sbmlNodeId);
							if(mutationFreqSbmlNodeIDIndex!=-1)
							{
								String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
								Double fc=FoldChange_foldChange.get(i);
								Double percent=MutationFreq_percentage.get(mutationFreqSbmlNodeIDIndex);
								if(percent>=mutationFreqValue)
									diseaseNodeList.add(nodeName, null, fc, percent);
							}
						}
					}
				}
				//OR rule
				if(mutationFreqOperator.compareTo("OR")==0)
				{
					for(int i=0; i<FoldChange_foldChange.size(); i++)
					{
						if(Math.abs(FoldChange_foldChange.get(i))>=foldChangeValue)
						{
							String sbmlNodeId=FoldChange_sbmlNodeID.get(i);
							String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
							Double fc=FoldChange_foldChange.get(i);
							Double percent;
							sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND "
									+" NODE_ID='"+sbmlNodeId+"';";
							result=statement.executeQuery(sqlStatement);
							if(result.next())
								percent=Double.valueOf(result.getString(1));
							else
								percent=Double.valueOf(0);
							diseaseNodeList.add(nodeName, null, fc, percent);
						}
					}
					for(int i=0; i<MutationFreq_percentage.size(); i++)
					{
						if(MutationFreq_percentage.get(i)>=mutationFreqValue)
						{
							String sbmlNodeId=MutationFreq_sbmlNodeID.get(i);
							String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
							if(diseaseNodeList.containsNode(nodeName)==false)
							{
								Double fc;
								Double percent=MutationFreq_percentage.get(i);
								sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND "
										+" NODE_ID='"+sbmlNodeId+"';";
								result=statement.executeQuery(sqlStatement);
								if(result.next())
									fc=Double.valueOf(result.getString(1));
								else
									fc=Double.valueOf(1);
								diseaseNodeList.add(nodeName, null, fc, percent);
							}
						}
					}
				}
			}			
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public diseaseNode getNetworkViewNode_getDiseaseNodeFromNodeList(String view, ArrayList<String> nodeList){
		diseaseNode diseaseNodeList=new diseaseNode();

		//System.out.println("nodeList:"+nodeList.toString());

		ArrayList<String> nodeSBMLID=new ArrayList<String>();
		for(int i=0; i<nodeList.size(); i++)
		{
			String sbmlID=getNodeID(getNodeDBID(nodeList.get(i)));
			if(sbmlID!=null && nodeSBMLID.contains(sbmlID)==false)
				nodeSBMLID.add(sbmlID);
		}

		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<nodeSBMLID.size(); i++)
			{
				String sbmlNodeId=nodeSBMLID.get(i);
				String nodeName=getNodeName(getNodeDBID(sbmlNodeId));
				double foldChange, mutation;

				sqlStatement="SELECT FOLD_CHANGE FROM NETWORK_VIEW_NODE_FOLDCHANGE WHERE VIEW_NAME='"+view+"' AND " +
						"NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					foldChange=Double.valueOf(result.getString(1));
				else
					foldChange=Double.valueOf(1);

				sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND " +
						"NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					mutation=Double.valueOf(result.getString(1));
				else
					mutation=Double.valueOf(0);
				diseaseNodeList.add(nodeName, null, foldChange, mutation);
				//		System.out.println("add "+nodeName+" "+foldChange+" "+mutation);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public ArrayList<Integer> getNodeHallmark(String node){
		ArrayList<Integer> hallmark=new ArrayList<Integer>();

		System.out.println("[getNetworkViewNode_getNodeHallmark] node:"+node);
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			//obtain the hallmarks of nodes in that view and store if jaccard>=0.8 
			sqlStatement="SELECT B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.NODE_ID=B.NODE_ID AND A.SBML_NODE_NAME='"+node+"';";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				for(int i=1; i<11; i++)
					hallmark.add(result.getInt(i));
			}

			statement.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return hallmark;
	}

	private void createSortTempTables()
	{
		try {
			Statement statement= conn.createStatement();

			String sqlCreateTempSortTab="CREATE TABLE IF NOT EXISTS TEMP_SORT (NAME TEXT PRIMARY KEY NOT NULL, VALUE NUMERIC NOT NULL);";
			//will commit automatically			
			statement.execute(sqlCreateTempSortTab);
			statement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public ArrayList<String> sortInDecreasing(ArrayList<String> nameList, ArrayList<Double> valList, boolean appendVal, String sortFunction, Double threshold){
		ArrayList<String> sortedList=new ArrayList<String>();

		//drop temporary tables
		dropTable(initTableList(TEMP_SORT_TABLE_NO_QUOTES));
		//create temporary tables 
		createSortTempTables();

		System.out.println("[sortInDecreasing] "+nameList.size()+" nameList:"+nameList.toString());
		System.out.println("[sortInDecreasing] "+valList.size()+" valList:"+valList.toString());
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<nameList.size(); i++)
			{
				sqlStatement="INSERT INTO TEMP_SORT (NAME, VALUE) VALUES ('"+nameList.get(i)+"', '"+valList.get(i)+"');";
				statement.execute(sqlStatement);
			}
			if(sortFunction.compareTo("RETURN_BEST_ONLY")==0)
				result=statement.executeQuery("SELECT NAME, VALUE FROM TEMP_SORT WHERE VALUE=(SELECT MAX(VALUE) FROM TEMP_SORT);");
			else if(sortFunction.compareTo("RETURN_ALL")==0)
				result=statement.executeQuery("SELECT NAME, VALUE FROM TEMP_SORT ORDER BY VALUE DESC;");
			else
				result=statement.executeQuery("SELECT NAME, VALUE FROM TEMP_SORT WHERE VALUE>"+threshold+" ORDER BY VALUE DESC;");
			while(result.next())
			{
				String name=result.getString(1);
				String value=result.getString(2);
				if(appendVal==true)
					sortedList.add(name+" ["+value+"]");
				else
					sortedList.add(name);
			}
			statement.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return sortedList;
	}

	public ArrayList<String> sortInIncreasing(ArrayList<String> nameList, ArrayList<Double> valList, boolean appendVal){
		ArrayList<String> sortedList=new ArrayList<String>();

		//drop temporary tables
		dropTable(initTableList(TEMP_SORT_TABLE_NO_QUOTES));
		//create temporary tables 
		createSortTempTables();

		System.out.println("[sortInIncreasing] nameList:"+nameList.toString());
		System.out.println("[sortInIncreasing] valList:"+valList.toString());
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<nameList.size(); i++)
			{
				sqlStatement="INSERT INTO TEMP_SORT (NAME, VALUE) VALUES ('"+nameList.get(i)+"', '"+valList.get(i)+"');";
				statement.execute(sqlStatement);
			}
			result=statement.executeQuery("SELECT NAME, VALUE FROM TEMP_SORT ORDER BY VALUE ASC;");
			while(result.next())
			{
				String name=result.getString(1);
				String value=result.getString(2);
				if(appendVal==true)
					sortedList.add(name+" ["+value+"]");
				else
					sortedList.add(name);
			}
			statement.close();
			result.close();

		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return sortedList;
	}

	public String computeTarget_findRandomCandidateNodeBasedOnHallmarkSimilarityAndFitnessFunction(ArrayList<Integer> hallmarkWeights, ArrayList<String> ancestorNode, double jaccardThreshold)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		ArrayList<Integer> diseaseNodeHallmark=new ArrayList<Integer>();
		//compute Jaccard index
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		ArrayList<String> rankedName=new ArrayList<String>();
		ArrayList<String> value=new ArrayList<String>();
		ArrayList<Integer> rank=new ArrayList<Integer>();
		ArrayList<Double> fitness=new ArrayList<Double>();
		ArrayList<Double> crossThresholdJaccardList=new ArrayList<Double>();
		ArrayList<String> crossThresholdAncestorList=new ArrayList<String>();
		double SP=1.8f;
		double upperBound=0f, lowerBound=0f;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			diseaseNodeHallmark=hallmarkWeights;

			//System.out.println("diseaseNodeHallmark:"+diseaseNodeHallmark.toString());
			//System.out.println("ancestorNode:"+ancestorNode.toString());

			//numA=diseaseNodeHallmark.size();
			//numB=diseaseNodeHallmark.size();

			for(int i=0; i<diseaseNodeHallmark.size(); i++)
			{
				if(diseaseNodeHallmark.get(i)>0)
					numA=numA+diseaseNodeHallmark.get(i);
			}

			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+ancestorNode.get(i)+"' AND A.NODE_ID=B.NODE_ID;";
				jaccardList.add(0.0);
				//System.out.println("i:"+i+" ancestorNode:"+ancestorNode.get(i));
				result=statement.executeQuery(sqlStatement);
				ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();

				if(result.next())
				{
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
				}
				//System.out.println("nodeHallmark:"+nodeHallmark.toString());
				//compute jaccard similarity
				Double jaccard, numerator, denominator;
				numB=0;
				numAIntersectB=0;
				for(int j=0; j<nodeHallmark.size(); j++)
				{
					if(nodeHallmark.get(j)==1)
					{
						if(diseaseNodeHallmark.get(j)>0)
						{
							numAIntersectB=numAIntersectB+diseaseNodeHallmark.get(j);
							numB=numB+diseaseNodeHallmark.get(j);
						}
						else
							numB=numB+1;
					}
					//if(nodeHallmark.get(j)==diseaseNodeHallmark.get(j))
					//	numAIntersectB++;
				}
				numerator=(double) numAIntersectB;
				denominator=(double) (numA+numB-numAIntersectB);
				if(denominator==0)//an empty set compared to empty set
					jaccard=(double)1;
				else
					jaccard=numerator/denominator;
				//System.out.println(ancestorNode.get(i)+"numA: "+numA+" numB:"+numB+" numAIntersectB:"+numAIntersectB+" numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
				jaccardList.set(i,jaccard);
			}

			//clear the TEMP_SORT table first
			sqlStatement="TRUNCATE TEMP_SORT;";
			statement.execute(sqlStatement);
			int count=0;
			for(int i=0; i<jaccardList.size(); i++)
			{
				if(jaccardList.get(i)>=jaccardThreshold)
				{
					sqlStatement="INSERT INTO TEMP_SORT (NAME, VALUE) VALUES ('"+ancestorNode.get(i)+"', '"+jaccardList.get(i)+"');";
					statement.execute(sqlStatement);
					crossThresholdJaccardList.add(jaccardList.get(i));
					crossThresholdAncestorList.add(ancestorNode.get(i));
					count++;
				}
			}
			//System.out.println("******************** count:"+count);
			//ranking in ascending of jaccard due to fitness rank value generation
			sqlStatement="SELECT NAME, VALUE, DENSE_RANK() OVER (ORDER BY VALUE ASC) FROM TEMP_SORT;";
			//sqlStatement="SELECT NAME, VALUE, DENSE_RANK() OVER (ORDER BY VALUE DESC) FROM TEMP_SORT;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				rankedName.add(result.getString(1));
				value.add(result.getString(2));
				rank.add(result.getInt(3));
				fitness.add((double)0);
			}
			int maxRank=rank.get(rank.size()-1);
			if(fitness.size()==1)
				fitness.set(0,(double)1);
			else
			{
				for(int i=0; i<fitness.size(); i++)
				{
					double n_minus, n_plus, f, N=(double)maxRank, r=(double)rank.get(i);
					n_minus=SP;
					n_plus=2-n_minus;
					f=1/N*(n_minus+(n_plus-n_minus)*(r-1)/(N-1));
					fitness.set(i,f);
				}
			}
			upperBound=fitness.get(0);
			lowerBound=fitness.get(fitness.size()-1);
			/*System.out.println("+++++++++++ rankedName: value rank fitness");
			if(fitness.size()==1)
				System.out.println(rankedName.get(0)+": "+value.get(0)+" "+rank.get(0)+" "+fitness.get(0));
			else
			{
				for(int i=0; i<10; i++)
					System.out.println(rankedName.get(i)+": "+value.get(i)+" "+rank.get(i)+" "+fitness.get(i));
			}*/

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		Random rand = new Random();
		boolean NOTFOUND=true;
		if(crossThresholdAncestorList.size()>0)
		{
			do{
				int  n = rand.nextInt(crossThresholdAncestorList.size());//generate random number from 0 to crossThresholdAncestorList.size() (inclusive)
				BigDecimal uB=BigDecimal.valueOf(upperBound);
				BigDecimal lB=BigDecimal.valueOf(lowerBound);
				BigDecimal range=uB.subtract(lB);
				BigDecimal r=lB.add(range.multiply(new BigDecimal(Math.random())));
				if(BigDecimal.valueOf(crossThresholdJaccardList.get(n)).compareTo(r)>=0)
					return crossThresholdAncestorList.get(n);
			}while(NOTFOUND);
		}
		return null;
	}

	public ArrayList<ArrayList<String>> computeTarget_getPredictedCombinations_Greedy()
	{
		//** temp_combi table columns
		//1) combi (array string)
		//2) disease_node_list (array string)
		//3) essential_offtarget 
		//4) outdegree_offtarget
		//5) offtarget_score
		//6) disease_node_coverage
		//7) elapsed_time
		//8) overall_score
		//** returned array of strings is the contents in these columns. Element 0 is column 1 (combi); element 1 is column 2 (disease_node_list)...
		Statement statement=null;
		ResultSet result=null;
		ArrayList<ArrayList<String>> predictedTargetCombinations=new ArrayList<ArrayList<String>>();
		try {
			statement = conn.createStatement();
			String sqlStatement="";
			System.out.println("postgreSQL.java: computeTarget_getPredictedCombinations_nonGreedy");

			sqlStatement="SELECT * FROM TEMP_CANDIDATE ORDER BY OVERALL_SCORE ASC";
			//if multiple best values are found, always return the first result
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				ArrayList<String> candidate=new ArrayList<String>();
				candidate.add(result.getString(1));
				candidate.add(result.getString(8));
				predictedTargetCombinations.add(candidate);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return predictedTargetCombinations;
	}

	public ArrayList<ArrayList<String>> computeTarget_getPredictedCombinations_nonGreedy()
	{
		//** temp_combi table columns
		//1) combi (array string)
		//2) disease_node_list (array string)
		//3) essential_offtarget 
		//4) outdegree_offtarget
		//5) offtarget_score
		//6) disease_node_coverage
		//7) elapsed_time
		//8) overall_score
		//** returned array of strings is the contents in these columns. Element 0 is column 1 (combi); element 1 is column 2 (disease_node_list)...
		Statement statement=null;
		ResultSet result=null;
		ArrayList<ArrayList<String>> predictedTargetCombinations=new ArrayList<ArrayList<String>>();
		try {
			statement = conn.createStatement();
			String sqlStatement="";
			System.out.println("postgreSQL.java: computeTarget_getPredictedCombinations_nonGreedy");

			for(int trial=1; trial<=10; trial++)
			{
				sqlStatement=sqlStatement+"SELECT * FROM TEMP_COMBI_"+trial;
				if(trial<10)
					sqlStatement=sqlStatement+" UNION ALL ";
			}
			sqlStatement=sqlStatement+" ORDER BY OVERALL_SCORE ASC";
			//if multiple best values are found, always return the first result
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				ArrayList<String> candidate=new ArrayList<String>();
				candidate.add(result.getString(1));
				candidate.add(result.getString(9));
				predictedTargetCombinations.add(candidate);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return predictedTargetCombinations;
	}

	public ArrayList<String> computeTarget_findBestCombinationBasedOnOffTarget(int trial)
	{
		//** temp_combi table columns
		//1) combi (array string)
		//2) disease_node_list (array string)
		//3) essential_offtarget 
		//4) outdegree_offtarget
		//5) offtarget_score
		//6) disease_node_coverage
		//7) elapsed_time
		//8) overall_score
		//** returned array of strings is the contents in these columns. Element 0 is column 1 (combi); element 1 is column 2 (disease_node_list)...
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> bestOffTargetCandidate=new ArrayList<String>();
		try {
			statement = conn.createStatement();
			String sqlStatement;
			System.out.println("postgreSQL.java: computeTarget_findBestCombinationBasedOnOffTarget");

			sqlStatement="SELECT * FROM TEMP_COMBI_"+trial+" WHERE OVERALL_SCORE=(SELECT MIN(OVERALL_SCORE) FROM TEMP_COMBI_"+trial+");";
			//if multiple best values are found, always return the first result
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				System.out.println("found something!!");
				//there are 8 columns in table TEMP_COMBI
				for(int i=1; i<9; i++)
				{
					bestOffTargetCandidate.add(result.getString(i));
					System.out.println(i+" "+result.getString(i));
				}
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		System.out.println("bestOffTargetCandidate:"+bestOffTargetCandidate.toString());
		return bestOffTargetCandidate;
	}

	public int computeTarget_tempCombiSize(int trial)
	{
		Statement statement=null;
		ResultSet result=null;
		int solutionSetSize=0;
		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT COUNT(COMBI) FROM TEMP_COMBI_"+trial+";";

			result=statement.executeQuery(sqlStatement);
			if(result.next())
				solutionSetSize=result.getInt(1);

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return solutionSetSize;
	}

	public ArrayList<String> computeTarget_findBestCandidateNodeOfDiseaseNodeBasedOnOffTarget()
	{
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> bestOffTargetCandidate=new ArrayList<String>();
		try {
			statement = conn.createStatement();
			String sqlStatement;
			System.out.println("postgreSQL.java: computeTarget_findBestCandidateNodeOfDiseaseNodeBasedOnOffTarget");

			sqlStatement="SELECT NEXTNODE FROM TEMP_CANDIDATE WHERE OVERALL_SCORE=(SELECT MIN(OVERALL_SCORE) FROM TEMP_CANDIDATE);";

			result=statement.executeQuery(sqlStatement);
			while(result.next())
				bestOffTargetCandidate.add(result.getString(1));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return bestOffTargetCandidate;
	}


	public String computeTarget_findRandomCandidateNodeOfDiseaseNodeBasedOnHallmarkSimilarityAndFitnessFunction(String diseaseNode, ArrayList<String> ancestorNode, Double jaccardThreshold)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		ArrayList<Integer> diseaseNodeHallmark=new ArrayList<Integer>();
		//compute Jaccard index
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		ArrayList<String> rankedName=new ArrayList<String>();
		ArrayList<String> value=new ArrayList<String>();
		ArrayList<Integer> rank=new ArrayList<Integer>();
		ArrayList<Double> fitness=new ArrayList<Double>();
		double SP=1.8f;
		double upperBound=0f, lowerBound=0f;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+diseaseNode+"' AND A.NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				for(int i=3; i<13; i++)
					diseaseNodeHallmark.add(result.getInt(i));
			}
			for(int i=0; i<diseaseNodeHallmark.size(); i++)
				numA=numA+diseaseNodeHallmark.get(i);
			//numA=diseaseNodeHallmark.size();
			//numB=diseaseNodeHallmark.size();

			System.out.println("diseaseNodeHallmark:"+diseaseNodeHallmark.toString());
			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+ancestorNode.get(i)+"' AND A.NODE_ID=B.NODE_ID;";
				jaccardList.add(0.0);
				result=statement.executeQuery(sqlStatement);
				ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();

				if(result.next())
				{
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
				}
				//compute jaccard similarity
				Double jaccard, numerator, denominator;
				numB=0;
				numAIntersectB=0;
				for(int j=0; j<nodeHallmark.size(); j++)
				{
					if(nodeHallmark.get(j)==1)
					{
						if(diseaseNodeHallmark.get(j)>0)
						{
							numAIntersectB=numAIntersectB+diseaseNodeHallmark.get(j);
							numB=numB+diseaseNodeHallmark.get(j);
						}
						else
							numB=numB+1;
					}
				}
				numerator=(double) numAIntersectB;
				denominator=(double) (numA+numB-numAIntersectB);
				if(denominator==0)//an empty set compared to empty set
					jaccard=(double)1;
				else
					jaccard=numerator/denominator;
				//System.out.println(ancestorNode.get(i)+" numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
				jaccardList.set(i,jaccard);
				if(ancestorNode.size()==1)
				{
					System.out.println("numA:"+numA+" numB:"+numB+" numAIntersectB:"+numAIntersectB);
				}
			}

			//clear the TEMP_SORT table first
			sqlStatement="TRUNCATE TEMP_SORT;";
			statement.execute(sqlStatement);
			for(int i=0; i<jaccardList.size(); i++)
			{
				sqlStatement="INSERT INTO TEMP_SORT (NAME, VALUE) VALUES ('"+ancestorNode.get(i)+"', '"+jaccardList.get(i)+"');";
				statement.execute(sqlStatement);
			}
			//sqlStatement="SELECT NAME, VALUE, DENSE_RANK() OVER (ORDER BY VALUE DESC) FROM TEMP_SORT;";
			//ranking in ascending of jaccard due to fitness rank value generation
			sqlStatement="SELECT NAME, VALUE, DENSE_RANK() OVER (ORDER BY VALUE ASC) FROM TEMP_SORT;"; 
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				rankedName.add(result.getString(1));
				value.add(result.getString(2));
				rank.add(result.getInt(3));
				fitness.add((double)0);
			}
			int maxRank=rank.get(rank.size()-1);
			if(fitness.size()==1)
				fitness.set(0,(double)1);
			else
			{
				for(int i=0; i<fitness.size(); i++)
				{
					double n_minus, n_plus, f, N=(double)maxRank, r=(double)rank.get(i);
					n_minus=SP;
					n_plus=2-n_minus;
					f=1/N*(n_minus+(n_plus-n_minus)*(r-1)/(N-1));
					fitness.set(i,f);
				}
			}
			upperBound=fitness.get(0);
			lowerBound=fitness.get(fitness.size()-1);
			/*System.out.println("+++++++++++ rankedName: value rank fitness");
			if(fitness.size()==1)
				System.out.println(rankedName.get(0)+": "+value.get(0)+" "+rank.get(0)+" "+fitness.get(0));
			else
			{
				for(int i=0; i<10; i++)
					System.out.println(rankedName.get(i)+": "+value.get(i)+" "+rank.get(i)+" "+fitness.get(i));
			}*/

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		Random rand = new Random();
		boolean NOTFOUND=true;
		do{
			System.out.println("^^ ancestorNode.size():"+ancestorNode.size()+" jaccardList.size():"+jaccardList.size());
			int n;
			if(ancestorNode.size()>1)
				n = rand.nextInt(ancestorNode.size());//generate random number from 0 to ancestorNode.size() (inclusive)
			else
				n = 0;
			BigDecimal uB=BigDecimal.valueOf(upperBound);
			BigDecimal lB=BigDecimal.valueOf(lowerBound);
			BigDecimal range=uB.subtract(lB);
			BigDecimal r=lB.add(range.multiply(new BigDecimal(Math.random())));
			System.out.println("jaccardList.get(n):"+jaccardList.get(n));
			System.out.println("r:"+r);
			if(BigDecimal.valueOf(jaccardList.get(n)).compareTo(r)>=0)
				return ancestorNode.get(n);
		}while(NOTFOUND);
		return null;
	}

	public ArrayList<String> computeTarget_findBestCandidateNodeBasedOnHallmarkSimilarity(ArrayList<Integer> diseaseNodeHallmark, ArrayList<String> ancestorNode, Double jaccardThreshold)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		//compute Jaccard index
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<diseaseNodeHallmark.size(); i++)
				numA=numA+diseaseNodeHallmark.get(i);
			//numA=diseaseNodeHallmark.size();
			//numB=diseaseNodeHallmark.size();

			System.out.println("diseaseNodeHallmark:"+diseaseNodeHallmark.toString());
			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+ancestorNode.get(i)+"' AND A.NODE_ID=B.NODE_ID;";
				jaccardList.add(0.0);
				result=statement.executeQuery(sqlStatement);
				if(result.next())
				{
					ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
					//compute jaccard similarity
					Double jaccard, numerator, denominator;
					numB=0;
					numAIntersectB=0;
					for(int j=0; j<nodeHallmark.size(); j++)
					{
						if(nodeHallmark.get(j)==1)
						{
							if(diseaseNodeHallmark.get(j)>0)
							{
								numAIntersectB=numAIntersectB+diseaseNodeHallmark.get(j);
								numB=numB+diseaseNodeHallmark.get(j);
							}
							else
								numB=numB+1;
						}

						//if(nodeHallmark.get(j)==diseaseNodeHallmark.get(j))
						//	numAIntersectB++;
					}
					numerator=(double) numAIntersectB;
					denominator=(double) (numA+numB-numAIntersectB);
					if(denominator==0)//an empty set compared to empty set
						jaccard=(double)1;
					else
						jaccard=numerator/denominator;
					//System.out.println(ancestorNode.get(i)+" numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
					jaccardList.set(i,jaccard);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		System.out.println("ancestorNode:"+ancestorNode.toString());
		System.out.println("jaccardList:"+jaccardList.toString());
		ArrayList<String> bestCandidates=sortInDecreasing(ancestorNode, jaccardList, false, "RETURN_GREATER_THAN_EQUAL_TO_THRESHOLD", jaccardThreshold);
		System.out.println("bestCandidates:"+bestCandidates.toString());
		return bestCandidates;
	}

	public ArrayList<String> computeTarget_findBestCandidateNodeOfDiseaseNodeBasedOnHallmarkSimilarity(String diseaseNode, ArrayList<String> ancestorNode, Double jaccardThreshold)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		ArrayList<Integer> diseaseNodeHallmark=new ArrayList<Integer>();
		//compute Jaccard index
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+diseaseNode+"' AND A.NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				for(int i=3; i<13; i++)
					diseaseNodeHallmark.add(result.getInt(i));
			}
			for(int i=0; i<diseaseNodeHallmark.size(); i++)
				numA=numA+diseaseNodeHallmark.get(i);
			//numA=diseaseNodeHallmark.size();
			//numB=diseaseNodeHallmark.size();

			System.out.println("diseaseNodeHallmark:"+diseaseNodeHallmark.toString());
			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+ancestorNode.get(i)+"' AND A.NODE_ID=B.NODE_ID;";
				jaccardList.add(0.0);
				result=statement.executeQuery(sqlStatement);
				if(result.next())
				{
					ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
					//compute jaccard similarity
					Double jaccard, numerator, denominator;
					numB=0;
					numAIntersectB=0;
					for(int j=0; j<nodeHallmark.size(); j++)
					{
						if(nodeHallmark.get(j)==1)
						{
							if(diseaseNodeHallmark.get(j)>0)
							{
								numAIntersectB=numAIntersectB+diseaseNodeHallmark.get(j);
								numB=numB+diseaseNodeHallmark.get(j);
							}
							else
								numB=numB+1;
						}
						//if(nodeHallmark.get(j)==diseaseNodeHallmark.get(j))
						//	numAIntersectB++;
					}
					numerator=(double) numAIntersectB;
					denominator=(double) (numA+numB-numAIntersectB);
					if(denominator==0)//an empty set compared to empty set
						jaccard=(double)1;
					else
						jaccard=numerator/denominator;
					//System.out.println(ancestorNode.get(i)+" numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
					jaccardList.set(i,jaccard);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		System.out.println("ancestorNode:"+ancestorNode.toString());
		System.out.println("jaccardList:"+jaccardList.toString());
		ArrayList<String> bestCandidates=sortInDecreasing(ancestorNode, jaccardList, false, "RETURN_GREATER_THAN_EQUAL_TO_THRESHOLD", jaccardThreshold);
		System.out.println("bestCandidates:"+bestCandidates.toString());
		return bestCandidates;
	}

	public ArrayList<String> computeTarget_retrieveAncestorOfDiseaseNode(String diseaseNode)
	{
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> list=new ArrayList<String>();
		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT ANCESTOR FROM TEMP_ALL_ANCESTORS_OF_DISEASE_NODES WHERE NODE='"+diseaseNode+"';";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				if(list.contains(result.getString(1))==false)
					list.add(result.getString(1));
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		return list;
	}

	public double computeTarget_getSelectionProbabilityOfNode(String node)
	{
		double probability=0f;
		Statement statement=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT SELECTION_PROBABILITY FROM TEMP_CANDIDATE_HALLMARK_RANK WHERE CANDIDATE='"+node+"';";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				probability=Double.valueOf(result.getFloat(1));
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return probability;
	}

	public void computeTarget_computeSelectionProbabilityOfRemainingAncestorOfDiseaseNode(String diseaseNode, ArrayList<String> ancestorNode)
	{
		Statement statement=null, statement2=null;
		ResultSet result=null;
		try {
			statement = conn.createStatement();
			statement2 = conn.createStatement();
			String sqlStatement, sqlStatement2, ancestorString="";

			// populate TEMP_ALL_ANCESTORS_OF_DISEASE_NODES with CANDIDATE and JACCARD_INDEX data first
			for(int i=0; i<ancestorNode.size(); i++)
			{
				ancestorString=ancestorString+"'"+ancestorNode.get(i)+"'";
				if(i<ancestorNode.size()-1)
					ancestorString=ancestorString+",";
			}
			sqlStatement="SELECT NODE, ANCESTOR, JACCARD FROM TEMP_ALL_ANCESTORS_OF_DISEASE_NODES WHERE NODE='"+diseaseNode
					+ "' AND ANCESTOR IN ("+ancestorString+");";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				sqlStatement2="INSERT INTO TEMP_CANDIDATE_HALLMARK_RANK (CANDIDATE, JACCARD_INDEX) VALUES ('"+result.getString(2)+"', '"+result.getFloat(3)+"');";
				statement2.execute(sqlStatement2);
			}
			// then rank based on descending JACCARD_INDEX and update RANK
			sqlStatement="SELECT CANDIDATE, DENSE_RANK() OVER (ORDER BY JACCARD_INDEX DESC) FROM TEMP_CANDIDATE_HALLMARK_RANK";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String candidate=result.getString(1);
				int rank=result.getInt(2);
				sqlStatement2="UPDATE TEMP_CANDIDATE_HALLMARK_RANK SET RANK="+rank+" WHERE CANDIDATE='"+candidate+"';";
				statement2.execute(sqlStatement2);
			}
			//finally compute SELECTION_PROBABILITY based on RANK
			//compute fitness   2-SP+2*(SP-1)*(rank-1)/(maxRank-1)
			int maxRank;
			sqlStatement="SELECT MAX(RANK) FROM TEMP_CANDIDATE_HALLMARK_RANK";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxRank=result.getInt(1);
			else
				maxRank=0;
			System.out.println("maxRank:"+maxRank);
			sqlStatement="SELECT CANDIDATE, RANK FROM TEMP_CANDIDATE_HALLMARK_RANK";
			result=statement.executeQuery(sqlStatement);
			while(result.next())
			{
				String candidate=result.getString(1);
				int rank=result.getInt(2);
				double SP=1.8;
				double fitness_probability;

				if(maxRank==1)
					fitness_probability=1;
				else
					fitness_probability=2-SP+2*(SP-1)*(rank-1)/(maxRank-1);
				System.out.println("candidate:"+candidate+" fitness_probability:"+fitness_probability);
				sqlStatement2="UPDATE TEMP_CANDIDATE_HALLMARK_RANK SET SELECTION_PROBABILITY="+fitness_probability+" WHERE CANDIDATE='"+candidate+"';";
				statement2.execute(sqlStatement2);
			}

			statement2.close();
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void computeTarget_populateAncestorNodeListOfDiseaseNodes(String diseaseNode, ArrayList<String> ancestorNode)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		ArrayList<Integer> diseaseNodeHallmark=new ArrayList<Integer>();
		//compute Jaccard index
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
					+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
					+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+diseaseNode+"' AND A.NODE_ID=B.NODE_ID;";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
			{
				for(int i=3; i<13; i++)
					diseaseNodeHallmark.add(result.getInt(i));
			}
			for(int i=0; i<diseaseNodeHallmark.size(); i++)
				numA=numA+diseaseNodeHallmark.get(i);
			//numA=diseaseNodeHallmark.size();
			//numB=diseaseNodeHallmark.size();

			System.out.println("diseaseNodeHallmark:"+diseaseNodeHallmark.toString());
			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.SBML_NODE_NAME='"+ancestorNode.get(i)+"' AND A.NODE_ID=B.NODE_ID;";
				jaccardList.add(0.0);
				result=statement.executeQuery(sqlStatement);
				if(result.next())
				{
					ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
					//compute jaccard similarity
					Double jaccard, numerator, denominator;
					numB=0;
					numAIntersectB=0;
					for(int j=0; j<nodeHallmark.size(); j++)
					{
						if(nodeHallmark.get(j)==1)
						{
							if(diseaseNodeHallmark.get(j)>0)
							{
								numAIntersectB=numAIntersectB+diseaseNodeHallmark.get(j);
								numB=numB+diseaseNodeHallmark.get(j);
							}
							else
								numB=numB+1;
						}

						//if(nodeHallmark.get(j)==diseaseNodeHallmark.get(j))
						//	numAIntersectB++;
					}
					numerator=(double) numAIntersectB;
					denominator=(double) (numA+numB-numAIntersectB);
					if(denominator==0)//an empty set compared to empty set
						jaccard=(double)1;
					else
						jaccard=numerator/denominator;
					//System.out.println(ancestorNode.get(i)+" numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
					jaccardList.set(i,jaccard);
				}
			}

			System.out.println("ancestorNode:"+ancestorNode.toString());
			System.out.println("jaccardList:"+jaccardList.toString());
			for(int i=0; i<ancestorNode.size(); i++)
			{
				sqlStatement="INSERT INTO TEMP_ALL_ANCESTORS_OF_DISEASE_NODES (NODE, ANCESTOR, JACCARD) VALUES ('"+diseaseNode+"', '"+ancestorNode.get(i)+"', '"
						+jaccardList.get(i)+"');";
				statement.execute(sqlStatement);
			}


			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public ArrayList<String> computeTarget_rankDiseaseNodeBasedOnRankedHallmark(ArrayList<String> selectedDiseaseNode, ArrayList<Integer> hallmarkWeights)
	{
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> rankedDiseaseNode=new ArrayList<String>();
		ArrayList<Double> jaccardList=new ArrayList<Double>();
		int numA=0, numB, numAIntersectB;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<hallmarkWeights.size(); i++)
				numA=numA+hallmarkWeights.get(i);
			//numA=hallmarkWeights.size();
			//numB=hallmarkWeights.size();

			for(int i=0; i<selectedDiseaseNode.size(); i++)
			{
				int nodeId=getNodeDBID(selectedDiseaseNode.get(i));
				System.out.println(selectedDiseaseNode.get(i)+" sbmlNodeId:"+nodeId);
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.NODE_ID="+nodeId+" AND B.NODE_ID="+nodeId+";";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
				{
					ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
					for(int j=3; j<13; j++)
						nodeHallmark.add(result.getInt(j));
					System.out.println(selectedDiseaseNode.get(i)+" nodeHallmark:"+nodeHallmark.toString()+" hallmarkWeights:"+hallmarkWeights.toString());
					//compute jaccard similarity
					Double jaccard, numerator, denominator;
					numB=0;
					numAIntersectB=0;
					for(int j=0; j<nodeHallmark.size(); j++)
					{
						if(nodeHallmark.get(j)==1)
						{
							if(hallmarkWeights.get(j)>0)
							{
								numAIntersectB=numAIntersectB+hallmarkWeights.get(j);
								numB=numB+hallmarkWeights.get(j);
							}
							else
								numB=numB+1;
						}
						//if(nodeHallmark.get(j)==hallmarkWeights.get(j))
						//	numAIntersectB++;
					}
					numerator=(double) numAIntersectB;
					denominator=(double) (numA+numB-numAIntersectB);
					if(denominator==0)//an empty set compared to empty set
						jaccard=(double)1;
					else
						jaccard=numerator/denominator;
					System.out.println("numerator:"+numerator+" denominator:"+denominator+" jaccard:"+jaccard);
					rankedDiseaseNode.add(selectedDiseaseNode.get(i));
					jaccardList.add(jaccard);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		rankedDiseaseNode=sortInDecreasing(rankedDiseaseNode, jaccardList, false, "RETURN_ALL", 0.0);

		return rankedDiseaseNode;
	}

	@SuppressWarnings("unused")
	public double computeTarget_getJaccardForCandidateNodes(ArrayList<String> selectedCandidateNodes, ArrayList<Integer> hallmarkWeights)
	{
		Statement statement=null;
		ResultSet result=null;
		int numA=0, numB, numAIntersectB;
		double jaccard=0;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<hallmarkWeights.size(); i++)
				numA=numA+hallmarkWeights.get(i);
			//numA=hallmarkWeights.size();
			//numB=hallmarkWeights.size();

			ArrayList<Integer> nodeHallmark=new ArrayList<Integer>();
			for(int i=0; i<selectedCandidateNodes.size(); i++)
			{
				boolean emptyNodeHallmark=true;
				int nodeId=getNodeDBID(selectedCandidateNodes.get(i));
				System.out.println(selectedCandidateNodes.get(i)+" sbmlNodeId:"+nodeId);
				sqlStatement="SELECT A.SBML_NODE_NAME, A.NODE_ID, B.PROLIFERATION, B.GROWTH_REPRESSOR, B.APOPTOSIS, B.REPLICATIVE_IMMORTALITY, B.ANGIOGENESIS, B.METASTASIS, "
						+ "B.METABOLISM, B.IMMUNE_DESTRUCTION, B.GENOME_INSTABILITY, B.TUMOR_PROMOTING_INFLAMMATION FROM CURR_NETWORK_NODE AS A, "
						+ "HALLMARK_HALLMARK AS B WHERE A.NODE_ID="+nodeId+" AND B.NODE_ID="+nodeId+";";
				result=statement.executeQuery(sqlStatement);
				if(nodeHallmark.size()>0)
					emptyNodeHallmark=false;
				if(result.next())
				{
					for(int j=3; j<13; j++)
					{
						if(emptyNodeHallmark)
							nodeHallmark.add(result.getInt(j));
						else
						{
							System.out.println("i:"+i+" nodeHallmark:"+nodeHallmark.toString()+" selectedCandidateNodes:"+selectedCandidateNodes.toString());
							int currWt=nodeHallmark.get(j-3);
							int newWt=currWt+result.getInt(j);
							nodeHallmark.set(j-3, newWt);
						}
					}
					System.out.println(selectedCandidateNodes.get(i)+" nodeHallmark:"+nodeHallmark.toString()+" hallmarkWeights:"+hallmarkWeights.toString());
				}
			}
			//compute jaccard similarity
			double numerator, denominator;
			numB=0;
			numAIntersectB=0;
			for(int j=0; j<nodeHallmark.size(); j++)
			{
				if(nodeHallmark.get(j)>0)
				{
					numAIntersectB=numAIntersectB+hallmarkWeights.get(j);
					numB=numB+hallmarkWeights.get(j);
				}
				else
					numB=numB+1;

				//if(nodeHallmark.get(j)==hallmarkWeights.get(j))
				//	numAIntersectB++;
			}
			numerator=(double) numAIntersectB;
			denominator=(double) (numA+numB-numAIntersectB);
			if(denominator==0)//an empty set compared to empty set
				jaccard=(double)1;
			else
				jaccard=numerator/denominator;

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		System.out.println("jaccard:"+jaccard);
		return jaccard;
	}

	public ArrayList<String> computeTarget_getIncrementalDiseaseNodeCovered(String node)
	{
		ArrayList<String> incrementalDiseaseNodeCovered=new ArrayList<String>();

		try {
			Statement statement = conn.createStatement();
			ResultSet result = statement.executeQuery("SELECT DISEASE_NODE_LIST FROM TEMP_CANDIDATE WHERE NEXTNODE='"+node+"';");

			if(result.next())
			{
				String comma=",";
				String incrementalDiseaseNodeString=result.getString(1);
				//remove square brackets
				incrementalDiseaseNodeString=incrementalDiseaseNodeString.substring(1,incrementalDiseaseNodeString.length()-1);
				System.out.println("incrementalDiseaseNodeString:"+incrementalDiseaseNodeString);
				int commaIndex=incrementalDiseaseNodeString.indexOf(comma);

				while(incrementalDiseaseNodeString!=null)
				{
					String diseaseNode;
					if(commaIndex!=-1)
					{
						diseaseNode=incrementalDiseaseNodeString.substring(0,commaIndex);
						incrementalDiseaseNodeString=incrementalDiseaseNodeString.substring(commaIndex+1).trim();
						commaIndex=incrementalDiseaseNodeString.indexOf(comma);
					}
					else
					{
						diseaseNode=incrementalDiseaseNodeString;
						incrementalDiseaseNodeString=null;
					}
					if(incrementalDiseaseNodeCovered.contains(diseaseNode)==false)
						incrementalDiseaseNodeCovered.add(diseaseNode);
				}
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return incrementalDiseaseNodeCovered;
	}

	public void computeTarget_add_temp_combi(String node, String diseaseNodeListSize, String diseaseNodeList, String essential_offTargetStr, String outDegree_offTargetStr, boolean useEssentialRule, boolean useOutDegreeRule, String essentialWtStr, String outDegreeWtStr, String numDiseaseNode, String jaccard) {
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			//get nodeID
			ResultSet result = statement.executeQuery("SELECT * FROM TEMP_CANDIDATE WHERE NEXTNODE='"+node+"';");

			if(!result.next())
			{
				double offTargetScore;
				double overallScore;
				if(useEssentialRule==true && useOutDegreeRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2)+Math.pow((outDegreeWt*outDegree),2));
				}
				else if(useEssentialRule==true)
				{
					double essentialWt=Double.parseDouble(essentialWtStr);
					double essential=Double.parseDouble(essential_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((essentialWt*essential),2));
				}
				else
				{
					double outDegreeWt=Double.parseDouble(outDegreeWtStr);
					double outDegree=Double.parseDouble(outDegree_offTargetStr);
					offTargetScore=Math.sqrt(Math.pow((outDegreeWt*outDegree),2));
				}
				overallScore=Math.sqrt(offTargetScore*offTargetScore+(Double.parseDouble(diseaseNodeListSize)-Double.parseDouble(numDiseaseNode))/Double.parseDouble(diseaseNodeListSize)*(Double.parseDouble(diseaseNodeListSize)-Double.parseDouble(numDiseaseNode))/Double.parseDouble(diseaseNodeListSize)+
						(1-Double.parseDouble(jaccard))*(1-Double.parseDouble(jaccard)));
				sqlStatement="INSERT INTO TEMP_CANDIDATE (NEXTNODE, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_NUM, JACCARD, OVERALL_SCORE) VALUES ('"+node+"', '"
						+diseaseNodeList+"', '"+essential_offTargetStr+"', '"+outDegree_offTargetStr+"', '"+offTargetScore+"', '"+numDiseaseNode+"', '"+jaccard+"', '"+overallScore+"');";
				statement.execute(sqlStatement);
			}
			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void computeTarget_storeThisTrialSummary(int trial, int requiredT, int requiredIt, double elapsedTime)
	{
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			sqlStatement="INSERT INTO TEMP_COMBI_SUMMARY (TRIAL, TEMPERATURE, ITERATION, ELAPSED_TIME) VALUES ('"+trial+"', '"
					+requiredT+"', '"+requiredIt+"', '"+elapsedTime+"');";
			statement.execute(sqlStatement);
			statement.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public void computeTarget_addRandomTempCombi(int trial, ArrayList<String> combi, ArrayList<String> coveredDiseaseNode, double essential, double outdegree, double offTargetScore, double diseaseNodeCoverage, double elapsedTime, double jaccard, double overallScore)
	{
		try {
			Statement statement = conn.createStatement();
			String sqlStatement=null;
			sqlStatement="INSERT INTO TEMP_COMBI_"+trial+" (COMBI, DISEASE_NODE_LIST, ESSENTIAL_OFFTARGET, OUTDEGREE_OFFTARGET, OFFTARGET_SCORE, DISEASE_NODE_COVERAGE, ELAPSED_TIME, JACCARD, OVERALL_SCORE) VALUES ('"+combi.toString()+"', '"
					+coveredDiseaseNode.toString()+"', '"+essential+"', '"+outdegree+"', '"+offTargetScore+"', '"+diseaseNodeCoverage+"', '"+elapsedTime+"', '"+jaccard+"', '"+overallScore+"');";
			statement.execute(sqlStatement);
			statement.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
	}

	public double getNetworkViewNode_getTotalNonDiseaseNodesOutDegree(String view, ArrayList<String> allNodeList, ArrayList<String> diseaseNode){
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> nonDiseaseNodeList=new ArrayList<String>();
		double totalNonDiseaseNodesOutDegree=Double.valueOf(0);

		for(int i=0; i<allNodeList.size(); i++)
		{
			if(diseaseNode.contains(allNodeList.get(i))==false && nonDiseaseNodeList.contains(allNodeList.get(i))==false)
				nonDiseaseNodeList.add(allNodeList.get(i));
		}

		//System.out.println("diseaseNode:"+diseaseNode.toString());
		//System.out.println("nonDiseaseNodeList:"+nonDiseaseNodeList.size()+" "+nonDiseaseNodeList.toString());
		try {
			statement = conn.createStatement();
			String sqlStatement;

			for(int i=0; i<nonDiseaseNodeList.size(); i++)
			{
				String sbmlNodeId=getNodeID(getNodeDBID(nonDiseaseNodeList.get(i)));
				double percent=Double.valueOf(0), weight=Double.valueOf(0);
				int outDegree=0;
				sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					percent=Double.valueOf(result.getString(1));
				weight=(100-percent)/100;
				sqlStatement="SELECT OUT_DEGREE FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbmlNodeId+"';";
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					outDegree=result.getInt(1);
				totalNonDiseaseNodesOutDegree=totalNonDiseaseNodesOutDegree+weight*Double.valueOf(outDegree);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return totalNonDiseaseNodesOutDegree;
	}

	public double getNetworkViewNode_getNonDiseaseNodesOutDegreeFraction(String view, ArrayList<String> nodeList, double totalPercentage){
		Statement statement=null;
		ResultSet result=null;
		double totalNonDiseaseNodesOutDegree=Double.valueOf(0);

		if(nodeList.size()>0)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement;

				for(int i=0; i<nodeList.size(); i++)
				{
					String sbmlNodeId=getNodeID(getNodeDBID(nodeList.get(i)));
					double percent=Double.valueOf(0), weight=Double.valueOf(0);
					int outDegree=0;
					sqlStatement="SELECT PERCENTAGE FROM NETWORK_VIEW_NODE_MUTATION WHERE VIEW_NAME='"+view+"' AND NODE_ID='"+sbmlNodeId+"';";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						percent=Double.valueOf(result.getString(1));
					weight=(100-percent)/100;
					sqlStatement="SELECT OUT_DEGREE FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID='"+sbmlNodeId+"';";
					result=statement.executeQuery(sqlStatement);
					if(result.next())
						outDegree=result.getInt(1);
					totalNonDiseaseNodesOutDegree=totalNonDiseaseNodesOutDegree+weight*Double.valueOf(outDegree);
				}

				statement.close();
				result.close();
			}catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			}
		}
		return totalNonDiseaseNodesOutDegree/totalPercentage;
	}

	public int getNetworkViewNode_getTotalEssentialNode(String view){
		Statement statement=null;
		ResultSet result=null;
		int totalCount=0; 

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT COUNT(NODE_ID) FROM NETWORK_VIEW_NODE_ESSENTIAL WHERE VIEW_NAME='"+view+"';";
			result=statement.executeQuery(sqlStatement);
			if(result.next())
				totalCount=result.getInt(1);

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return totalCount;
	}

	public double getNetworkViewNode_getEssentialNodeFraction(String view, ArrayList<String> nodeList, int totalEssentialNodes){
		double percent=Double.valueOf(0);
		Statement statement=null;
		ResultSet result=null;
		int count=0; 

		if(nodeList.size()>0)
		{
			try {
				statement = conn.createStatement();
				String sqlStatement, sbmlNodeIdList="";

				for(int i=0; i<nodeList.size(); i++)
				{
					String sbmlNodeId=getNodeID(getNodeDBID(nodeList.get(i)));
					sbmlNodeIdList=sbmlNodeIdList+"'"+sbmlNodeId+"'";
					if(i<nodeList.size()-1)
						sbmlNodeIdList=sbmlNodeIdList+",";
				}

				sqlStatement="SELECT COUNT(NODE_ID) FROM NETWORK_VIEW_NODE_ESSENTIAL WHERE VIEW_NAME='"+view+"' " +
						"AND NODE_ID IN ("+sbmlNodeIdList+");";
				//System.out.println(sqlStatement);
				result=statement.executeQuery(sqlStatement);
				if(result.next())
					count=result.getInt(1);
				percent=Double.valueOf(count)/Double.valueOf(totalEssentialNodes);
				//System.out.println("count:"+count+" totalEssentialNodes:"+totalEssentialNodes+" percent:"+percent);

				statement.close();
				result.close();
			}catch (SQLException ex) {
				// handle any errors
				System.out.println("SQLException: " + ex.getMessage());
				System.out.println("SQLState: " + ex.getSQLState());
				System.out.println("VendorError: " + ex.getErrorCode());
			}
		}
		return percent;
	}
	/*
	public ArrayList<String> getNetworkViewNode_getDiseaseNodeCoveredFromTempCommonAncestor(ArrayList<String> diseaseNodeList, String node)
	{
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT DISEASE_NODE_LIST FROM TEMP_COMMON_ANCESTORS WHERE NODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String nodeList=result.getString(1);
				String delimiter=",";
				int delimiterIndex;
				while(nodeList!=null && nodeList.length()>0)
				{
					delimiterIndex=nodeList.indexOf(delimiter);
					String diseaseNode;
					if(delimiterIndex!=-1)
					{
						diseaseNode=nodeList.substring(0, delimiterIndex);
						nodeList=nodeList.substring(delimiterIndex+1);
					}
					else
					{
						diseaseNode=nodeList;
						nodeList=null;
					}
					if(diseaseNodeList.contains(diseaseNode)==false)
						diseaseNodeList.add(diseaseNode);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}
	 */
	public ArrayList<String> getNetworkViewNode_getDiseaseNodeCoveredFromTempCombi(ArrayList<String> diseaseNodeList, String node)
	{
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT DISEASE_NODE_LIST FROM TEMP_COMBI WHERE NEXTNODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String nodeList=result.getString(1);
				String delimiter=",";
				int delimiterIndex;
				while(nodeList!=null && nodeList.length()>0)
				{
					delimiterIndex=nodeList.indexOf(delimiter);
					String diseaseNode;
					if(delimiterIndex!=-1)
					{
						diseaseNode=nodeList.substring(0, delimiterIndex);
						nodeList=nodeList.substring(delimiterIndex+1);
					}
					else
					{
						diseaseNode=nodeList;
						nodeList=null;
					}
					if(diseaseNodeList.contains(diseaseNode)==false)
						diseaseNodeList.add(diseaseNode);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public ArrayList<String> getNetworkViewNode_getDiseaseNodeCoveredFromTempCandidateAll(ArrayList<String> diseaseNodeList, String node)
	{
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT DISEASE_NODE_LIST FROM TEMP_CANDIDATE_ALL WHERE METANODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String nodeList=result.getString(1);
				String delimiter=",";
				int delimiterIndex;
				while(nodeList!=null && nodeList.length()>0)
				{
					delimiterIndex=nodeList.indexOf(delimiter);
					String diseaseNode;
					if(delimiterIndex!=-1)
					{
						diseaseNode=nodeList.substring(0, delimiterIndex);
						nodeList=nodeList.substring(delimiterIndex+1);
					}
					else
					{
						diseaseNode=nodeList;
						nodeList=null;
					}
					if(diseaseNodeList.contains(diseaseNode)==false)
						diseaseNodeList.add(diseaseNode);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}
		System.out.println("[getNetworkViewNode_getDiseaseNodeCoveredFromTempCandidateAll] diseaseNodeList:"+diseaseNodeList.toString());
		return diseaseNodeList;
	}

	public ArrayList<String> getNetworkViewNode_getDiseaseNodeCoveredFromTempCandidate(ArrayList<String> diseaseNodeList, String node)
	{
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT DISEASE_NODE_LIST FROM TEMP_CANDIDATE WHERE NEXTNODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String nodeList=result.getString(1);
				String delimiter=",";
				int delimiterIndex;
				while(nodeList!=null && nodeList.length()>0)
				{
					delimiterIndex=nodeList.indexOf(delimiter);
					String diseaseNode;
					if(delimiterIndex!=-1)
					{
						diseaseNode=nodeList.substring(0, delimiterIndex);
						nodeList=nodeList.substring(delimiterIndex+1);
					}
					else
					{
						diseaseNode=nodeList;
						nodeList=null;
					}
					if(diseaseNodeList.contains(diseaseNode)==false)
						diseaseNodeList.add(diseaseNode);
				}
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return diseaseNodeList;
	}

	public targetCombination getNetworkViewNode_getPredictedTargetCombiFromTempCandidate(ArrayList<String> bestCombi)
	{
		Statement statement=null;
		ResultSet result=null;
		targetCombination tc=new targetCombination();

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NEXTNODE, DISEASE_NODE_LIST, OFFTARGET_SCORE FROM TEMP_CANDIDATE ORDER BY OFFTARGET_SCORE ASC;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				ArrayList<String> combi=new ArrayList<String>();
				for(int i=0; i<bestCombi.size()-1; i++)
					combi.add(bestCombi.get(i));
				combi.add(result.getString(1));
				String nodeList=result.getString(2);
				Double score=(result.getBigDecimal(3)).doubleValue();
				tc.addTargetCombination(combi, nodeList, score);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return tc;
	}

	public double getNetworkViewNode_getOffTargetScoreFromTempCombi(String node)
	{
		Statement statement=null;
		ResultSet result=null;
		double score=Double.parseDouble("0");

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT OFFTARGET_SCORE FROM TEMP_COMBI WHERE NEXTNODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String scoreString=result.getString(1);
				score=Double.parseDouble(scoreString);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return score;
	}

	public double getNetworkViewNode_getOffTargetScoreFromTempCandidate(String node)
	{
		Statement statement=null;
		ResultSet result=null;
		double score=Double.parseDouble("0");

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT OFFTARGET_SCORE FROM TEMP_CANDIDATE WHERE NEXTNODE='"+node+"';";
			result=statement.executeQuery(sqlStatement);

			if(result.next())
			{
				String scoreString=result.getString(1);
				score=Double.parseDouble(scoreString);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return score;
	}
	/*
	public ArrayList<String> getNetworkViewNode_getSingleAncestorNodeFromTempCommonAncestor()
	{
		Statement statement=null;
		ResultSet result=null;
		ArrayList<String> list=new ArrayList<String>();

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NODE FROM TEMP_COMMON_ANCESTORS WHERE DISEASE_NODE_NUM=1;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				String node=result.getString(1);
				if(list.contains(node)==false)
					list.add(node);
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return list;
	}
	 */
	public ArrayList<String> getNodeIDList(ArrayList<String> nameList) {
		ArrayList<String> nodeIDList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement, nodeList="";

			for(int i=0; i<nameList.size(); i++)
			{
				if(i>0)
					nodeList=nodeList+",";
				nodeList=nodeList+"'"+nameList.get(i)+"'";
			}	

			sqlStatement="SELECT SBML_NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_NAME IN ("+nodeList+");";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeIDList.contains(result.getString(1))==false)
					nodeIDList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeIDList;
	}

	public ArrayList<String> getNodeNameList(ArrayList<String> IDlist) {
		ArrayList<String> nodeNameList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement, nodeList="";

			for(int i=0; i<IDlist.size(); i++)
			{
				if(i>0)
					nodeList=nodeList+",";
				nodeList=nodeList+"'"+IDlist.get(i)+"'";
			}	

			sqlStatement="SELECT SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE SBML_NODE_ID IN ("+nodeList+");";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeNameList.contains(result.getString(1))==false)
					nodeNameList.add(result.getString(1));
			}

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return nodeNameList;
	}

	public ArrayList<edge> getEdgeList(ArrayList<String> list) {
		ArrayList<edge> edgeList=new ArrayList<edge>();
		ArrayList<Integer> nodeIDList=new ArrayList<Integer>();
		Statement statement=null, statement1;
		ResultSet result=null, result1 = null;

		try {
			statement = conn.createStatement();
			statement1=conn.createStatement();

			String sqlStatement, nodeListString="", nodeIDListString="";

			for(int i=0; i<list.size(); i++)
			{
				if(i>0)
					nodeListString=nodeListString+",";
				nodeListString=nodeListString+"'"+list.get(i)+"'";
			}	

			//System.out.println("[getEdgeList] nodeList:"+nodeListString.toString());

			sqlStatement="SELECT NODE_ID FROM CURR_NETWORK_NODE WHERE SBML_NODE_NAME IN ("+nodeListString+");";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				if(nodeIDList.contains(result.getInt(1))==false)
					nodeIDList.add(result.getInt(1));
			}

			for(int i=0; i<nodeIDList.size(); i++)
			{
				if(i>0)
					nodeIDListString=nodeIDListString+",";
				nodeIDListString=nodeIDListString+"'"+nodeIDList.get(i)+"'";
			}

			//System.out.println("[getEdgeList] nodeIDList:"+nodeIDList.toString());

			sqlStatement="SELECT SOURCE_NODE_ID, TARGET_NODE_ID, EDGE_TYPE FROM CURR_NETWORK_EDGE WHERE SOURCE_NODE_ID IN ("+nodeIDListString+") AND TARGET_NODE_ID IN ("+nodeIDListString+");";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
			{
				int sourceID=result.getInt(1);
				int targetID=result.getInt(2);
				String edgeType=result.getString(3);

				//System.out.println("[getEdgeList] sourceID:"+sourceID+" targetID:"+targetID+" edgeType:"+edgeType);

				result1=statement1.executeQuery("SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+sourceID+"';");
				String sourceNodeID = null, sourceNodeName=null;
				while(result1.next())
				{
					sourceNodeID=result1.getString(1);
					sourceNodeName=result1.getString(2);
				}

				result1=statement1.executeQuery("SELECT SBML_NODE_ID, SBML_NODE_NAME FROM CURR_NETWORK_NODE WHERE NODE_ID='"+targetID+"';");
				String targetNodeID=null, targetNodeName=null;
				while(result1.next())
				{
					targetNodeID=result1.getString(1);
					targetNodeName=result1.getString(2);
				}

				//System.out.println("[getEdgeList] sourceNodeID:"+sourceNodeID+" sourceNodeName:"+sourceNodeName+" targetNodeID:"+targetNodeID+" targetNodeName:"+targetNodeName);

				edge e=new edge(sourceNodeID, sourceNodeName, targetNodeID, targetNodeName, edgeType);
				if(edgeList.contains(e)==false)
					edgeList.add(e);
			}

			statement.close();
			statement1.close();
			result.close();
			result1.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return edgeList;
	}

	public ArrayList<String> getNetworkMetadata_networkList() {
		ArrayList<String> networkList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT NETWORK_NAME FROM CURR_NETWORK_METADATA;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
				networkList.add(result.getString(1));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return networkList;
	}

	public ArrayList<String> getNetworkMetadata_versionList() {
		ArrayList<String> versionList=new ArrayList<String>();
		Statement statement=null;
		ResultSet result=null;

		try {
			statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT VERSION FROM CURR_NETWORK_METADATA;";
			result=statement.executeQuery(sqlStatement);

			while(result.next())
				versionList.add(result.getString(1));

			statement.close();
			result.close();
		}catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		}

		return versionList;
	}

	public double getCOfModel(String modelAccuracy) {
		double C=0;

		try {
			Statement statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT C FROM CURR_NETWORK_MODEL_ACCURACY WHERE ACCURACY='"+modelAccuracy+"';";
			ResultSet result=statement.executeQuery(sqlStatement);

			if(result.next())
				C=result.getDouble(1);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return C;
	}

	public String getMaxAccuracy(String weight) {
		String maxAccuracy=null;

		try {
			Statement statement = conn.createStatement();
			String sqlStatement;

			sqlStatement="SELECT MAX(ACCURACY) FROM CURR_NETWORK_MODEL_ACCURACY WHERE WEIGHT='"+weight+"';";
			ResultSet result=statement.executeQuery(sqlStatement);

			if(result.next())
				maxAccuracy=result.getString(1);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 

		return maxAccuracy;
	}

	public void addNewModelAccuracy(String accuracy, int weight, String CParam, ArrayList<String> featuresToRemove) {
		try {
			Statement statement = conn.createStatement();
			int maxID=0;
			String sqlStatement;
			ArrayList<Integer> featureToRemoveValues=new ArrayList<Integer>();

			//find current maximum ID in table
			sqlStatement="SELECT COUNT(MODEL_ID) FROM CURR_NETWORK_MODEL_ACCURACY;";
			ResultSet result=statement.executeQuery(sqlStatement);
			if(result.next())
				maxID=result.getInt(1)+1;
			else
				maxID=1;

			if(featuresToRemove.contains(IN_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(OUT_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(TOTAL_DEGREE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(EIGENVECTOR)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(CLOSENESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(ECCENTRICITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BETWEENNESS)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);

			if(featuresToRemove.contains(BRIDGING_CENTRALITY)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(UNDIRECTED_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(IN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(OUT_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(CYCLE_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(MIDDLEMAN_CLUSTERING_COEFFICIENT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(PROXIMITY_PRESTIGE)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			if(featuresToRemove.contains(TARGET_DOWNSTREAM_EFFECT)==true)
				featureToRemoveValues.add(1);
			else
				featureToRemoveValues.add(0);			

			sqlStatement="INSERT INTO CURR_NETWORK_MODEL_ACCURACY (MODEL_ID, WEIGHT, C, ACCURACY, IN_DEGREE, OUT_DEGREE, TOTAL_DEGREE, "
					+ "EIGENVECTOR, CLOSENESS, ECCENTRICITY, BETWEENNESS, BRIDGING_COEFFICIENT, BRIDGING_CENTRALITY, UNDIRECTED_CLUSTERING_COEFFICIENT, "
					+ "IN_CLUSTERING_COEFFICIENT, OUT_CLUSTERING_COEFFICIENT, CYCLE_CLUSTERING_COEFFICIENT, MIDDLEMAN_CLUSTERING_COEFFICIENT, "
					+ "PROXIMITY_PRESTIGE, TARGET_DOWNSTREAM_EFFECT) VALUES ('"+maxID+"', '"+weight+"', '"+CParam+"', '"+accuracy+"', '"+featureToRemoveValues.get(0)+"', '"+featureToRemoveValues.get(1)
					+ "', '"+featureToRemoveValues.get(2)+"', '"+featureToRemoveValues.get(3)+"', '"+featureToRemoveValues.get(4)+"', '"+featureToRemoveValues.get(5)
					+ "', '"+featureToRemoveValues.get(6)+"', '"+featureToRemoveValues.get(7)+"', '"+featureToRemoveValues.get(8)+"', '"+featureToRemoveValues.get(9)
					+ "', '"+featureToRemoveValues.get(10)+"', '"+featureToRemoveValues.get(11)+"', '"+featureToRemoveValues.get(12)+"', '"+featureToRemoveValues.get(13)
					+ "', '"+featureToRemoveValues.get(14)+"', '"+featureToRemoveValues.get(15)+"');";
			statement.execute(sqlStatement);

			statement.close();
			result.close();
		} catch (SQLException ex) {
			// handle any errors
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
		} 
	}

	public boolean getComputedFeature(String feature)
	{
		if(feature.compareTo(IN_DEGREE)==0)
			return COMPUTED_IN_DEGREE;
		else if(feature.compareTo(OUT_DEGREE)==0)
			return COMPUTED_OUT_DEGREE;
		else if(feature.compareTo(TOTAL_DEGREE)==0)
			return COMPUTED_TOTAL_DEGREE;
		else if(feature.compareTo(EIGENVECTOR)==0)
			return COMPUTED_EIGENVECTOR;
		else if(feature.compareTo(CLOSENESS)==0)
			return COMPUTED_CLOSENESS;
		else if(feature.compareTo(ECCENTRICITY)==0)
			return COMPUTED_ECCENTRICITY;
		else if(feature.compareTo(BETWEENNESS)==0)
			return COMPUTED_BETWEENNESS;
		else if(feature.compareTo(BRIDGING_COEFFICIENT)==0)
			return COMPUTED_BRIDGING_COEFFICIENT;
		else if(feature.compareTo(BRIDGING_CENTRALITY)==0)
			return COMPUTED_BRIDGING_CENTRALITY;
		else if(feature.compareTo(UNDIRECTED_CLUSTERING_COEFFICIENT)==0)
			return COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT;
		else if(feature.compareTo(IN_CLUSTERING_COEFFICIENT)==0)
			return COMPUTED_IN_CLUSTERING_COEFFICIENT;
		else if(feature.compareTo(OUT_CLUSTERING_COEFFICIENT)==0)
			return COMPUTED_OUT_CLUSTERING_COEFFICIENT;
		else if(feature.compareTo(CYCLE_CLUSTERING_COEFFICIENT)==0)
			return COMPUTED_CYCLE_CLUSTERING_COEFFICIENT;
		else if(feature.compareTo(MIDDLEMAN_CLUSTERING_COEFFICIENT)==0)
			return COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT;
		else if(feature.compareTo(PROXIMITY_PRESTIGE)==0)
			return COMPUTED_PROXIMITY_PRESTIGE;
		else if(feature.compareTo(TARGET_DOWNSTREAM_EFFECT)==0)
			return COMPUTED_TARGET_DOWNSTREAM_EFFECT;
		else if(feature.compareTo(PROBABILITY_COEFFICIENT)==0)
			return COMPUTED_PROBABILITY_COEFFICIENT;
		else
			return false;
	}

	public void resetComputedFeature()
	{
		COMPUTED_IN_DEGREE=false;
		COMPUTED_OUT_DEGREE=false;
		COMPUTED_TOTAL_DEGREE=false;
		COMPUTED_EIGENVECTOR=false;
		COMPUTED_CLOSENESS=false;
		COMPUTED_ECCENTRICITY=false;
		COMPUTED_BETWEENNESS=false;
		COMPUTED_BRIDGING_COEFFICIENT=false;
		COMPUTED_BRIDGING_CENTRALITY=false;
		COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT=false;
		COMPUTED_IN_CLUSTERING_COEFFICIENT=false;
		COMPUTED_OUT_CLUSTERING_COEFFICIENT=false;
		COMPUTED_CYCLE_CLUSTERING_COEFFICIENT=false;
		COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT=false;
		COMPUTED_PROXIMITY_PRESTIGE=false;
		COMPUTED_TARGET_DOWNSTREAM_EFFECT=false;
		COMPUTED_PROBABILITY_COEFFICIENT=false;
	}

	public void resetComputedFeature_subset(ArrayList<String> featureList)
	{
		if(featureList.contains(IN_DEGREE))
			COMPUTED_IN_DEGREE=false;
		if(featureList.contains(OUT_DEGREE))
			COMPUTED_OUT_DEGREE=false;
		if(featureList.contains(TOTAL_DEGREE))
			COMPUTED_TOTAL_DEGREE=false;
		if(featureList.contains(EIGENVECTOR))
			COMPUTED_EIGENVECTOR=false;
		if(featureList.contains(CLOSENESS))
			COMPUTED_CLOSENESS=false;
		if(featureList.contains(ECCENTRICITY))
			COMPUTED_ECCENTRICITY=false;
		if(featureList.contains(BETWEENNESS))
			COMPUTED_BETWEENNESS=false;
		if(featureList.contains(BRIDGING_COEFFICIENT))
			COMPUTED_BRIDGING_COEFFICIENT=false;
		if(featureList.contains(BRIDGING_CENTRALITY))
			COMPUTED_BRIDGING_CENTRALITY=false;
		if(featureList.contains(UNDIRECTED_CLUSTERING_COEFFICIENT))
			COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT=false;
		if(featureList.contains(IN_CLUSTERING_COEFFICIENT))
			COMPUTED_IN_CLUSTERING_COEFFICIENT=false;
		if(featureList.contains(OUT_CLUSTERING_COEFFICIENT))
			COMPUTED_OUT_CLUSTERING_COEFFICIENT=false;
		if(featureList.contains(CYCLE_CLUSTERING_COEFFICIENT))
			COMPUTED_CYCLE_CLUSTERING_COEFFICIENT=false;
		if(featureList.contains(MIDDLEMAN_CLUSTERING_COEFFICIENT))
			COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT=false;
		if(featureList.contains(PROXIMITY_PRESTIGE))
			COMPUTED_PROXIMITY_PRESTIGE=false;
		if(featureList.contains(TARGET_DOWNSTREAM_EFFECT))
			COMPUTED_TARGET_DOWNSTREAM_EFFECT=false;
		if(featureList.contains(PROBABILITY_COEFFICIENT))
			COMPUTED_PROBABILITY_COEFFICIENT=false;
	}

	public void setComputedFeature(String feature, boolean done)
	{
		if(feature.compareTo(IN_DEGREE)==0)
			COMPUTED_IN_DEGREE=done;
		else if(feature.compareTo(OUT_DEGREE)==0)
			COMPUTED_OUT_DEGREE=done;
		else if(feature.compareTo(TOTAL_DEGREE)==0)
			COMPUTED_TOTAL_DEGREE=done;
		else if(feature.compareTo(EIGENVECTOR)==0)
			COMPUTED_EIGENVECTOR=done;
		else if(feature.compareTo(CLOSENESS)==0)
			COMPUTED_CLOSENESS=done;
		else if(feature.compareTo(ECCENTRICITY)==0)
			COMPUTED_ECCENTRICITY=done;
		else if(feature.compareTo(BETWEENNESS)==0)
			COMPUTED_BETWEENNESS=done;
		else if(feature.compareTo(BRIDGING_COEFFICIENT)==0)
			COMPUTED_BRIDGING_COEFFICIENT=done;
		else if(feature.compareTo(BRIDGING_CENTRALITY)==0)
			COMPUTED_BRIDGING_CENTRALITY=done;
		else if(feature.compareTo(UNDIRECTED_CLUSTERING_COEFFICIENT)==0)
			COMPUTED_UNDIRECTED_CLUSTERING_COEFFICIENT=done;
		else if(feature.compareTo(IN_CLUSTERING_COEFFICIENT)==0)
			COMPUTED_IN_CLUSTERING_COEFFICIENT=done;
		else if(feature.compareTo(OUT_CLUSTERING_COEFFICIENT)==0)
			COMPUTED_OUT_CLUSTERING_COEFFICIENT=done;
		else if(feature.compareTo(CYCLE_CLUSTERING_COEFFICIENT)==0)
			COMPUTED_CYCLE_CLUSTERING_COEFFICIENT=done;
		else if(feature.compareTo(MIDDLEMAN_CLUSTERING_COEFFICIENT)==0)
			COMPUTED_MIDDLEMAN_CLUSTERING_COEFFICIENT=done;
		else if(feature.compareTo(PROXIMITY_PRESTIGE)==0)
			COMPUTED_PROXIMITY_PRESTIGE=done;
		else if(feature.compareTo(TARGET_DOWNSTREAM_EFFECT)==0)
			COMPUTED_TARGET_DOWNSTREAM_EFFECT=done;
		else if(feature.compareTo(PROBABILITY_COEFFICIENT)==0)
			COMPUTED_PROBABILITY_COEFFICIENT=done;
	}
}
